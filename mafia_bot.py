from __future__ import annotations
from dataclasses import dataclass
import pickle, os, random, asyncio
import telegram.error
import jdatetime
import requests
import json, httpx
import sys
import re
import asyncio
import regex
import subprocess
from html import escape
from telegram.ext import filters
from telegram.error import RetryAfter, TimedOut, BadRequest
group_filter = filters.ChatType.GROUPS
from datetime import datetime, timezone, timedelta  
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ForceReply, Message
from telegram.ext import (
    ApplicationBuilder, CommandHandler, CallbackQueryHandler,
    MessageHandler, ContextTypes, filters
)
from collections import defaultdict
# --- CALLBACK DATA CONSTANTS ---
BTN_PLAYER  = "player_name"    
BTN_DELETE  = "delete_seat"      
BTN_START   = "start_game"      
BTN_CALL = "call_players"   
BTN_REROLL = "reroll_roles" 
MAFIA_FILENAME = "mafia.json"
 

GH_TOKEN = os.environ.get("GH_TOKEN")
GIST_ID = os.environ.get("GIST_ID")
GIST_FILENAME = "gistfile1.txt"
GIST_API_URL = f"https://api.github.com/gists/{GIST_ID}"


USERNAMES_FILENAME = "usernames.json" 
TOKEN = os.environ.get("TOKEN")
PERSIST_FILE = "mafia_data.pkl"
SEAT_EMOJI = "üë§"; LOCKED_EMOJI = "üîí"; GOD_EMOJI = "üë≥üèª‚Äç‚ôÇÔ∏è"; START_EMOJI = "üöÄ"

def load_active_groups() -> set[int]:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; load_active_groups -> empty set")
            return set()
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        r = requests.get(url, headers=headers, timeout=10)
        if r.status_code != 200:
            print("‚ùå load_active_groups failed:", r.status_code, r.text)
            return set()
        data = r.json()
        content = data["files"].get("active_groups.json", {}).get("content", "[]")
        arr = json.loads(content) if content else []
        return set(int(x) for x in arr)
    except Exception as e:
        print("‚ùå load_active_groups error:", e)
        return set()

def save_active_groups(active_groups: set[int]) -> bool:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; save_active_groups skipped")
            return False
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        payload = {
            "files": {
                "active_groups.json": {
                    "content": json.dumps(sorted(list(active_groups)), ensure_ascii=False, indent=2)
                }
            }
        }
        r = requests.patch(url, headers=headers, json=payload, timeout=10)
        if r.status_code not in (200, 201):
            print("‚ùå save_active_groups failed:", r.status_code, r.text)
            return False
        return True
    except Exception as e:
        print("‚ùå save_active_groups error:", e)
        return False

@dataclass
class Scenario:
    name: str
    roles: dict[str, int]

@dataclass
class GameState:
    god_id: int | None = None
    god_name: str | None = None
    seats: dict[int, tuple[int, str]] | None = None
    event_time: str | None = None
    max_seats: int = 0
    scenario: Scenario | None = None
    phase: str = "idle"

    waiting_name: dict[int, int] | None = None
    waiting_name_proxy: dict[int, int] | None = None
    waiting_god: set[int] | None = None
    awaiting_scenario: bool = False

    assigned_roles: dict[int, str] | None = None
    striked: set[int] | None = None
    voting: dict[int, list[int]] | None = None
    current_vote_target: int | None = None
    vote_type: str | None = None
    vote_candidates: list[int] | None = None
    votes_cast: dict[int, set[int]] | None = None
    defense_seats: list[int] | None = None
    last_seating_msg_id: int | None = None
    last_roles_msg_id: int | None = None
    last_roles_scenario_name: str | None = None
    winner_side: str | None = None
    awaiting_winner: bool = False
    last_vote_msg_id: int | None = None
    defense_prompt_msg_id: int | None = None
    strike_control_msg_id = None
    strike_list_msg_id = None
    awaiting_players: set[int] | None = None
    awaiting_name_input: dict[int, int] = None
    last_name_prompt_msg_id: dict[int, int] = None
    from_startgame: bool = False
    awaiting_shuffle_decision: bool = False
    shuffle_prompt_msg_id: int | None = None
    purchased_seat: int | None = None
    awaiting_purchase_number: bool = False
    pending_strikes: set[int] | None = None 
    status_counts: dict[str, int] = None
    status_mode: bool = False 
    ui_hint: str | None = None
    warnings: dict[int, int] | None = None
    warning_mode: bool = False
    pending_warnings: dict[int, int] | None = None
    remaining_cards: dict[str, list[str]] = None


    def __post_init__(self):
        self.seats = self.seats or {}
        self.waiting_name = self.waiting_name or {}
        self.waiting_name_proxy = self.waiting_name_proxy or {}
        self.waiting_god = self.waiting_god or set()
        self.assigned_roles = self.assigned_roles or {}
        self.striked = self.striked or set()
        self.strike_backup_seats = {}
        self.strike_control_msg_id = None
        self.voting = self.voting or {}
        self.vote_candidates = self.vote_candidates or []
        self.defense_seats = self.defense_seats or []
        self.awaiting_players = self.awaiting_players or set()
        self.defense_prompt_msg_id = self.defense_prompt_msg_id or None
        self.awaiting_seat = {}
        self.pending_name_msgs = {}
        self.awaiting_name_input = self.awaiting_name_input or {}
        self.last_name_prompt_msg_id = self.last_name_prompt_msg_id or {}
        self.user_names = {}
        self.selected_defense = []
        self.vote_messages: list = []
        self.last_roles_msg_id = None
        self.awaiting_shuffle_decision = False
        self.shuffle_prompt_msg_id = None
        self.awaiting_purchase_number = False
        self.pending_strikes = self.pending_strikes or set()
        self.status_counts = self.status_counts or {"citizen": 0, "mafia": 0}
        self.status_mode = False
        self.preview_uid_to_role = getattr(self, "preview_uid_to_role", None)
        self.shuffle_repeats = getattr(self, "shuffle_repeats", None) 
        self.chaos_mode = False        
        self.chaos_selected = set()       
        self.purchased_seat = None    
        self.pending_delete = getattr(self, "pending_delete", None) or set()  
        self.warnings = self.warnings or {}
        self.pending_warnings = self.pending_warnings or {}
        self.warning_mode = getattr(self, "warning_mode", False)
        self.remaining_cards = self.remaining_cards or {}
        self.votes_cast = self.votes_cast or {}


  

class Store:
    def __init__(self, path=PERSIST_FILE):
        self.path = path
        self.scenarios: list[Scenario] = []
        self.games: dict[int, GameState] = {}
        self.group_stats: dict[int, dict] = {}
        self.active_groups: set[int] = set()
        self.load()

    def load(self):
        if os.path.exists(self.path):
            with open(self.path, "rb") as f:
                obj = pickle.load(f)
                self.scenarios = obj.get("scenarios", [])
                self.games = obj.get("games", {})
                self.group_stats = obj.get("group_stats", {})
                # ‚¨áÔ∏è ŸÖŸÜÿ®ÿπ ÿ≠ŸÇ€åŸÇÿ™: Gist
                ag = load_active_groups()
                self.active_groups = ag if ag else set(obj.get("active_groups", []))
                for g in self.games.values():
                    if isinstance(g, GameState):
                        g.__post_init__()
        else:
          
            self.scenarios = []
            self.games = {}
            self.group_stats = {}
            self.active_groups = load_active_groups()  
            self.save()  # ÿ®ÿπÿØÿßŸã ÿ±Ÿà€å ÿØ€åÿ≥⁄© ÿ∞ÿÆ€åÿ±Ÿá ⁄©ŸÜ

    def save(self):
        with open(self.path, "wb") as f:
            pickle.dump({
                "scenarios": self.scenarios,
                "games": self.games,
                "group_stats": self.group_stats,
                "active_groups": list(self.active_groups)
            }, f)


def save_scenarios_to_gist(scenarios):
    if not GH_TOKEN or not GIST_ID:
        return

    url = f"https://api.github.com/gists/{GIST_ID}"
    headers = {
        "Authorization": f"token {GH_TOKEN}",
        "Accept": "application/vnd.github+json",
    }
    data = {
        "files": {
            GIST_FILENAME: {
                "content": json.dumps({"scenarios": [s.__dict__ for s in scenarios]}, ensure_ascii=False, indent=2)
            }
        }
    }

    try:
        httpx.patch(url, headers=headers, json=data)
    except Exception as e:
        print("‚ùå save_scenarios error:", e)

def load_scenarios_from_gist():
    if not GH_TOKEN or not GIST_ID:
        return []

    url = f"https://api.github.com/gists/{GIST_ID}"
    headers = {
        "Authorization": f"token {GH_TOKEN}",
        "Accept": "application/vnd.github+json",
    }

    try:
        response = httpx.get(url, headers=headers)
        if response.status_code == 200:
            gist_data = response.json()
            content = gist_data["files"][GIST_FILENAME]["content"]
            data = json.loads(content)
            return [Scenario(name=s["name"], roles=s["roles"]) for s in data.get("scenarios", [])]
        else:
            print("‚ùå Gist fetch failed:", response.status_code)
            return []
    except Exception as e:
        print("‚ùå load_scenarios error:", e)
        return []
def load_usernames_from_gist():
    try:
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {
            "Authorization": f"token {GH_TOKEN}",
            "Accept": "application/vnd.github+json",
        }

        response = httpx.get(url, headers=headers)
        if response.status_code == 200:
            gist_data = response.json()
            content = gist_data["files"].get(USERNAMES_FILENAME, {}).get("content", "{}")
            data = json.loads(content) or {}
            return {int(k): v for k, v in data.items()}  # üëà ⁄©ŸÑ€åÿØŸáÿß ÿ±Ÿà ÿ™ÿ®ÿØ€åŸÑ ⁄©ŸÜ ÿ®Ÿá ÿπÿØÿØ
        else:
            print("‚ùå user_names gist fetch failed:", response.status_code)
            return {}
    except Exception as e:
        print("‚ùå load_usernames error:", e)
        return {}

def save_usernames_to_gist(usernames: dict[int, str]):
    try:
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {
            "Authorization": f"token {GH_TOKEN}",
            "Accept": "application/vnd.github+json",
        }
        data = {
            "files": {
                USERNAMES_FILENAME: {
                    "content": json.dumps(usernames, ensure_ascii=False, indent=2)
                }
            }
        }
        httpx.patch(url, headers=headers, json=data)
    except Exception as e:
        print("‚ùå save_usernames error:", e)


store = Store()
store.scenarios = load_scenarios_from_gist()

# ŸÑŸàÿØ ⁄©ÿ±ÿØŸÜ ŸÜÿßŸÖ‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿßÿ≤ Gist ÿ®ÿ±ÿß€å ÿ™ŸÖÿßŸÖ ⁄Ø€åŸÖ‚ÄåŸáÿß
usernames = load_usernames_from_gist()
for g in store.games.values():
    g.user_names = usernames



def gs(chat_id):
    g = store.games.setdefault(chat_id, GameState())
    if not g.user_names:
        g.user_names = load_usernames_from_gist()  # ‚Üê ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿßÿ≥ÿßŸÖ€å ÿßÿ≤ Gist
    return g

def load_event_numbers():
    url = f"https://api.github.com/gists/{GIST_ID}"
    res = requests.get(url, headers={"Authorization": f"token {GH_TOKEN}"})
    data = res.json()
    content = data["files"]["event_numbers.json"]["content"]
    try:
        return json.loads(content)
    except:
        return {}

def save_event_numbers(event_numbers: dict) -> bool:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; save_event_numbers skipped")
            return False
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        payload = {
            "files": {
                "event_numbers.json": {
                    "content": json.dumps(event_numbers, ensure_ascii=False, indent=2)
                }
            }
        }
        res = requests.patch(url, headers=headers, json=payload, timeout=10)
        if res.status_code not in (200, 201):
            print("‚ùå save_event_numbers PATCH failed:", res.status_code, res.text)
            return False

        # ‚úÖ ⁄©ÿ¥ ÿ±ÿß ŸáŸÖÿ≤ŸÖÿßŸÜ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ⁄©ŸÜ
        global EVENT_NUMBERS_CACHE
        EVENT_NUMBERS_CACHE = event_numbers
        return True
    except Exception as e:
        print("‚ùå save_event_numbers error:", e)
        return False


def load_mafia_roles() -> set[str]:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; load_mafia_roles -> empty set")
            return set()
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        r = requests.get(url, headers=headers, timeout=10)
        if r.status_code != 200:
            print("‚ùå load_mafia_roles failed:", r.status_code, r.text)
            return set()
        data = r.json()
        content = data["files"].get(MAFIA_FILENAME, {}).get("content", "[]")
        arr = json.loads(content) if content else []
        # ÿ±ÿ¥ÿ™Ÿá‚ÄåŸáÿß€å ÿÆÿßŸÑ€å ÿ±Ÿà ÿ≠ÿ∞ŸÅ ⁄©ŸÜ
        clean = [x.strip() for x in arr if isinstance(x, str) and x.strip()]
        return set(clean)
    except Exception as e:
        print("‚ùå load_mafia_roles error:", e)
        return set()

def save_mafia_roles(roles: set[str]) -> bool:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; save_mafia_roles skipped")
            return False
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        payload = {
            "files": {
                MAFIA_FILENAME: {
                    "content": json.dumps(sorted(list(roles)), ensure_ascii=False, indent=2)
                }
            }
        }
        r = requests.patch(url, headers=headers, json=payload, timeout=10)
        if r.status_code not in (200, 201):
            print("‚ùå save_mafia_roles failed:", r.status_code, r.text)
            return False
        return True
    except Exception as e:
        print("‚ùå save_mafia_roles error:", e)
        return False


INDEP_FILENAME = "indep_roles.json"

def load_indep_roles() -> dict[str, list[str]]:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; load_indep_roles -> empty dict")
            return {}
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        r = requests.get(url, headers=headers, timeout=10)
        if r.status_code != 200:
            print("‚ùå load_indep_roles failed:", r.status_code, r.text)
            return {}
        data = r.json()
        content = data["files"].get("indep_roles.json", {}).get("content", "{}")
        roles = json.loads(content) if content else {}
        return roles  # ‚Üê ÿ≠ÿßŸÑÿß ÿÆÿ±Ÿàÿ¨€å ŸÖÿ´ŸÑ ÿ¨€åÿ≥ÿ™ÿ™ Ÿáÿ≥ÿ™
    except Exception as e:
        print("‚ùå load_indep_roles error:", e)
        return {}


def save_indep_roles(indep: dict[str, list[str]]) -> bool:
    try:
        if not GH_TOKEN or not GIST_ID:
            return False
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        payload = {
            "files": {
                INDEP_FILENAME: {"content": json.dumps(indep, ensure_ascii=False, indent=2)}
            }
        }
        r = requests.patch(url, headers=headers, json=payload, timeout=10)
        return r.status_code == 200
    except Exception as e:
        print("‚ùå save_indep_roles error:", e)
        return False




def load_stickers():
    url = f"https://api.github.com/gists/{GIST_ID}"
    res = requests.get(url, headers={"Authorization": f"token {GH_TOKEN}"})
    data = res.json()
    content = data["files"]["stickers.json"]["content"]
    try:
        return json.loads(content)
    except:
        return {}

def save_stickers(stickers):
    url = f"https://api.github.com/gists/{GIST_ID}"
    files = {
        "stickers.json": {
            "content": json.dumps(stickers, ensure_ascii=False, indent=2)
        }
    }
    requests.patch(url, headers={"Authorization": f"token {GH_TOKEN}"}, json={"files": files})


def text_seating_keyboard(g: GameState) -> InlineKeyboardMarkup:
    rows = [
        [
            InlineKeyboardButton("‚ùå ÿ≠ÿ∞ŸÅ ", callback_data=BTN_DELETE),
            InlineKeyboardButton("‚è∞ ÿ™ÿ∫€å€åÿ± ÿ≥ÿßÿπÿ™", callback_data="change_time"),   
        
        ],
        [
            InlineKeyboardButton("üßπ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ", callback_data="cleanup"),
            InlineKeyboardButton("‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™", callback_data="settings_menu")
        ],
        [
            InlineKeyboardButton("‚Ü©Ô∏è ŸÑÿ∫Ÿà", callback_data="cancel_self"),
            InlineKeyboardButton("‚úèÔ∏è ÿ™ÿ∫€å€åÿ± ŸÜÿßŸÖ", callback_data="change_name")
        ]

    ]

    if g.god_id:
        # ÿ±ÿØ€åŸÅ ÿßŸàŸÑ: ÿµÿØÿß ÿ≤ÿØŸÜ + ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà
        rows.append([
            InlineKeyboardButton("üîä ÿµÿØÿß ÿ≤ÿØŸÜ", callback_data=BTN_CALL),
            InlineKeyboardButton("ü™Ñ ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà", callback_data="change_scenario")
        ])

        # ÿ±ÿØ€åŸÅ ÿØŸàŸÖ: ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å + ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥ (ŸÅŸÇÿ∑ ŸàŸÇÿ™€å ŸáŸÖŸá ÿµŸÜÿØŸÑ€åÿß Ÿæÿ±Ÿá)
        if len(g.seats) == g.max_seats:
            rows.append([
                InlineKeyboardButton("‚ñ∂Ô∏è ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å", callback_data="startgame"),
                InlineKeyboardButton("üé≤ ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥", callback_data=BTN_REROLL)
            ])

    return InlineKeyboardMarkup(rows)

def settings_keyboard() -> InlineKeyboardMarkup:
    rows = [
        [InlineKeyboardButton("‚ûï ÿ≥ŸÜÿßÿ±€åŸà ÿ¨ÿØ€åÿØ", callback_data="add_scenario")],
        [InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿ±⁄Øÿ¥ÿ™", callback_data="back_to_main")]
    ]
    return InlineKeyboardMarkup(rows)


CARDS_FILENAME = "cards.json"

def load_cards() -> dict[str, list[str]]:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; load_cards -> empty dict")
            return {}
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        r = requests.get(url, headers=headers, timeout=10)
        if r.status_code != 200:
            print("‚ùå load_cards failed:", r.status_code, r.text)
            return {}
        data = r.json()
        content = data["files"].get(CARDS_FILENAME, {}).get("content", "{}")
        return json.loads(content) if content else {}
    except Exception as e:
        print("‚ùå load_cards error:", e)
        return {}

def save_cards(cards: dict[str, list[str]]) -> bool:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; save_cards skipped")
            return False
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        payload = {
            "files": {
                CARDS_FILENAME: {
                    "content": json.dumps(cards, ensure_ascii=False, indent=2)
                }
            }
        }
        r = requests.patch(url, headers=headers, json=payload, timeout=10)
        return r.status_code in (200, 201)
    except Exception as e:
        print("‚ùå save_cards error:", e)
        return False


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#  ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ⁄©ŸÜÿ™ÿ±ŸÑ ÿ±ÿßŸà€å ÿØÿ± ÿ≠€åŸÜ ÿ®ÿßÿ≤€å
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def control_keyboard(g: GameState) -> InlineKeyboardMarkup:
    rows = []

    # ÿß⁄Øÿ± ⁄©ÿßÿ±ÿ™ ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿ≥ŸÜÿßÿ±€åŸà Ÿàÿ¨ŸàÿØ ÿØÿßÿ¥ÿ™ ‚Üí ÿßŸàŸÑ ÿ®€åÿßÿØ
    cards = load_cards()
    if g.scenario and g.scenario.name in cards and cards[g.scenario.name]:
        rows.append([InlineKeyboardButton("üÉè ÿ¥ÿßŸÅŸÑ ⁄©ÿßÿ±ÿ™", callback_data="shuffle_card")])

    # ÿ®ÿπÿØ ÿ®ŸÇ€åŸá ÿØ⁄©ŸÖŸá‚ÄåŸáÿß
    rows.extend([
        [InlineKeyboardButton("‚ö†Ô∏è ÿßÿÆÿ∑ÿßÿ±", callback_data="warn_mode")],
        [InlineKeyboardButton("‚úÇÔ∏è ÿÆÿ∑‚Äåÿ≤ÿØŸÜ", callback_data="strike_out")],
        [InlineKeyboardButton("üìä ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™ (ÿßÿ™ŸàŸÖÿßÿ™)", callback_data="status_auto")],
        [InlineKeyboardButton("üìä ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™ (ÿØÿ≥ÿ™€å)", callback_data="status_query")],
        [InlineKeyboardButton("üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá", callback_data="init_vote")],
        [InlineKeyboardButton("üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å", callback_data="final_vote")],
        [InlineKeyboardButton("üèÅ ÿßÿ™ŸÖÿßŸÖ ÿ®ÿßÿ≤€å", callback_data="end_game")]
    ])

    return InlineKeyboardMarkup(rows)



def warn_button_markup_plusminus(g: GameState) -> InlineKeyboardMarkup:
    # ÿßÿ≤ dict ÿ®ŸàÿØŸÜ ŸÖÿ∑ŸÖÿ¶ŸÜ ÿ¥Ÿà
    pw = g.pending_warnings if isinstance(g.pending_warnings, dict) else {}
    w  = g.warnings          if isinstance(g.warnings, dict)          else {}

    rows = []
    # ŸÅŸÇÿ∑ ÿ≤ŸÜÿØŸá‚ÄåŸáÿß
    alive = [s for s in sorted(g.seats) if s not in g.striked]
    for s in alive:
        base = pw.get(s, w.get(s, 0))
        try:
            n = int(base)
        except Exception:
            n = 0
       
        n = max(0, n)
        icons = "‚ùóÔ∏è" * n if n > 0 else "(0)"
        label = f"{s} {icons}"

        rows.append([
            InlineKeyboardButton("‚ûñ", callback_data=f"warn_dec_{s}"),
            InlineKeyboardButton(label, callback_data="noop"),
            InlineKeyboardButton("‚ûï", callback_data=f"warn_inc_{s}"),
        ])

    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="warn_confirm")])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="warn_back")])
    return InlineKeyboardMarkup(rows)




def kb_endgame_root(g: GameState) -> InlineKeyboardMarkup:
    rows = [
        [InlineKeyboardButton("üèô ÿ¥Ÿáÿ±", callback_data="winner_city")],
        [InlineKeyboardButton("üòà ŸÖÿßŸÅ€åÿß", callback_data="winner_mafia")],
        [InlineKeyboardButton("üèô ⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™ ÿ¥Ÿáÿ±", callback_data="clean_city")],
        [InlineKeyboardButton("üòà ⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™ ŸÖÿßŸÅ€åÿß", callback_data="clean_mafia")],
        [InlineKeyboardButton("üèô ÿ¥Ÿáÿ± (⁄©€å‚Äåÿ¢ÿ≥)", callback_data="winner_city_chaos")],
        [InlineKeyboardButton("üòà ŸÖÿßŸÅ€åÿß (⁄©€å‚Äåÿ¢ÿ≥)", callback_data="winner_mafia_chaos")],
    ]

    indep_roles = load_indep_roles()
    if g.scenario and g.scenario.name in indep_roles and indep_roles[g.scenario.name]:
        rows.append([InlineKeyboardButton("‚ô¶Ô∏è ŸÖÿ≥ÿ™ŸÇŸÑ", callback_data="winner_indep")])

    rows.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_endgame")])
    return InlineKeyboardMarkup(rows)





def kb_purchase_yesno() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ ÿ®ŸÑŸá", callback_data="purchased_yes")],
        [InlineKeyboardButton("‚ùå ÿÆ€åÿ±", callback_data="purchased_no")],
        [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")]
    ])


def kb_pick_single_seat(alive_seats: list[int], selected: int | None,
                        confirm_cb: str, back_cb: str, title: str = "ÿßŸÜÿ™ÿÆÿßÿ® ÿµŸÜÿØŸÑ€å") -> InlineKeyboardMarkup:
    rows = []
    for s in alive_seats:
        label = f"{s} ‚úÖ" if selected == s else f"{s}"
        rows.append([InlineKeyboardButton(label, callback_data=f"pick_single_{s}")])
    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data=confirm_cb)])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_cb)])
    return InlineKeyboardMarkup(rows)


def kb_pick_multi_seats(alive_seats: list[int], selected: set[int],
                        max_count: int, confirm_cb: str, back_cb: str) -> InlineKeyboardMarkup:
    rows = []
    for s in alive_seats:
        label = f"{s} ‚úÖ" if s in selected else f"{s}"
        rows.append([InlineKeyboardButton(label, callback_data=f"toggle_multi_{s}")])
    rows.append([InlineKeyboardButton(f"‚úÖ ÿ™ÿ£€å€åÿØ ({len(selected)}/{max_count})", callback_data=confirm_cb)])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_cb)])
    return InlineKeyboardMarkup(rows)

def delete_button_markup(g: GameState) -> InlineKeyboardMarkup:
    rows = []
    # ŸÅŸÇÿ∑ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å€å ⁄©Ÿá ÿ®ÿßÿ≤€å⁄©ŸÜ ÿØÿßÿ±ŸÜÿØ
    for seat in sorted(g.seats.keys()):
        label = f"{seat} ‚úÖ" if seat in g.pending_delete else f"{seat}"
        rows.append([InlineKeyboardButton(label, callback_data=f"delete_toggle_{seat}")])
    # ⁄©ŸÜÿ™ÿ±ŸÑ‚ÄåŸáÿß
    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ ÿ≠ÿ∞ŸÅ", callback_data="delete_confirm")])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="delete_cancel")])
    return InlineKeyboardMarkup(rows)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÿ®ÿßŸÑÿß€å ŸÅÿß€åŸÑ (€åÿß ⁄©ŸÜÿßÿ± ÿ®ŸÇ€åŸáŸî ÿ´Ÿàÿßÿ®ÿ™) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
REG   = "register"   # ŸÜŸÖÿß€åÿ¥ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ€å
CTRL  = "controls"   # ŸÅŸÇÿ∑ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ⁄©ŸÜÿ™ÿ±ŸÑ€å

async def safe_q_answer(q, text=None, show_alert=False):
    try:
        await q.answer(text, show_alert=show_alert)
    except telegram.error.BadRequest:
        pass
    except Exception:
        pass
async def set_hint_and_kb(ctx, chat_id: int, g: GameState, hint: str | None, kb: InlineKeyboardMarkup, mode: str = CTRL):
    g.ui_hint = hint
    store.save()
    await publish_seating(ctx, chat_id, g, mode=mode, custom_kb=kb)

EVENT_NUMBERS_CACHE = None

def get_event_numbers():
    global EVENT_NUMBERS_CACHE
    if EVENT_NUMBERS_CACHE is None:
        EVENT_NUMBERS_CACHE = load_event_numbers() or {}
    return EVENT_NUMBERS_CACHE


# ---- Concurrency / Debounce / Retry helpers ----
DEBOUNCE_EDIT_SEC = 0.15
SAVE_DEBOUNCE_SEC = 0.30

CHAT_LOCKS: dict[int, asyncio.Lock] = {}
def get_chat_lock(chat_id: int) -> asyncio.Lock:
    lock = CHAT_LOCKS.get(chat_id)
    if lock is None:
        lock = asyncio.Lock()
        CHAT_LOCKS[chat_id] = lock
    return lock


_SAVE_TASK: asyncio.Task | None = None
def save_debounced():
    global _SAVE_TASK
    if _SAVE_TASK and not _SAVE_TASK.done():
        return
    async def _do():
        await asyncio.sleep(SAVE_DEBOUNCE_SEC)
        try:
            store.save()
        except Exception as e:
            print("save_debounced error:", e)
    _SAVE_TASK = asyncio.create_task(_do())

# Retry wrapper for Telegram rate limits
async def _retry(coro):
    try:
        return await coro
    except RetryAfter as e:
        await asyncio.sleep(float(getattr(e, "retry_after", 1.0)) + 0.1)
        return await coro


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÿ™ÿßÿ®ÿπ ÿßÿµŸÑÿßÿ≠‚Äå ÿ¥ÿØŸá ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def publish_seating(
    ctx,
    chat_id: int,
    g: GameState,
    mode: str = REG,
    custom_kb: InlineKeyboardMarkup | None = None,
):
    lock = get_chat_lock(chat_id)
    async with lock:
        await asyncio.sleep(DEBOUNCE_EDIT_SEC)

        if not g.max_seats or g.max_seats <= 0:
            await _retry(ctx.bot.send_message(chat_id, "ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπÿå ÿßÿØŸÖ€åŸÜ ÿ®ÿß€åÿØ /newgame <seats> ÿ®ÿ≤ŸÜÿØ."))
            return

        today = jdatetime.date.today().strftime("%Y/%m/%d")
        emoji_numbers = [
            "‚ìø", "‚ûä", "‚ûã", "‚ûå", "‚ûç", "‚ûé", "‚ûè", "‚ûê", "‚ûë", "‚ûí",
            "‚ûì", "‚ì´", "‚ì¨", "‚ì≠", "‚ìÆ", "‚ìØ", "‚ì∞", "‚ì±", "‚ì≤", "‚ì≥", "‚ì¥"
        ]

        # ÿ¢€åÿØ€å/ŸÑ€åŸÜ⁄© ⁄Øÿ±ŸàŸá
        if not hasattr(g, "_chat_cache"):
            g._chat_cache = {}
        group_id_or_link = f"üÜî {chat_id}"
        if ctx.bot.username and chat_id < 0:
            try:
                if "username" in g._chat_cache and "title" in g._chat_cache:
                    username = g._chat_cache["username"]
                    title = g._chat_cache["title"]
                else:
                    chat_obj = await _retry(ctx.bot.get_chat(chat_id))
                    username = getattr(chat_obj, "username", None)
                    title = getattr(chat_obj, "title", None)
                    g._chat_cache["username"] = username
                    g._chat_cache["title"] = title

                if username:
                    group_id_or_link = f"üîó <a href='https://t.me/{username}'>{title}</a>"
                elif title:
                    group_id_or_link = f"üîí {title}"
            except Exception:
                pass

        # ŸÖÿ™ŸÜ ÿßÿµŸÑ€å
        lines = [
            f"{group_id_or_link}",
            "‚ôöüé≠ <b>ÿ±Ÿà€åÿØÿßÿØ ŸÖÿßŸÅ€åÿß</b>",
            f"‚ôöüìÜ <b>ÿ™ÿßÿ±€åÿÆ:</b> {today}",
            f"‚ôöüï∞ <b>ÿ≤ŸÖÿßŸÜ:</b> {g.event_time or '---'}",
            f"‚ôöüé© <b>ÿ±ÿßŸà€å:</b> <a href='tg://user?id={g.god_id}'>{g.god_name or '‚ùì'}</a>",
        ]

        event_num = int(get_event_numbers().get(str(chat_id), 1))
        lines.insert(1, f"‚ôöüéØ <b>ÿ¥ŸÖÿßÿ±Ÿá ÿ±Ÿà€åÿØÿßÿØ:</b> {event_num}")

        if g.scenario:
            lines.append(f"‚ôöüìú <b>ÿ≥ŸÜÿßÿ±€åŸà:</b> {g.scenario.name} | üë• {sum(g.scenario.roles.values())} ŸÜŸÅÿ±")

        lines.append("\n\n‚ôöüìÇ <b>ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ:</b>\n")

        # ŸÑ€åÿ≥ÿ™ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß
        for i in range(1, g.max_seats + 1):
            emoji_num = emoji_numbers[i] if i < len(emoji_numbers) else str(i)
            if i in g.seats:
                uid, name = g.seats[i]
                safe_name = escape(name, quote=False)
                txt = f"<a href='tg://user?id={uid}'>{safe_name}</a>"

                wn = 0
                if isinstance(getattr(g, "warnings", None), dict):
                    wn = g.warnings.get(i, 0)
                try:
                    wn = int(wn)
                except Exception:
                    wn = 0
                wn = max(0, wn)
                if wn > 0:
                    txt += " " + ("‚ùóÔ∏è" * wn)

                if i in g.striked:
                    txt += " ‚ùå‚ò†Ô∏è"

                line = f"‚ôö{i}  {txt}"
            else:
                line = f"‚ôö{i} ‚¨ú /{i}"
            lines.append(line)

        # ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™
        if g.status_counts.get("citizen", 0) > 0 or g.status_counts.get("mafia", 0) > 0:
            c = g.status_counts.get("citizen", 0)
            m = g.status_counts.get("mafia", 0)
            lines.append(f"\nüßæ <i>ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™: {c} ÿ¥Ÿáÿ±ŸàŸÜÿØ Ÿà {m} ŸÖÿßŸÅ€åÿß</i>")

        if getattr(g, "ui_hint", None):
            lines.append("")
            lines.append(f"‚ÑπÔ∏è <i>{g.ui_hint}</i>")

        text = "\n".join(lines)

        # ÿßŸÜÿ™ÿÆÿßÿ® ⁄©€åÿ®Ÿàÿ±ÿØ
        if custom_kb is not None:
            kb = custom_kb
        else:
            if mode == REG:
                kb = text_seating_keyboard(g)
            elif mode == "strike":
                kb = strike_button_markup(g)
            elif mode == "status":
                kb = status_button_markup(g)
            elif mode == "delete":
                kb = delete_button_markup(g)
            elif mode == "warn":
                kb = warn_button_markup_plusminus(g)
            else:
                kb = control_keyboard(g)

        # --- ÿ∞ÿÆ€åÿ±Ÿá ÿßÿ≥ŸÜŸæ‚Äåÿ¥ÿßÿ™ ÿ¢ÿÆÿ±€åŸÜ ŸÑ€åÿ≥ÿ™ ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤€åÿßÿ®€å ÿ®ÿß /lists ---
        try:
            g.last_snapshot = {
                "text": text,
                "kb": kb.to_dict(),  # ⁄©€åÿ®Ÿàÿ±ÿØ ÿ±Ÿà ÿ®Ÿá dict ÿ∞ÿÆ€åÿ±Ÿá ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
            }
            store.save()
        except Exception as e:
            print("‚ö†Ô∏è snapshot save error:", e)
        # Ÿæ€åÿßŸÖ ŸÑ€åÿ≥ÿ™
        try:
            if g.last_seating_msg_id:
                try:
                    await _retry(ctx.bot.edit_message_text(
                        chat_id=chat_id,
                        message_id=g.last_seating_msg_id,
                        text=text,
                        parse_mode="HTML",
                        reply_markup=kb,
                    ))
                except BadRequest as e:
                    s = str(e)
                    if "message is not modified" in s:
                        try:
                            await _retry(ctx.bot.edit_message_reply_markup(
                                chat_id=chat_id,
                                message_id=g.last_seating_msg_id,
                                reply_markup=kb
                            ))
                        except BadRequest as e2:
                            if "message is not modified" in str(e2):
                                pass
                            else:
                                raise
                    else:
                        raise
            else:
                msg = await _retry(ctx.bot.send_message(
                    chat_id,
                    text,
                    parse_mode="HTML",
                    reply_markup=kb
                ))
                g.last_seating_msg_id = msg.message_id
                if chat_id < 0:
                    try:
                        await _retry(ctx.bot.pin_chat_message(
                            chat_id,
                            msg.message_id,
                            disable_notification=True
                        ))
                    except Exception:
                        pass
        except Exception:
            old_msg_id = g.last_seating_msg_id
            msg = await _retry(ctx.bot.send_message(
                chat_id,
                text,
                parse_mode="HTML",
                reply_markup=kb
            ))
            g.last_seating_msg_id = msg.message_id

            if chat_id < 0:
                try:
                    await _retry(ctx.bot.pin_chat_message(
                        chat_id,
                        msg.message_id,
                        disable_notification=True
                    ))
                except Exception:
                    pass

            if old_msg_id:
                try:
                    await ctx.bot.delete_message(chat_id, old_msg_id)
                except Exception:
                    pass

  
        # ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß
        if g.scenario and mode == REG:
            if getattr(g, "last_roles_scenario_name", None) != g.scenario.name:
                mafia_roles = load_mafia_roles()
                indep_roles = load_indep_roles()
                indep_for_this = indep_roles.get(g.scenario.name, [])
                mafia_lines = ["<b>ŸÜŸÇÿ¥‚ÄåŸáÿß€å ŸÖÿßŸÅ€åÿß:</b>"]
                citizen_lines = ["<b>ŸÜŸÇÿ¥‚ÄåŸáÿß€å ÿ¥Ÿáÿ±ŸàŸÜÿØ:</b>"]
                indep_lines = ["<b>ŸÜŸÇÿ¥‚ÄåŸáÿß€å ŸÖÿ≥ÿ™ŸÇŸÑ:</b>"]

                for role, count in g.scenario.roles.items():
                    for _ in range(count):
                        if role in mafia_roles:
                            mafia_lines.append(f"‚ô†Ô∏è {role}")
                        elif role in indep_for_this:
                            indep_lines.append(f"‚ô¶Ô∏è {role}")
                        else:
                            citizen_lines.append(f"‚ô•Ô∏è {role}")

                role_lines = ["üìú <b>ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß€å ÿ≥ŸÜÿßÿ±€åŸà:</b>\n"]
                role_lines.extend(mafia_lines)
                role_lines.append("")
                role_lines.extend(citizen_lines)
                if len(indep_lines) > 1:  # €åÿπŸÜ€å ÿ≠ÿØÿßŸÇŸÑ €å⁄© ŸÜŸÇÿ¥ ŸÖÿ≥ÿ™ŸÇŸÑ Ÿáÿ≥ÿ™
                    role_lines.append("")
                    role_lines.extend(indep_lines)

                role_text = "\n".join(role_lines)

                try:
                    if getattr(g, "last_roles_msg_id", None):
                        try:
                            await _retry(ctx.bot.edit_message_text(
                                chat_id=chat_id,
                                message_id=g.last_roles_msg_id,
                                text=role_text,
                                parse_mode="HTML",
                            ))
                        except BadRequest as e:
                            if "message is not modified" in str(e):
                                pass
                            else:
                                raise
                    else:
                        role_msg = await _retry(
                            ctx.bot.send_message(chat_id, role_text, parse_mode="HTML")
                        )
                        g.last_roles_msg_id = role_msg.message_id
                except Exception:
                    role_msg = await _retry(
                        ctx.bot.send_message(chat_id, role_text, parse_mode="HTML")
                    )
                    g.last_roles_msg_id = role_msg.message_id

                g.last_roles_scenario_name = g.scenario.name


        save_debounced()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#  ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å (ŸáŸÖÿßŸÜ ŸÜÿ≥ÿÆŸáŸî ŸÇÿ®ŸÑ€åÿõ ŸÅŸÇÿ∑ ÿØÿ≥ÿ™ ŸÜÿ≤ÿØ€åŸÖ)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def start_vote(ctx, chat_id: int, g: GameState, stage: str):
    g.vote_stage = stage
    g.tally = {}
    g.current_target = None
    g.collecting = False

    candidates = g.defense_seats if stage == "final" else list(g.seats.keys())
    g.vote_candidates = [s for s in candidates if s not in g.striked]
    if stage != "final":
        g.vote_candidates = sorted(g.vote_candidates)

    btns = []
    for s in g.vote_candidates:
        name = g.seats[s][1]
        label = f"‚úÖ {s}. {name}" if s in getattr(g, "voted_targets", set()) else f"{s}. {name}"
        btns.append([InlineKeyboardButton(label, callback_data=f"vote_{s}")])

    if stage == "initial_vote":
        btns.append([InlineKeyboardButton("üßπ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="clear_vote_initial")])
        btns.append([InlineKeyboardButton("‚úÖ Ÿæÿß€åÿßŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="vote_done_initial")])
    else:  # final
        btns.append([InlineKeyboardButton("üßπ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="clear_vote_final")])
        btns.append([InlineKeyboardButton("‚úÖ Ÿæÿß€åÿßŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="vote_done_final")])

    back_code = "back_vote_init" if stage == "initial_vote" else "back_vote_final"
    btns.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_code)])

    title = "üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá ‚Äì ÿßŸÜÿ™ÿÆÿßÿ® ŸáÿØŸÅ:" if stage == "initial_vote" else "üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å ‚Äì ÿßŸÜÿ™ÿÆÿßÿ® ÿ≠ÿ∞ŸÅ:"
    msg = await ctx.bot.send_message(chat_id, title, reply_markup=InlineKeyboardMarkup(btns))

    g.vote_msg_id = msg.message_id

    if stage == "initial_vote":
        g.first_vote_msg_id_initial = msg.message_id
        g.last_vote_msg_id_initial = msg.message_id
    elif stage == "final":
        g.first_vote_msg_id_final = msg.message_id
        g.last_vote_msg_id_final = msg.message_id

    store.save()


async def update_vote_buttons(ctx, chat_id: int, g: GameState):
    btns = []
    for s in g.vote_candidates:
        name = g.seats[s][1]
        label = f"‚úÖ {s}. {name}" if s in getattr(g, "voted_targets", set()) else f"{s}. {name}"
        btns.append([InlineKeyboardButton(label, callback_data=f"vote_{s}")])

    if g.vote_stage == "initial_vote":
        btns.append([InlineKeyboardButton("üßπ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="clear_vote_initial")])
        btns.append([InlineKeyboardButton("‚úÖ Ÿæÿß€åÿßŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="vote_done_initial")])
        btns.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_vote_init")])
    elif g.vote_stage == "final":
        btns.append([InlineKeyboardButton("üßπ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="clear_vote_final")])
        btns.append([InlineKeyboardButton("‚úÖ Ÿæÿß€åÿßŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="vote_done_final")])
        btns.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_vote_final")])

    try:
        await ctx.bot.edit_message_reply_markup(
            chat_id=chat_id,
            message_id=g.vote_msg_id,  # üìå ŸÅŸÇÿ∑ ÿ±Ÿà€å Ÿæ€åÿßŸÖ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿßÿµŸÑ€å
            reply_markup=InlineKeyboardMarkup(btns)
        )
    except:
        pass


async def handle_vote(ctx, chat_id: int, g: GameState, target_seat: int):
    g.current_vote_target = target_seat

    start_time = datetime.now().timestamp()
    end_time = start_time + 4.3
    g.vote_window = (start_time, end_time, target_seat)

    g.vote_collecting = True
    g.votes_cast.setdefault(target_seat, set())
    g.vote_logs.setdefault(target_seat, [])

    if not hasattr(g, "vote_order"):
        g.vote_order = []
    g.vote_order.append(target_seat)

    if not hasattr(g, "vote_cleanup_ids"):
        g.vote_cleanup_ids = []

    store.save()

    msg = await ctx.bot.send_message(
        chat_id,
        f"‚è≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ®ÿ±ÿß€å <b>{target_seat}. {g.seats[target_seat][1]}</b>",
        parse_mode="HTML"
    )
    g.vote_cleanup_ids.append(msg.message_id)

    await asyncio.sleep(4)

    g.vote_collecting = False
    end_msg = await ctx.bot.send_message(chat_id, "üõë ÿ™ŸÖÿßŸÖ", parse_mode="HTML")

    if g.vote_stage == "initial_vote":
        g.last_vote_msg_id_initial = end_msg.message_id
    elif g.vote_stage == "final":
        g.last_vote_msg_id_final = end_msg.message_id

    g.voted_targets.add(target_seat)
    await update_vote_buttons(ctx, chat_id, g)
    store.save()



import jdatetime







async def announce_winner(ctx, update, g: GameState):
    chat = update.effective_chat
    group_title = chat.title or "‚Äî"
    date_str = jdatetime.date.today().strftime("%Y/%m/%d")
    scenario_name = getattr(g.scenario, "name", "‚Äî")

    # ‚Üê ŸÅŸÇÿ∑ ÿßÿ≤ ⁄©ÿ¥
    nums = get_event_numbers()
    key = str(chat.id)
    event_num = int(nums.get(key, 1))  # ŸÜŸÖÿß€åÿ¥ ÿπÿØÿØ ŸÅÿπŸÑ€å

    # ŸÑ€åŸÜ⁄©‚ÄåÿØÿßÿ± ⁄©ÿ±ÿØŸÜ ⁄Øÿ±ŸàŸá
    if chat.username:
        group_link = f"<a href='https://t.me/{chat.username}'>{group_title}</a>"
    else:
        group_link = group_title

    lines = [
        f"‚ñë‚öúÔ∏èüéÆ ⁄Øÿ±ŸàŸá: {group_link}",
        f"‚ñë‚öúÔ∏èüìÖ ÿ™ÿßÿ±€åÿÆ: {date_str}",
        f"‚ñë‚öúÔ∏èüéØ ÿ¥ŸÖÿßÿ±Ÿá ÿ±Ÿà€åÿØÿßÿØ:{event_num}",
        f"‚ñëüí°üî± ÿ±ÿßŸà€å: <a href='tg://user?id={g.god_id}'>{g.god_name or '‚ùì'}</a>",
        f"‚ñë‚öúÔ∏èüìÉ ÿ≥ŸÜÿßÿ±€åŸà: {scenario_name}",
        "",
        "‚ñë‚öúÔ∏èüí´ ŸÑ€åÿ≥ÿ™ ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ‚¨áÔ∏è",
        "",
    ]

    mafia_roles = load_mafia_roles()
    indep_roles = load_indep_roles()
    indep_for_this = indep_roles.get(g.scenario.name, [])

    for seat in sorted(g.seats):
        uid, name = g.seats[seat]
        role = g.assigned_roles.get(seat, "‚Äî")

        # ÿßŸÜÿ™ÿÆÿßÿ® ŸÖÿßÿ±⁄©ÿ± ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜŸÇÿ¥
        if getattr(g, "purchased_seat", None) == seat:
            role_display = f"{role} / ŸÖÿßŸÅ€åÿß"
            marker = "‚óæÔ∏è"  # ÿÆÿ±€åÿØÿßÿ±€å ÿ¥ÿØŸá ‚Üí ŸÖÿßŸÅ€åÿß
        elif role in mafia_roles:
            marker = "‚óæÔ∏è"  # ŸÖÿßŸÅ€åÿß
            role_display = role
        elif role in indep_for_this:
            marker = "‚ô¶Ô∏è"  # ŸÖÿ≥ÿ™ŸÇŸÑ
            role_display = role
                
        else:
            marker = "‚óΩÔ∏è"  # ÿ¥Ÿáÿ±ŸàŸÜÿØ
            role_display = role

        chaos_mark = " üî∏" if getattr(g, "chaos_selected", set()) and seat in g.chaos_selected else ""

        lines.append(
            f"‚ñë‚öúÔ∏è{marker}{seat}- <a href='tg://user?id={uid}'>{name}</a> ‚á¶ {role_display}{chaos_mark}"
        )

    lines.append("")
    result_line = f"üèÜ ŸÜÿ™€åÿ¨Ÿá ÿ®ÿßÿ≤€å: ÿ®ÿ±ÿØ {g.winner_side}"
    if getattr(g, "clean_win", False):
        result_line += " (⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™)"
    if getattr(g, "chaos_mode", False):
        result_line += " (⁄©€å‚Äåÿ¢ÿ≥)"
    lines.append(result_line)

    # ‚úÖ ÿßŸÅÿ≤ÿß€åÿ¥ ÿ¥ŸÖÿßÿ±Ÿá ÿß€åŸàŸÜÿ™ (⁄©ÿ¥ + Gist)
    nums[key] = event_num + 1
    ok = save_event_numbers(nums)
    if not ok:
        print(f"‚ö†Ô∏è save_event_numbers failed for chat {key}")

    g.phase = "ended"
    store.save()

    msg = await ctx.bot.send_message(chat.id, "\n".join(lines), parse_mode="HTML")
    try:
        await ctx.bot.pin_chat_message(chat_id=chat.id, message_id=msg.message_id)
    except Exception as e:
        print("‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± Ÿæ€åŸÜ ⁄©ÿ±ÿØŸÜ Ÿæ€åÿßŸÖ:", e)




def _apply_size_and_scenario(g: GameState, new_size: int, new_scenario: Scenario):
    # ÿß⁄Øÿ± ⁄©ŸÖ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ: ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿ®ÿßŸÑÿß€å ÿ∏ÿ±ŸÅ€åÿ™ ÿ¨ÿØ€åÿØ ÿ≠ÿ∞ŸÅ ÿ¥ŸàŸÜÿØ
    if new_size < g.max_seats:
        for seat in sorted(list(g.seats.keys())):
            if seat > new_size:
                g.seats.pop(seat, None)
        # ÿÆÿ∑‚ÄåÿÆŸàÿ±ÿØŸá‚ÄåŸáÿß Ÿà ÿØŸÅÿßÿπ Ÿà‚Ä¶ ŸáŸÖ ÿ™ŸÖ€åÿ≤ ÿ¥ŸàŸÜÿØ
        g.striked = {s for s in g.striked if s <= new_size}
        g.defense_seats = [s for s in g.defense_seats if s <= new_size]
    # ÿß⁄Øÿ± ÿ≤€åÿßÿØ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ: ŸÅŸÇÿ∑ ÿ∏ÿ±ŸÅ€åÿ™ ÿ®ÿßŸÑÿß ÿ®ÿ±ŸàÿØÿõ ŸÜŸÅÿ±ÿßÿ™ ŸÇÿ®ŸÑ€å ÿ≥ÿ± ÿ¨ÿß€åÿ¥ÿßŸÜ
    g.max_seats = new_size
    g.scenario = new_scenario
    g.last_roles_scenario_name = None  # ÿ™ÿß ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿØŸàÿ®ÿßÿ±Ÿá ⁄ÜÿßŸæ ÿ¥ŸàÿØ
    # Ÿáÿ±⁄Ü€åÿ≤€å ⁄©Ÿá ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ŸÜŸÇÿ¥‚ÄåŸáÿß€å ŸÇÿ®ŸÑ€å ÿ®ŸàÿØŸá Ÿæÿß⁄©ÿõ ⁄ÜŸàŸÜ ŸáŸÜŸàÿ≤ ÿ®ÿßÿ≤€å ÿ¥ÿ±Ÿàÿπ ŸÜÿ¥ÿØŸá
    g.assigned_roles = {}
    g.phase = "idle"
    g.awaiting_scenario = False
    # ŸÅŸÑ⁄Ø‚ÄåŸáÿß€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà
    g.awaiting_scenario_change = False
    g.pending_size = None

def _scenario_sizes_available() -> list[int]:
    sizes = sorted({sum(s.roles.values()) for s in store.scenarios})
    return sizes

def kb_choose_sizes() -> InlineKeyboardMarkup:
    sizes = _scenario_sizes_available()
    rows, row = [], []
    for i, n in enumerate(sizes, 1):
        row.append(InlineKeyboardButton(str(n), callback_data=f"scsize_{n}"))
        if i % 4 == 0:
            rows.append(row); row = []
    if row:
        rows.append(row)
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="scchange_back")])
    return InlineKeyboardMarkup(rows)

def kb_choose_scenarios_for(size: int) -> InlineKeyboardMarkup:
    options = [s for s in store.scenarios if sum(s.roles.values()) == size]
    # Ÿáÿ± ÿ≥ŸÜÿßÿ±€åŸà €å⁄© ÿØ⁄©ŸÖŸá
    rows = [[InlineKeyboardButton(s.name, callback_data=f"scpick_{size}_{i}")]
            for i, s in enumerate(options)]
    rows.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÜÿ™ÿÆÿßÿ® ÿ∏ÿ±ŸÅ€åÿ™ ÿØ€å⁄Øÿ±", callback_data="scchange_again")])
    return InlineKeyboardMarkup(rows)



async def cleanup_after(ctx, chat_id: int, from_message_id: int, stop_message_id: int | None = None):

    try:
        
        if stop_message_id:
            limit = stop_message_id
        else:
            
            limit = from_message_id + 5000

        batch = []
        for msg_id in range(from_message_id + 1, limit):
            batch.append(msg_id)
            if len(batch) == 100:  # Ÿáÿ± 100 ÿ™ÿß
                for mid in batch:
                    try:
                        await ctx.bot.delete_message(chat_id, mid)
                    except Exception:
                        pass
                batch = []
                await asyncio.sleep(1)  # ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ FloodLimit

        # ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá
        for mid in batch:
            try:
                await ctx.bot.delete_message(chat_id, mid)
            except Exception:
                pass

    except Exception as e:
        print(f"‚ö†Ô∏è cleanup_after error: {e}")




# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#  CALL-BACK ROUTER ‚Äì ŸÜÿ≥ÿÆŸáŸî ⁄©ÿßŸÖŸÑ ÿ®ÿß ŸÅÿßÿµŸÑŸá‚Äå⁄Øÿ∞ÿßÿ±€å ÿØÿ±ÿ≥ÿ™
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def callback_router(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.type == "private":
        return
    q = update.callback_query
    await safe_q_answer(q)
    data = q.data
    chat = q.message.chat.id
    uid = q.from_user.id
    g = gs(chat)


    # ‚îÄ‚îÄ‚îÄ ÿ≠ÿ∞ŸÅ ÿ®ÿßÿ≤€å⁄©ŸÜ ÿ™Ÿàÿ≥ÿ∑ ⁄ØÿßÿØ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == BTN_DELETE:
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ≠ÿ∞ŸÅ ⁄©ŸÜÿØ!")
            return
        g.pending_delete = set()
        store.save()
        await set_hint_and_kb(
            ctx, chat, g,
            "ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØÿßÿ±ÿß€å ÿ®ÿßÿ≤€å⁄©ŸÜ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿØÿ± Ÿæÿß€åÿßŸÜ ¬´ÿ™ÿ£€å€åÿØ ÿ≠ÿ∞ŸÅ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            delete_button_markup(g),
            mode="delete"
        )
        return
    if data.startswith("delete_toggle_") and uid == g.god_id:
        try:
            seat = int(data.split("_")[2])
        except:
            return
        # ŸÅŸÇÿ∑ ÿß⁄Øÿ± ÿµŸÜÿØŸÑ€å ŸæŸèÿ± ÿßÿ≥ÿ™ ÿßÿ¨ÿßÿ≤ŸáŸî ÿßŸÜÿ™ÿÆÿßÿ® ÿ®ÿØŸá
        if seat in g.seats:
            if seat in g.pending_delete:
                g.pending_delete.remove(seat)
            else:
                g.pending_delete.add(seat)
            store.save()
        await publish_seating(ctx, chat, g, mode="delete")
        return

    if data == "delete_confirm" and uid == g.god_id:
        # ÿ≠ÿ∞ŸÅ ŸáŸÖŸáŸî ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿßŸÜÿ™ÿÆÿßÿ®‚Äåÿ¥ÿØŸá
        for seat in sorted(list(g.pending_delete)):
            g.seats.pop(seat, None)
        g.pending_delete = set()
        g.ui_hint = None 
        store.save()
        await publish_seating(ctx, chat, g, mode=REG)
        return

    if data == "delete_cancel" and uid == g.god_id:
        g.pending_delete = set()
        store.save()
        await publish_seating(ctx, chat, g, mode=REG)
        return


    # ‚îÄ‚îÄ‚îÄ ŸÑÿ∫Ÿà ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ™Ÿàÿ≥ÿ∑ ÿÆŸàÿØŸê ÿ®ÿßÿ≤€å⁄©ŸÜ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "cancel_self":
        for seat, (player_uid, _) in g.seats.items():
            if player_uid == uid:
                del g.seats[seat]
                store.save()
                await ctx.bot.send_message(chat, "‚ùé ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÑÿ∫Ÿà ÿ¥ÿØ.")
                await publish_seating(ctx, chat, g)
                break
        else:
            await ctx.bot.send_message(chat,"‚ùó ÿ¥ŸÖÿß ÿØÿ± ŸÑ€åÿ≥ÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.")
        return

    if data == "change_name":
        if uid not in [u for u, _ in g.seats.values()]:
            await ctx.bot.send_message(chat, "‚ùó ÿ¥ŸÖÿß ŸáŸÜŸàÿ≤ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ŸÜ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.")
            return

        seat_no = [s for s in g.seats if g.seats[s][0] == uid][0]
        g.waiting_name[uid] = seat_no
        store.save()

        await ctx.bot.send_message(
            chat,
            f"‚úèÔ∏è ÿß€åŸÜ Ÿæ€åÿßŸÖ ÿ±ÿß ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ Ÿà ŸÜÿßŸÖ ÿ¨ÿØ€åÿØ ÿÆŸàÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å {seat_no} ÿ®Ÿá ŸÅÿßÿ±ÿ≥€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:"
        )
        return


    if data == "settings_menu" and uid == g.god_id:
        await ctx.bot.edit_message_reply_markup(
            chat_id=chat,
            message_id=g.last_seating_msg_id,
            reply_markup=settings_keyboard()
        )
        return

    if data == "back_to_main" and uid == g.god_id:
        await ctx.bot.edit_message_reply_markup(
            chat_id=chat,
            message_id=g.last_seating_msg_id,
            reply_markup=text_seating_keyboard(g)
        )
        return

    # ‚îÄ‚îÄ‚îÄ ÿµÿØÿß ÿ≤ÿØŸÜ ŸáŸÖŸá ŸÇÿ®ŸÑŸê ÿ¥ÿ±Ÿàÿπ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == BTN_CALL:
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿß€åŸÜ ÿØ⁄©ŸÖŸá ÿ±ÿß ÿ®ÿ≤ŸÜÿØ!")
            return

        mentions = [
            f"<a href='tg://user?id={u_id}'>{name}</a>"
            for _, (u_id, name) in sorted(g.seats.items())
        ]
        text = (
            "üéô ÿ≥ŸÑÿßÿ∑€åŸÜ ÿ™ÿ¥ÿ±€åŸÅ ÿ®€åÿßÿ±€åÿØÿå "
            "ÿ®ŸÇ€åŸá ÿ±Ÿà ÿπŸÑÿßŸÅ ŸÜ⁄©ŸÜ€åÿØ!\n" + " | ".join(mentions)
        )
        await ctx.bot.send_message(chat, text, parse_mode="HTML")
        return

    # ‚îÄ‚îÄ‚îÄ ÿ™ÿ∫€å€åÿ± ÿ≥ÿßÿπÿ™ ÿ¥ÿ±Ÿàÿπ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "change_time":
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ≤ŸÖÿßŸÜ ÿ±ÿß ÿπŸàÿ∂ ⁄©ŸÜÿØ!")
            return
        g.vote_type = "awaiting_time"
        store.save()
        await ctx.bot.send_message(
            chat,
            "üïí ÿ≥ÿßÿπÿ™ ÿ¥ÿ±Ÿàÿπ ÿ±ÿß ÿ®ŸÜŸà€åÿ≥ (ŸÖÿ´ÿßŸÑ: 22:30):",
            reply_markup=ForceReply(selective=True)
        )
        return


    # ‚îÄ‚îÄ‚îÄ ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å (ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "startgame":
        if g.god_id is None:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ÿ±ÿßŸà€å ÿ´ÿ®ÿ™ ŸÜÿßŸÖ ⁄©ŸÜÿØ!")
            return

        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ®ÿßÿ≤€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        if not getattr(g, "preview_uid_to_role", None):
            await ctx.bot.send_message(
                chat,
                "üé≤ ŸÇÿ®ŸÑ ÿßÿ≤ ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€åÿå ⁄ÜŸÜÿØ ÿ®ÿßÿ± ÿ±Ÿà€å ¬´ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥¬ª ÿ®ÿ≤ŸÜ€åÿØ ÿ™ÿß ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ¥ÿßŸÅŸÑ ÿ¥ŸàŸÜÿØ."
            )
            return

        if len(g.seats) != g.max_seats:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸáŸÜŸàÿ≤ ŸáŸÖŸáŸî ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ŸæŸèÿ± ŸÜÿ¥ÿØŸá!")
            return

     
        now = datetime.now(timezone.utc).timestamp()
        store.group_stats.setdefault(chat, {
            "waiting_list": [],
            "started": [],
            "ended": []
        })
        store.group_stats[chat]["started"].append(now)
        store.save()
        if g.scenario:
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("‚úÖ ÿ®ŸÑŸá", callback_data="shuffle_yes"),
                    InlineKeyboardButton("‚ùå ÿÆ€åÿ±", callback_data="shuffle_no"),
                ]
            ])
            msg = await ctx.bot.send_message(
                chat,
                "‚ùì ÿ¢€åÿß ŸÖÿß€åŸÑ Ÿáÿ≥ÿ™€åÿØ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿ±ŸÜÿØŸàŸÖ ÿ®ÿ¥ŸÜÿü",
                reply_markup=keyboard
            )
            g.shuffle_prompt_msg_id = msg.message_id
            g.awaiting_shuffle_decision = True
            store.save()
            return

 
        g.awaiting_scenario = True
        g.from_startgame = False
        store.save()
        await show_scenario_selection(ctx, chat, g)
        return

    if data == "shuffle_yes":
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ®ÿßÿ≤€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        if not g.awaiting_shuffle_decision:
            return

        g.awaiting_shuffle_decision = False
        g.from_startgame = False
        store.save()

        prompt_id = g.shuffle_prompt_msg_id 
        if prompt_id:
            try:
                await ctx.bot.delete_message(chat, prompt_id)
            except:
                pass
            g.shuffle_prompt_msg_id = None

        repeats = getattr(g, "shuffle_repeats", None) or 1

        # ÿßŸàŸÑ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿØÿßÿØŸá ÿ¥ŸàÿØ
        await shuffle_and_assign(
            ctx,
            chat,
            g,
            shuffle_seats=True,
            uid_to_role=g.preview_uid_to_role or None,
            notify_players=True,
            preview_mode=False,
            role_shuffle_repeats=repeats,
        )


        g.preview_uid_to_role = None
        g.shuffle_repeats = None
        store.save()
        return


    if data == "shuffle_no":
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ®ÿßÿ≤€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        if not g.awaiting_shuffle_decision:
            return

        g.awaiting_shuffle_decision = False
        g.from_startgame = False
        store.save()

        prompt_id = g.shuffle_prompt_msg_id  
        if prompt_id:
            try:
                await ctx.bot.delete_message(chat, prompt_id)
            except:
                pass
            g.shuffle_prompt_msg_id = None

        repeats = getattr(g, "shuffle_repeats", None) or 1

        # ÿßŸàŸÑ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿØÿßÿØŸá ÿ¥ŸàÿØ
        await shuffle_and_assign(
            ctx,
            chat,
            g,
            shuffle_seats=False,
            uid_to_role=g.preview_uid_to_role or None,
            notify_players=True,
            preview_mode=False,
            role_shuffle_repeats=repeats,
        )

        g.preview_uid_to_role = None
        g.shuffle_repeats = None
        store.save()
        return

    # Ÿàÿ±ŸàÿØ ÿ®Ÿá ÿ≠ÿßŸÑÿ™ ÿßÿÆÿ∑ÿßÿ±
    if data == "warn_mode":
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿßÿÆÿ∑ÿßÿ± ÿ®ÿØŸáÿØ!")
            return
        if not isinstance(g.warnings, dict):
            g.warnings = {}
        g.warning_mode = True
        g.pending_warnings = dict(g.warnings)  # Ÿà€åÿ±ÿß€åÿ¥ ÿ±Ÿà€å ⁄©Ÿæ€å
        store.save()
        await publish_seating(ctx, chat, g, mode="warn")
        return

    # ÿßŸÅÿ≤ÿß€åÿ¥ ÿßÿÆÿ∑ÿßÿ±
    if data.startswith("warn_inc_") and g.warning_mode and uid == g.god_id:
        try:
            seat = int(data.split("_")[2])
        except Exception:
            return
        if seat in g.seats and seat not in g.striked:
            if not isinstance(g.pending_warnings, dict):
                g.pending_warnings = {}
            cur = g.pending_warnings.get(seat, g.warnings.get(seat, 0))
            try:
                cur = int(cur)
            except Exception:
                cur = 0
            
            nxt = cur + 1
            g.pending_warnings[seat] = nxt
            store.save()
            await publish_seating(ctx, chat, g, mode="warn")
        return

    # ⁄©ÿßŸáÿ¥ ÿßÿÆÿ∑ÿßÿ±
    if data.startswith("warn_dec_") and g.warning_mode and uid == g.god_id:
        try:
            seat = int(data.split("_")[2])
        except Exception:
            return
        if seat in g.seats and seat not in g.striked:
            if not isinstance(g.pending_warnings, dict):
                g.pending_warnings = {}
            cur = g.pending_warnings.get(seat, g.warnings.get(seat, 0))
            try:
                cur = int(cur)
            except Exception:
                cur = 0
            
            nxt = max(cur - 1, 0) 
            
            g.pending_warnings[seat] = nxt
            store.save()
            await publish_seating(ctx, chat, g, mode="warn")
        return

    # ÿ™ÿ£€å€åÿØ ÿßÿÆÿ∑ÿßÿ±Ÿáÿß
    if data == "warn_confirm" and g.warning_mode and uid == g.god_id:
        if not isinstance(g.pending_warnings, dict):
            g.pending_warnings = {}
        # ŸÅŸÇÿ∑ ŸÖŸÇÿßÿØ€åÿ± >0 ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ŸàŸÜÿØ
        g.warnings = {
            int(k): int(v)
            for k, v in g.pending_warnings.items()
            if isinstance(v, int) and v > 0
        }
        g.warning_mode = False
        g.pending_warnings = {}
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return

    # ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®ÿØŸàŸÜ ÿßÿπŸÖÿßŸÑ
    if data == "warn_back" and g.warning_mode and uid == g.god_id:
        g.warning_mode = False
        g.pending_warnings = {}
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return

    # ŸÜÿßÿØ€åÿØŸá ⁄Øÿ±ŸÅÿ™ŸÜ ÿ®ÿ±⁄Üÿ≥ÿ®
    if data == "noop":
        return

    # ÿ¥ÿ±Ÿàÿπ ¬´ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà/ÿ∏ÿ±ŸÅ€åÿ™¬ª
    if data == "change_scenario":
        if g.god_id is None or uid != g.god_id:
            await safe_q_answer(q, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ≥ŸÜÿßÿ±€åŸà ÿ±ÿß ÿ™ÿ∫€å€åÿ± ÿØŸáÿØ!", show_alert=True)
            return
        g.awaiting_scenario_change = True
        g.pending_size = None
        store.save()
        await set_hint_and_kb(ctx, chat, g, "ÿßÿ®ÿ™ÿØÿß ÿ∏ÿ±ŸÅ€åÿ™ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", kb_choose_sizes(), mode=REG if g.phase=="idle" else CTRL)
        return

    # ÿ®ÿ±⁄Øÿ¥ÿ™ ÿßÿ≤ ÿßŸÜÿ™ÿÆÿßÿ® ÿ∏ÿ±ŸÅ€åÿ™/ÿ≥ŸÜÿßÿ±€åŸà
    if data == "scchange_back":
        g.awaiting_scenario_change = False
        g.pending_size = None
        g.ui_hint = None
        store.save()
        await publish_seating(ctx, chat, g, mode=REG if g.phase=="idle" else CTRL)
        return

    # ÿ™ÿ∫€å€åÿ± ÿ∏ÿ±ŸÅ€åÿ™ ‚Üí ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ÿ≥ŸÜÿßÿ±€åŸàŸáÿß€å ŸáŸÖÿßŸÜ ÿ∏ÿ±ŸÅ€åÿ™
    if data.startswith("scsize_") and getattr(g, "awaiting_scenario_change", False):
        try:
            size = int(data.split("_")[1])
        except:
            return
        g.pending_size = size
        store.save()
        await set_hint_and_kb(ctx, chat, g,
                              f"ÿ≥ŸÜÿßÿ±€åŸà€å {size}ŸÜŸÅÿ±Ÿá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
                              kb_choose_scenarios_for(size),
                              mode=REG if g.phase=="idle" else CTRL)
        return

    # ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà ŸÜŸáÿß€å€å Ÿà ÿßÿπŸÖÿßŸÑ ÿ™ÿ∫€å€åÿ±
    if data.startswith("scpick_") and getattr(g, "awaiting_scenario_change", False):
        parts = data.split("_")
        if len(parts) != 3:
            return
        try:
            size = int(parts[1])
            idx = int(parts[2])
        except:
            return

        options = [s for s in store.scenarios if sum(s.roles.values()) == size]
        if not (0 <= idx < len(options)):
            await safe_q_answer(q, "ÿ≥ŸÜÿßÿ±€åŸà€å ŸÜÿßŸÖÿπÿ™ÿ®ÿ±.", show_alert=True)
            return

        chosen = options[idx]

        # ‚õî ÿß⁄Øÿ± ÿ™ÿ∫€å€åÿ±€å ŸÜ€åÿ≥ÿ™ÿå ⁄©ÿßÿ±€å ŸÜ⁄©ŸÜ
        if g.scenario and g.scenario.name == chosen.name and g.max_seats == size:
            await safe_q_answer(q, "ÿ≥ŸÜÿßÿ±€åŸà ÿ™ÿ∫€å€åÿ±€å ŸÜ⁄©ÿ±ÿØ.", show_alert=False)
            return

        _apply_size_and_scenario(g, size, chosen)
        # ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ŸÖŸàÿØ ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà Ÿà Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ hint
        g.awaiting_scenario_change = False
        g.pending_size = None
        g.ui_hint = None
        store.save()

        # ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ÿ®ÿß ÿ∏ÿ±ŸÅ€åÿ™/ÿ≥ŸÜÿßÿ±€åŸà€å ÿ¨ÿØ€åÿØ
        await set_hint_and_kb(
            ctx, chat, g,
            None,
            text_seating_keyboard(g),
            mode=REG if g.phase == "idle" else CTRL
        )
        return

    # ÿß⁄Øÿ± Ÿàÿ≥ÿ∑ ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà ÿ®ŸàÿØ Ÿà ⁄ØŸÅÿ™ ¬´ÿ∏ÿ±ŸÅ€åÿ™ ÿØ€å⁄Øÿ±¬ª
    if data == "scchange_again" and getattr(g, "awaiting_scenario_change", False):
        g.pending_size = None
        store.save()
        await set_hint_and_kb(ctx, chat, g, "ÿ∏ÿ±ŸÅ€åÿ™ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", kb_choose_sizes(), mode=REG if g.phase=="idle" else CTRL)
        return

 



    # ‚îÄ‚îÄ‚îÄ Ÿæÿß€åÿßŸÜ ÿ®ÿßÿ≤€å Ÿà ÿßŸÜÿ™ÿÆÿßÿ® ÿ®ÿ±ŸÜÿØŸá ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "end_game" and uid == g.god_id:
        now = datetime.now(timezone.utc).timestamp()
        store.group_stats.setdefault(chat, {"waiting_list": [], "started": [], "ended": []})
        store.group_stats[chat]["ended"].append(now)

        g.phase = "awaiting_winner"
        g.awaiting_winner = True
        g.temp_winner = None
        g.chaos_mode = False
        g.chaos_selected = set()
        store.save()

        await set_hint_and_kb(ctx, chat, g, "ÿ®ÿ±ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.", kb_endgame_root(g))
        return


    if data == "back_endgame" and uid == g.god_id:
        g.awaiting_winner = False
        g.phase = "playing"
        g.temp_winner = None
        g.chaos_mode = False
        g.chaos_selected = set()
        g.ui_hint = None  # üëà ÿ®ÿ±ÿß€å ÿß€åŸÜ⁄©Ÿá ŸÖÿ™ŸÜ ÿ±ÿßŸáŸÜŸÖÿß ÿ±Ÿà€å ŸÑ€åÿ≥ÿ™ ÿßÿµŸÑ€å ÿ®ÿßŸÇ€å ŸÜŸÖŸàŸÜŸá
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return


    if data in {
        "winner_city", "winner_mafia", "clean_city", "clean_mafia",
        "winner_city_chaos", "winner_mafia_chaos", "winner_indep"   # üîπ ŸÖÿ≥ÿ™ŸÇŸÑ ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ
    } and g.awaiting_winner:
        g.temp_winner = data
        g.chaos_mode = data.endswith("_chaos")
        store.save()

        if data == "winner_indep":
            # ŸÖÿ≥ÿ™ŸÇŸÑ ‚Üí ŸÖÿ≥ÿ™ŸÇ€åŸÖ ÿ™ÿ£€å€åÿØ (ÿ®ÿØŸàŸÜ ÿÆÿ±€åÿØÿßÿ±€å €åÿß ⁄©€å‚Äåÿ¢ÿ≥)
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
                [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
            ])
            await set_hint_and_kb(
                ctx, chat, g,
                "üîí ŸÜŸÇÿ¥ ŸÖÿ≥ÿ™ŸÇŸÑ ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØ. ÿ®ÿ±ÿß€å ŸÜŸáÿß€å€å‚Äåÿ≥ÿßÿ≤€å ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
                kb
            )
            return

        # ⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™ ‚Üí ŸÖÿ≥ÿ™ŸÇ€åŸÖÿßŸã ÿ™ÿ£€å€åÿØ ŸÜŸáÿß€å€å
        if data in {"clean_city", "clean_mafia"}:
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
                [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
            ])
            await set_hint_and_kb(ctx, chat, g, "ŸÜÿ™€åÿ¨Ÿá ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ Ÿà ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.", kb)
            return

        # ÿ¥Ÿáÿ±/ŸÖÿßŸÅ€åÿß (ŸÖÿπŸÖŸàŸÑ€å €åÿß ⁄©€å‚Äåÿ¢ÿ≥) ‚Üí ÿßŸàŸÑ ÿ®Ÿæÿ±ÿ≥ ¬´ÿÆÿ±€åÿØÿßÿ±€åÿü¬ª
        await set_hint_and_kb(ctx, chat, g, "ÿ¢€åÿß ÿ®ÿßÿ≤€å⁄©ŸÜ€å ÿÆÿ±€åÿØÿßÿ±€å ÿ¥ÿØŸá ÿßÿ≥ÿ™ÿü", kb_purchase_yesno())
        return





    if data == "purchased_yes" and g.awaiting_winner:
        g.awaiting_purchase_number = True
        alive = [s for s in sorted(g.seats) if s not in g.striked]
        kb = kb_pick_single_seat(alive_seats=alive,
                                 selected=g.purchased_seat,
                                 confirm_cb="purchased_confirm",
                                 back_cb="back_to_winner_select")
        await set_hint_and_kb(ctx, chat, g,"ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å ÿ®ÿßÿ≤€å⁄©ŸÜŸê ÿÆÿ±€åÿØÿßÿ±€å‚Äåÿ¥ÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.", kb)
        return

    if data == "purchased_no" and g.awaiting_winner:
        g.purchased_seat = None
        store.save()

        if not g.chaos_mode:
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
                [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
            ])
            await set_hint_and_kb(
                ctx, chat, g,
                "üîí ÿ®ÿ±ŸÜÿØŸá ŸÖÿ¥ÿÆÿµ ÿ¥ÿØ. ÿß⁄Øÿ± ŸÖÿ∑ŸÖÿ¶ŸÜ Ÿáÿ≥ÿ™€åÿØ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
                kb
            )
            return

        # ⁄©€å‚Äåÿ¢ÿ≥ ‚Üí ÿßŸÜÿ™ÿÆÿßÿ® €≥ ŸÜŸÅÿ± ÿ≤ŸÜÿØŸá
        alive = [s for s in sorted(g.seats) if s not in g.striked]
        g.chaos_selected = set()
        kb = kb_pick_multi_seats(
            alive, g.chaos_selected, 3,
            confirm_cb="chaos_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            "üåÄ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥: €≥ ŸÜŸÅÿ± ÿßÿ≤ ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ÿ≤ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data.startswith("pick_single_") and g.awaiting_winner:
        try:
            s = int(data.split("_")[2])
        except:
            return

        if s in g.seats and s not in g.striked:
            g.purchased_seat = s
            store.save()

        alive = [x for x in sorted(g.seats) if x not in g.striked]
        kb = kb_pick_single_seat(
            alive, g.purchased_seat,
            confirm_cb="purchased_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            "üõí ÿµŸÜÿØŸÑ€å ÿÆÿ±€åÿØÿßÿ±€å‚Äåÿ¥ÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data == "purchased_confirm" and g.awaiting_winner:
        if not g.chaos_mode:
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
                [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
            ])
            await set_hint_and_kb(
                ctx, chat, g,
                "üîí ÿ®ÿ±ŸÜÿØŸá Ÿà ÿµŸÜÿØŸÑ€å ÿÆÿ±€åÿØÿßÿ±€å‚Äåÿ¥ÿØŸá ÿ´ÿ®ÿ™ ÿ¥ÿØ. ÿ®ÿ±ÿß€å ŸÜŸáÿß€å€å‚Äåÿ≥ÿßÿ≤€å ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
                kb
            )
            return

        # ⁄©€å‚Äåÿ¢ÿ≥ ÿ®ÿπÿØ ÿßÿ≤ ÿÆÿ±€åÿØÿßÿ±€å
        alive = [s for s in sorted(g.seats) if s not in g.striked]
        g.chaos_selected = set()
        kb = kb_pick_multi_seats(
            alive, g.chaos_selected, 3,
            confirm_cb="chaos_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            "üåÄ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥: €≥ ŸÜŸÅÿ± ÿßÿ≤ ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ÿ≤ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data.startswith("toggle_multi_") and g.awaiting_winner and g.chaos_mode:
        try:
            s = int(data.split("_")[2])
        except:
            return

        alive = [x for x in sorted(g.seats) if x not in g.striked]
        if s in alive:
            if s in g.chaos_selected:
                g.chaos_selected.remove(s)
            else:
                if len(g.chaos_selected) >= 3:
                    await safe_q_answer(q, "ÿ≠ÿØÿß⁄©ÿ´ÿ± €≥ ŸÜŸÅÿ±!", show_alert=True)
                else:
                    g.chaos_selected.add(s)
            store.save()

        kb = kb_pick_multi_seats(
            alive, g.chaos_selected, 3,
            confirm_cb="chaos_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            f"üåÄ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥: {len(g.chaos_selected)}/3 ŸÜŸÅÿ± ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØŸá‚ÄåÿßŸÜÿØ. ÿßÿØÿßŸÖŸá ÿØŸá€åÿØ Ÿà ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data == "chaos_confirm" and g.awaiting_winner and g.chaos_mode:
        if len(g.chaos_selected) != 3:
            await safe_q_answer(q, "ÿ®ÿß€åÿØ ÿØŸÇ€åŸÇÿßŸã €≥ ŸÜŸÅÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€å.", show_alert=True)
            return

        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
            [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
        ])
        await set_hint_and_kb(
            ctx, chat, g,
            "üîí ÿßŸÜÿ™ÿÆÿßÿ®‚ÄåŸáÿß ÿ´ÿ®ÿ™ ÿ¥ÿØ. ÿ®ÿ±ÿß€å ŸÜŸáÿß€å€å‚Äåÿ≥ÿßÿ≤€å ŸÜÿ™€åÿ¨Ÿá ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data == "back_to_winner_select" and uid == g.god_id and g.awaiting_winner:
        await set_hint_and_kb(
            ctx, chat, g,
            "ÿ®ÿ±ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            kb_endgame_root(g)
        )
        return


    if data == "confirm_winner" and uid == g.god_id and getattr(g, "temp_winner", None):
        g.awaiting_winner = False

        if g.temp_winner == "winner_indep":
            g.winner_side = "ŸÖÿ≥ÿ™ŸÇŸÑ"
            g.clean_win = False
        else:
            g.winner_side = "ÿ¥Ÿáÿ±" if "city" in g.temp_winner else "ŸÖÿßŸÅ€åÿß"
            g.clean_win = "clean" in g.temp_winner

        # ÿØÿ± ÿµŸàÿ±ÿ™ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥ÿå g.chaos_selected ŸÇÿ®ŸÑÿßŸã ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØŸá
        g.temp_winner = None
        store.save()

        await announce_winner(ctx, update, g)
        await reset_game(update=update)
        return



    # ‚îÄ‚îÄ‚îÄ ÿß⁄Øÿ± ÿ®ÿßÿ≤€å Ÿæÿß€åÿßŸÜ €åÿßŸÅÿ™Ÿáÿå ÿØ€å⁄Øÿ± ÿßÿØÿßŸÖŸá ŸÜÿØŸá ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if g.phase == "ended":
        return
    if data == "vote_done_initial" and uid == g.god_id:
        await ctx.bot.send_message(chat, "‚úÖ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá ÿ™ŸÖÿßŸÖ ÿ¥ÿØ.")
        g.votes_cast = {}
        g.vote_logs = {}
        g.current_vote_target = None
        g.vote_has_ended_initial = True
        g.vote_order = []
        store.save()
        return

    if data == "vote_done_final" and uid == g.god_id:
        await ctx.bot.send_message(chat, "‚úÖ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å ÿ™ŸÖÿßŸÖ ÿ¥ÿØ.")
        g.votes_cast = {}
        g.vote_logs = {}
        g.current_vote_target = None
        g.vote_has_ended_final = True
        g.vote_order = []
        store.save()
        return


    if data == "clear_vote_initial" and uid == g.god_id:
        if not getattr(g, "vote_has_ended_initial", False):
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å Ÿæÿß€åÿßŸÜ €åÿßÿ®ÿØ.")
            return
        first_id = getattr(g, "first_vote_msg_id_initial", None)
        last_id  = getattr(g, "last_vote_msg_id_initial", None)
        if first_id and last_id:
            for mid in range(first_id, last_id + 1):
                try:
                    await ctx.bot.delete_message(chat_id=chat, message_id=mid)
                except:
                    pass
        await ctx.bot.send_message(chat, "üßπ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá Ÿæÿß⁄© ÿ¥ÿØ.")
        return
    if data == "clear_vote_final" and uid == g.god_id:
        if not getattr(g, "vote_has_ended_final", False):
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å Ÿæÿß€åÿßŸÜ €åÿßÿ®ÿØ.")
            return
        first_id = getattr(g, "first_vote_msg_id_final", None)
        last_id  = getattr(g, "last_vote_msg_id_final", None)
        if first_id and last_id:
            for mid in range(first_id, last_id + 1):
                try:
                    await ctx.bot.delete_message(chat_id=chat, message_id=mid)
                except:
                    pass
        await ctx.bot.send_message(chat, "üßπ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å Ÿæÿß⁄© ÿ¥ÿØ.")
        return
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    #  ⁄©ÿßÿ±ÿ™
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    if data == "shuffle_card":
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚õî ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ⁄©ÿßÿ±ÿ™ ÿ®⁄©ÿ¥ÿØ!")
            return

        cards = load_cards()
        scn = g.scenario.name if g.scenario else None
        if not scn or scn not in cards:
            await ctx.bot.send_message(chat, "‚ùå ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿ≥ŸÜÿßÿ±€åŸà ⁄©ÿßÿ±ÿ™€å ÿ™ÿπÿ±€åŸÅ ŸÜÿ¥ÿØŸá.")
            return

        deck = g.remaining_cards.get(scn, cards[scn].copy())

        if not deck:
            await ctx.bot.send_message(chat, "üÉè ŸáŸÖŸá ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß ŸÖÿµÿ±ŸÅ ÿ¥ÿØŸÜÿØ.")
            return

        choice = random.choice(deck)
        deck.remove(choice)
        g.remaining_cards[scn] = deck
        store.save()

        await ctx.bot.send_message(chat, f"üÉè ⁄©ÿßÿ±ÿ™ ÿßŸÜÿ™ÿÆÿßÿ®‚Äåÿ¥ÿØŸá:\n<b>{choice}</b>", parse_mode="HTML")
        return




    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    #  ÿ®ÿÆÿ¥‚ÄåŸáÿß€å ŸÇÿØ€åŸÖ€å (seat_ / cancel_ / strike_out / ‚Ä¶)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    if data == "strike_out" and uid == g.god_id:
        g.pending_strikes = set(g.striked)
        store.save()
        await publish_seating(ctx, chat, g, mode="strike")
        return

    if data == "strike_toggle_done" and uid == g.god_id:
        g.striked = set(g.pending_strikes)
        g.pending_strikes = set()
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return

    if data.startswith("strike_toggle_") and uid == g.god_id:
        seat = int(data.split("_")[2])
        if seat in g.pending_strikes:
            g.pending_strikes.remove(seat)
        else:
            g.pending_strikes.add(seat)
        store.save()
        await publish_seating(ctx, chat, g, mode="strike")
        return

    if data == BTN_REROLL:
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ±ÿß ÿ±ŸÜÿØŸàŸÖ ⁄©ŸÜÿØ!")
            return

        if not g.scenario or len(g.seats) != g.max_seats:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß ÿ≥ŸÜÿßÿ±€åŸà ÿßŸÜÿ™ÿÆÿßÿ® Ÿà ŸáŸÖŸá ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ŸæŸèÿ± ÿ¥ŸàŸÜÿØ.")
            return

        repeats = random.randint(1, 30)
        g.shuffle_repeats = repeats 

        try:
            await shuffle_and_assign(
                ctx,
                chat,
                g,
                shuffle_seats=False,
                uid_to_role=None,
                notify_players=False,
                preview_mode=True,
                role_shuffle_repeats=repeats,  
            )
            await ctx.bot.send_message(chat, f"üé≤ ŸÜŸÇÿ¥‚ÄåŸáÿß {repeats} ÿ®ÿßÿ± ÿ±ŸÜÿØŸàŸÖ ÿ¥ÿØ.")
           
        except Exception:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥.")

        store.save()
        return

    if data == "cleanup" and uid == g.god_id:
        if g.last_seating_msg_id:
            stop_id = g.shuffle_prompt_msg_id or None
            asyncio.create_task(
                cleanup_after(ctx, chat, g.last_seating_msg_id, stop_id)
            )
            await ctx.bot.send_message(chat, "üßπ ÿØÿ±ÿ≠ÿßŸÑ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å Ÿæ€åÿßŸÖ‚ÄåŸáÿß (ÿØÿ± Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá)...")
        else:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÑ€åÿ≥ÿ™ ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ŸÖÿ¥ÿÆÿµ ŸÜ€åÿ≥ÿ™ÿå Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ÿßŸÜÿ¨ÿßŸÖ ŸÜÿ¥ÿØ.")
        return


    if data == "add_scenario" and (uid == g.god_id or uid in g.admins):
        g.adding_scenario_step = "name"
        g.adding_scenario_data = {}
        g.adding_scenario_last = datetime.now()
        store.save()
        await ctx.bot.send_message(chat, "üìù ŸÜÿßŸÖ ÿ≥ŸÜÿßÿ±€åŸà€å ÿ¨ÿØ€åÿØ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ (€µ ÿØŸÇ€åŸÇŸá ŸÅÿ±ÿµÿ™ ÿØÿßÿ±€åÿØ).")
        return

    # ‚îÄ‚îÄ‚îÄ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å‚ÄåŸáÿß ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "init_vote":
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("üó≥ ŸæŸÑ", callback_data="init_vote_poll")],
            [InlineKeyboardButton("üó≥ ÿ™⁄© ÿ™⁄©", callback_data="init_vote_classic")],
            [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_controls")],
        ])
        await set_hint_and_kb(ctx, chat, g, "ÿ±Ÿàÿ¥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", kb)
        return

    if data == "init_vote_classic" and uid == g.god_id:
        g.votes_cast = {}
        g.vote_logs = {}
        g.current_vote_target = None
        g.voted_targets = set()
        store.save()

        await set_hint_and_kb(ctx, chat, g, None, control_keyboard(g), mode=CTRL)
        await start_vote(ctx, chat, g, "initial_vote")
        return

    if data == "init_vote_poll" and uid == g.god_id:
        await set_hint_and_kb(ctx, chat, g, None, control_keyboard(g), mode=CTRL)

        alive = [s for s in sorted(g.seats) if s not in g.striked]
        options = [f"{s}. {g.seats[s][1]}" for s in alive]
        max_per_poll = 9  # ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ®ÿßÿ≤€å⁄©ŸÜ ÿØÿ± Ÿáÿ± poll (€±€∞ŸÖ€åŸÜ ⁄Øÿ≤€åŸÜŸá ÿ®ÿ±ÿß€å "ÿØ€åÿØŸÜ ŸÜÿ™ÿß€åÿ¨")

        # ÿ™ŸÇÿ≥€åŸÖ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ®Ÿá ⁄ÜŸÜÿØ poll Ÿáÿ± 9 ŸÜŸÅÿ±
        chunks = [options[i:i + max_per_poll] for i in range(0, len(options), max_per_poll)]

        total_polls = len(chunks)
        if total_polls == 0:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è Ÿá€å⁄Ü ÿ®ÿßÿ≤€å⁄©ŸÜ€å ÿ®ÿ±ÿß€å ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
            return

        for idx, chunk in enumerate(chunks, start=1):
            # ÿßŸÅÿ≤ŸàÿØŸÜ ⁄Øÿ≤€åŸÜŸá‚Äå€å ŸÜÿ™ÿß€åÿ¨ ÿ®ÿ±ÿß€å Ÿáÿ± poll
            chunk.append(f"üìä ÿØ€åÿØŸÜ ŸÜÿ™ÿß€åÿ¨ ({idx}/{total_polls})")

            try:
                poll_msg = await ctx.bot.send_poll(
                    chat_id=chat,
                    question=f"üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá ‚Äì ÿ®ÿÆÿ¥ {idx}/{total_polls}",
                    options=chunk,
                    is_anonymous=False,
                    allows_multiple_answers=True
                )
                g.last_poll_ids = getattr(g, "last_poll_ids", []) + [poll_msg.message_id]
                store.save()

                await asyncio.sleep(11)  # ÿ®ÿ≤ÿßÿ± ŸÖÿ±ÿØŸÖ ÿ±ÿ£€å ÿ®ÿØŸÜ

                try:
                    await ctx.bot.stop_poll(chat_id=chat, message_id=poll_msg.message_id)
                except Exception as e:
                    print(f"‚ö†Ô∏è stop_poll error (part {idx}):", e)

            except Exception as e:
                print(f"‚ùå poll send error (part {idx}):", e)

        await ctx.bot.send_message(chat, f"‚úÖ {total_polls} ÿ±ÿß€å‚Äå⁄Ø€åÿ±€å ÿ®ÿ≥ÿ™Ÿá ÿ¥ÿØ.")
        return

    if data == "back_to_controls" and uid == g.god_id:
        await set_hint_and_kb(ctx, chat, g, None, control_keyboard(g), mode=CTRL)
        return

        return


    if data == "back_vote_init" and uid == g.god_id:
        g.phase = "voting_selection"
        g.voted_targets = set()  # üßπ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ŸÇÿ®ŸÑÿßŸã ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å‚Äåÿ¥ÿØŸá
        store.save()
        await ctx.bot.send_message(chat, "‚Ü©Ô∏è ŸÖÿ¨ÿØÿØÿßŸã ⁄©ÿßŸÜÿØ€åÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.")
        await start_vote(ctx, chat, g, "initial_vote")
        return


    if data == "final_vote" and uid == g.god_id:
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return
        g.votes_cast = {}
        g.vote_logs = {}
        g.current_vote_target = None
        g.voted_targets = set()
        store.save()

        g.vote_type = "awaiting_defense"
        msg = await ctx.bot.send_message(
            chat,
            "üì¢ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (ŸÖÿ´ÿßŸÑ: 1 3 5):",
            reply_markup=ForceReply(selective=True)
        )
        g.defense_prompt_msg_id = msg.message_id
        store.save()
        return

    if data == "status_query" and uid == g.god_id:
        g.status_mode = True
        await publish_seating(ctx, chat, g, mode="status")
        return

    if g.status_mode:
        changed = False

        if data == "inc_citizen":
            g.status_counts["citizen"] += 1
            changed = True

        elif data == "dec_citizen":
            if g.status_counts["citizen"] == 0:
                
                await safe_q_answer(q, "ÿßÿ≤ ÿµŸÅÿ± ⁄©ŸÖÿ™ÿ± ŸÜŸÖ€åÿ¥Ÿá.", show_alert=True)
                warn = await ctx.bot.send_message(chat, "‚ö†Ô∏è  ⁄©ŸÖÿ™ÿ± ÿßÿ≤ ÿµŸÅÿ± ŸÜŸÖ€å‚Äåÿ¥ŸàÿØ.")
               
                async def _cleanup(msg_id: int):
                    await asyncio.sleep(2)
                    try:
                        await ctx.bot.delete_message(chat_id=chat, message_id=msg_id)
                    except Exception:
                        pass
                asyncio.create_task(_cleanup(warn.message_id))
                # UI ÿ±ÿß ŸáŸÖÿßŸÜ ÿ≠ÿßŸÑÿ™ status ŸÜ⁄ØŸá ÿØÿßÿ±
                await publish_seating(ctx, chat, g, mode="status")
                return
            g.status_counts["citizen"] -= 1
            changed = True

        elif data == "inc_mafia":
            g.status_counts["mafia"] += 1
            changed = True

        elif data == "dec_mafia":
            if g.status_counts["mafia"] == 0:
                await safe_q_answer(q, "ÿßÿ≤ ÿµŸÅÿ± ⁄©ŸÖÿ™ÿ± ŸÜŸÖ€åÿ¥Ÿá.", show_alert=True)
                warn = await ctx.bot.send_message(chat, "‚ö†Ô∏è  ⁄©ŸÖÿ™ÿ± ÿßÿ≤ ÿµŸÅÿ± ŸÜŸÖ€å‚Äåÿ¥ŸàÿØ.")
                async def _cleanup(msg_id: int):
                    await asyncio.sleep(2)
                    try:
                        await ctx.bot.delete_message(chat_id=chat, message_id=msg_id)
                    except Exception:
                        pass
                asyncio.create_task(_cleanup(warn.message_id))
                await publish_seating(ctx, chat, g, mode="status")
                return
            g.status_counts["mafia"] -= 1
            changed = True

        elif data == "confirm_status":
            g.status_mode = False
            store.save()

            c = g.status_counts.get("citizen", 0)
            m = g.status_counts.get("mafia", 0)

            await ctx.bot.send_message(
                chat,
                f"üì¢ ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™ :\n {c} ÿ¥Ÿáÿ±ŸàŸÜÿØ\n {m} ŸÖÿßŸÅ€åÿß"
            )
            await publish_seating(ctx, chat, g, mode=CTRL)
            return

        if changed:
            store.save()
            await publish_seating(ctx, chat, g, mode="status")
        return

    if data == "status_auto":
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™ ÿ®⁄Ø€åÿ±ÿØ!")
            return

        mafia_roles = load_mafia_roles()
        dead_seats = [s for s in g.striked]  
        mafia_count = 0
        citizen_count = 0

        for s in dead_seats:
            role = g.assigned_roles.get(s)
            if role and role in mafia_roles:
                mafia_count += 1
            else:
                citizen_count += 1

        # ÿ∞ÿÆ€åÿ±Ÿá ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ ÿØÿ± ŸÑ€åÿ≥ÿ™
        g.status_counts = {"citizen": citizen_count, "mafia": mafia_count}
        g.status_mode = False
        store.save()

        await ctx.bot.send_message(
            chat,
            f"üì¢ ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™ :\n {citizen_count} ÿ¥Ÿáÿ±ŸàŸÜÿØ\n {mafia_count} ŸÖÿßŸÅ€åÿß"
        )
        await publish_seating(ctx, chat, g, mode=CTRL)
        return


    if data == "back_vote_final" and uid == g.god_id:
        g.phase = "defense_selection"
        g.vote_type = "awaiting_defense"
        g.voted_targets = set()  # üßπ Ÿæÿß⁄©‚Äåÿ≥ÿßÿ≤€å ŸÑ€åÿ≥ÿ™ ÿ™€å⁄©‚ÄåŸáÿß ŸáŸÜ⁄ØÿßŸÖ ÿ®ÿ±⁄Øÿ¥ÿ™
        store.save()

        msg = await ctx.bot.send_message(
            chat,
            "‚Ü©Ô∏è ÿØŸàÿ®ÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=ForceReply(selective=True)
        )
        g.defense_prompt_msg_id = msg.message_id
        store.save()
        return

    if data.startswith("vote_"):
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚õî ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ±ÿ£€å ÿ®ÿØŸáÿØ!")
            return
        seat_str = data.split("_")[1]
        if seat_str.isdigit():
            await handle_vote(ctx, chat, g, int(seat_str))
        return

def status_button_markup(g: GameState) -> InlineKeyboardMarkup:
    c = g.status_counts.get("citizen", 0)
    m = g.status_counts.get("mafia", 0)
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(f"‚ö™ {c}", callback_data="noop"),
            InlineKeyboardButton("‚¨ÜÔ∏è", callback_data="inc_citizen"),
            InlineKeyboardButton("‚¨áÔ∏è", callback_data="dec_citizen")
        ],
        [
            InlineKeyboardButton(f"‚ö´ {m}", callback_data="noop"),
            InlineKeyboardButton("‚¨ÜÔ∏è", callback_data="inc_mafia"),
            InlineKeyboardButton("‚¨áÔ∏è", callback_data="dec_mafia")
        ],
        [
            InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_status")
        ]
    ])

def strike_button_markup(g: GameState) -> InlineKeyboardMarkup:
    rows = []

    for i in range(1, g.max_seats + 1):
        if i in g.pending_strikes:
            label = f"{i} ‚ùå"
        else:
            label = f"{i} ‚úÖ"
        rows.append([InlineKeyboardButton(label, callback_data=f"strike_toggle_{i}")])

    # ÿØ⁄©ŸÖŸá ÿ™ÿß€å€åÿØ ŸÜŸáÿß€å€å
    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿß€å€åÿØ ÿÆÿ∑‚Äåÿ≤ÿØŸÜ", callback_data="strike_toggle_done")])

    return InlineKeyboardMarkup(rows)


async def shuffle_and_assign(
    ctx,
    chat_id: int,
    g: GameState,
    shuffle_seats: bool = True,
    uid_to_role: dict[int, str] | None = None,
    notify_players: bool = True,
    preview_mode: bool = False,
    role_shuffle_repeats: int = 1,
):

    # 1) ÿ®ÿßÿ≤€å⁄©ŸÜ‚ÄåŸáÿß ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ™ÿ±ÿ™€åÿ® ŸÅÿπŸÑ€å ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß
    players = [g.seats[i] for i in sorted(g.seats)]
    uids = [uid for uid, _ in players]

    # 2) ÿß⁄Øÿ± ŸÜ⁄Øÿßÿ¥ÿ™ ŸÜŸÇÿ¥‚Üíÿ®ÿßÿ≤€å⁄©ŸÜ ÿØÿßÿØŸá ŸÜÿ¥ÿØŸáÿå ÿß€åŸÜÿ¨ÿß ÿ®ÿ≥ÿßÿ≤ (ŸÖÿ≥ÿ™ŸÇŸÑ ÿßÿ≤ ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å)
    if uid_to_role is None:
        pool = [r for r, n in g.scenario.roles.items() for _ in range(n)]
        uids_for_roles = uids[:]
        reps = max(1, int(role_shuffle_repeats))
        for _ in range(reps):
            random.shuffle(pool)
            random.shuffle(uids_for_roles)
        uid_to_role = {uid_: pool[i] for i, uid_ in enumerate(uids_for_roles)}

    # 3) ÿ≠ÿßŸÑÿ™ Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥: ŸÅŸÇÿ∑ ŸÜ⁄Øÿßÿ¥ÿ™ ÿ±ÿß ÿ∞ÿÆ€åÿ±Ÿá ⁄©ŸÜ Ÿà ÿÆÿßÿ±ÿ¨ ÿ¥Ÿà (Ÿá€å⁄Ü Ÿæ€åÿßŸÖ/ÿ™ÿ∫€å€åÿ±€å ÿßÿπŸÖÿßŸÑ ŸÜ⁄©ŸÜ)
    if preview_mode:
        g.preview_uid_to_role = uid_to_role
        store.save()
        return uid_to_role

    # 4) ŸÜŸáÿß€å€å‚Äåÿ≥ÿßÿ≤€å: ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜ€åÿßÿ≤ÿå ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿ±ÿß ÿ®Ÿá ÿ™ÿπÿØÿßÿØ ŸÖÿ¥ÿÆÿµ ÿ¥ÿßŸÅŸÑ ⁄©ŸÜ
    if shuffle_seats:
        reps = max(1, int(role_shuffle_repeats))
        for _ in range(reps):
            random.shuffle(players)

    g.seats = {i + 1: (uid, name) for i, (uid, name) in enumerate(players)}

    # 5) ŸÜÿ≥ÿ®ÿ™‚ÄåÿØÿßÿØŸÜ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ®Ÿá ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿßÿ≤ ÿ±Ÿà€å uid
    g.assigned_roles = {
        seat: uid_to_role[g.seats[seat][0]]
        for seat in g.seats
    }

    # 6) ÿßÿ±ÿ≥ÿßŸÑ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ®Ÿá ÿ®ÿßÿ≤€å⁄©ŸÜ‚ÄåŸáÿß (ÿßÿÆÿ™€åÿßÿ±€å) Ÿà ÿ≥ÿßÿÆÿ™ ŸÑÿß⁄Ø ÿ®ÿ±ÿß€å ⁄ØÿßÿØ
    log, unreachable = [], []
    stickers = load_stickers()
    if notify_players:
        for seat in sorted(g.seats):
            uid, name = g.seats[seat]
            role = g.assigned_roles[seat]
            if role in stickers:
                try:
                    await ctx.bot.send_sticker(uid, stickers[role])
                except:
                    pass
            try:
                await ctx.bot.send_message(uid, f"üé≠ ŸÜŸÇÿ¥ ÿ¥ŸÖÿß: {role}")
            except telegram.error.Forbidden:
                unreachable.append(name)

    for seat in sorted(g.seats):
        uid, name = g.seats[seat]
        role = g.assigned_roles[seat]
        log.append(f"{seat:>2}. <a href='tg://user?id={uid}'>{name}</a> ‚Üí {role}")


    if g.god_id:
        text = "üëë ÿÆŸÑÿßÿµŸáŸî ŸÜŸÇÿ¥‚ÄåŸáÿß:\n" + "\n".join(log)
        if unreachable:
            text += "\n‚ö†Ô∏è ŸÜÿ¥ÿØ ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿßŸÅÿ±ÿßÿØ Ÿæ€åÿßŸÖ ÿ®ŸÅÿ±ÿ≥ÿ™ŸÖ: " + ", ".join(unreachable)
        try:
            await ctx.bot.send_message(g.god_id, text, parse_mode="HTML")
        except:
            pass

    # 7) ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÅÿßÿ≤ Ÿà UI
    g.phase = "playing"
    store.save()
    await publish_seating(ctx, chat_id, g, mode=CTRL)

    return uid_to_role





async def handle_simple_seat_command(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    chat_id = msg.chat.id
    uid = msg.from_user.id
    g = gs(chat_id)

    # ‚õî ŸÅŸÇÿ∑ ÿØÿ± ÿ≠ÿßŸÑÿ™ "idle" ÿßÿ¨ÿßÿ≤Ÿá ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ®ÿß /ÿπÿØÿØ Ÿáÿ≥ÿ™
    if g.phase != "idle":
        return

    if not hasattr(g, 'user_names') or g.user_names is None:
        g.user_names = load_usernames_from_gist()

    command_text = msg.text.split('@')[0]
    try:
        seat_no = int(command_text[1:])
    except:
        return

    if seat_no in g.seats:
        await ctx.bot.send_message(chat_id, f"‚ùó ÿµŸÜÿØŸÑ€å {seat_no} ŸÇÿ®ŸÑÿßŸã ŸæŸèÿ± ÿ¥ÿØŸá.")
        return

    if uid in [u for u, _ in g.seats.values()]:
        await ctx.bot.send_message(chat_id, "‚ùó ÿ¥ŸÖÿß ŸÇÿ®ŸÑÿßŸã ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.")
        return

    name = g.user_names.get(uid, "ŸÜÿßÿ¥ŸÜÿßÿ≥")
    g.seats[seat_no] = (uid, name)
    store.save()
    await publish_seating(ctx, chat_id, g)
    await ctx.bot.send_message(chat_id, f"‚úÖ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å {seat_no} ÿ®ÿß ŸÜÿßŸÖ ¬´{name}¬ª ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ.")


async def name_reply(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if not msg or not msg.text:
        return

    text = msg.text.strip()
    uid = msg.from_user.id
    chat_id = msg.chat.id
    g = gs(chat_id)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # 1) ÿ™ÿ∫€å€åÿ± ÿ≥ÿßÿπÿ™ ÿ¥ÿ±Ÿàÿπ (ŸÅŸÇÿ∑ ÿ™Ÿàÿ≥ÿ∑ ⁄ØÿßÿØ) ‚Äì ÿ®ÿß €åÿß ÿ®ÿØŸàŸÜ ÿ±€åŸæŸÑÿß€å
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if g.vote_type == "awaiting_time" and uid == g.god_id:

        g.event_time = text
        g.vote_type = None
        store.save()
        await publish_seating(ctx, chat_id, g)
        await ctx.bot.send_message(chat_id, f"‚úÖ ÿ≥ÿßÿπÿ™ ÿ±Ÿà€åÿØÿßÿØ ÿ±Ÿà€å {text} ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ.")
        return

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # 2) ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ/ÿ¨ÿßÿ®ÿ¨ÿß€å€å ÿ®ÿß ÿ±€åŸæŸÑÿß€å ÿ®Ÿá ŸÑ€åÿ≥ÿ™: ⁄©ÿßÿ±ÿ®ÿ± ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å ŸÖ€å‚ÄåŸÜŸà€åÿ≥ÿØ
    #    - ÿß⁄Øÿ± ŸÇÿ®ŸÑÿßŸã ŸÜÿ¥ÿ≥ÿ™Ÿá ÿ®ŸàÿØÿå ÿ¨ÿßÿ®Ÿá‚Äåÿ¨ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ
    #    - ÿß⁄Øÿ± ÿßÿ≥ŸÖ ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿ®ÿßÿ¥ÿØÿå ¬´ŸÜÿßÿ¥ŸÜÿßÿ≥¬ª
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (
        msg.reply_to_message
        and g.last_seating_msg_id
        and msg.reply_to_message.message_id == g.last_seating_msg_id
    ):
        if text.isdigit():
            seat_no = int(text)

            if not (1 <= seat_no <= g.max_seats):
                await ctx.bot.send_message(chat_id, "‚ùå ÿ¥ŸÖÿßÿ±ŸáŸî ÿµŸÜÿØŸÑ€å ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™.")
                return

            if seat_no in g.seats:
                await ctx.bot.send_message(chat_id, f"‚ùå ÿµŸÜÿØŸÑ€å {seat_no} ŸÇÿ®ŸÑÿßŸã ŸæŸèÿ± ÿ¥ÿØŸá.")
                return

            # ŸÜÿßŸÖ ÿ™ÿ±ÿ¨€åÿ≠€å
            preferred_name = g.user_names.get(uid, None)

            # ÿ¢€åÿß ⁄©ÿßÿ±ÿ®ÿ± ŸÇÿ®ŸÑÿßŸã ÿ±Ÿà€å ÿµŸÜÿØŸÑ€å‚Äåÿß€å ŸÜÿ¥ÿ≥ÿ™Ÿáÿü
            existing_seat = None
            existing_name = None
            for s, (u, n) in g.seats.items():
                if u == uid:
                    existing_seat = s
                    existing_name = n
                    break

            final_name = preferred_name or existing_name or "ŸÜÿßÿ¥ŸÜÿßÿ≥"

            if existing_seat is not None:
                # ÿ¨ÿßÿ®ÿ¨ÿß€å€å
                del g.seats[existing_seat]
                g.seats[seat_no] = (uid, final_name)
                store.save()
                await publish_seating(ctx, chat_id, g)
                await ctx.bot.send_message(
                    chat_id,
                    f"‚Ü™Ô∏è ¬´{final_name}¬ª ÿßÿ≤ ÿµŸÜÿØŸÑ€å {existing_seat} ÿ®Ÿá ÿµŸÜÿØŸÑ€å {seat_no} ŸÖŸÜÿ™ŸÇŸÑ ÿ¥ÿØ."
                )
                return

            # ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ¨ÿØ€åÿØ
            g.seats[seat_no] = (uid, final_name)
            store.save()
            await publish_seating(ctx, chat_id, g)
            await ctx.bot.send_message(
                chat_id,
                f"‚úÖ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å {seat_no} ÿ®ÿß ŸÜÿßŸÖ ¬´{final_name}¬ª ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ."
            )
            return

    if g.phase == "idle" and text.strip() == "⁄©ŸÜÿ≥ŸÑ":
        for seat, (player_uid, _) in list(g.seats.items()):
            if player_uid == uid:
                del g.seats[seat]
                store.save()
                await ctx.bot.send_message(chat_id, "‚ùé ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÑÿ∫Ÿà ÿ¥ÿØ.")
                await publish_seating(ctx, chat_id, g)
                break
        else:
            await ctx.bot.send_message(chat_id, "‚ùó ÿ¥ŸÖÿß ÿØÿ± ŸÑ€åÿ≥ÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.")
        return
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # 3) ÿ™ÿ∫€å€åÿ± ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± (ŸÅŸÇÿ∑ ŸàŸÇÿ™€å ÿßÿ≤ ÿØ⁄©ŸÖŸá ¬´‚úèÔ∏è ÿ™ÿ∫€å€åÿ± ŸÜÿßŸÖ¬ª Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá)
    #    g.waiting_name[uid] = seat_no
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if uid in g.waiting_name:
        target_seat = g.waiting_name[uid]  # ŸÅŸÑ⁄Ø ÿ±ÿß ŸÅÿπŸÑÿßŸã Ÿæÿß⁄© ŸÜ⁄©ŸÜ€åŸÖ

        import re
        if not re.match(r'^[\u0600-\u06FF\s]+$', text):
            await ctx.bot.send_message(
                chat_id,
                "‚ùó ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿ±ÿß ŸÅŸÇÿ∑ ÿ®ÿß ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ. ÿØŸàÿ®ÿßÿ±Ÿá ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ€åÿØ:"
            )
            return

        # Ÿàÿ±ŸàÿØ€å ŸÖÿπÿ™ÿ®ÿ± ÿ¥ÿØ ‚Üí ŸÅŸÑ⁄Ø ÿ±ÿß Ÿæÿß⁄© ⁄©ŸÜ
        g.waiting_name.pop(uid, None)

        # ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿßŸÖ ÿ¨ÿØ€åÿØ ÿØÿ± ÿØŸÅÿ™ÿ±⁄ÜŸá
        g.user_names[uid] = text

        # ÿß⁄Øÿ± ŸáŸÜŸàÿ≤ ÿ±Ÿà€å ŸáŸÖÿßŸÜ ÿµŸÜÿØŸÑ€å ÿßÿ≥ÿ™ÿå ŸáŸÖÿßŸÜ ÿ±ÿß ÿ¢ŸæÿØ€åÿ™ ⁄©ŸÜ
        if target_seat in g.seats and g.seats[target_seat][0] == uid:
            g.seats[target_seat] = (uid, text)
            changed_seat = target_seat
        else:
            # ÿß⁄Øÿ± ÿ¨ÿß€å ÿØ€å⁄Øÿ±€å ŸÜÿ¥ÿ≥ÿ™Ÿáÿå ÿµŸÜÿØŸÑ€å ŸÅÿπŸÑ€å‚Äåÿßÿ¥ ÿ±ÿß Ÿæ€åÿØÿß Ÿà ÿ¢ŸæÿØ€åÿ™ ⁄©ŸÜ
            changed_seat = None
            for s, (u, n) in list(g.seats.items()):
                if u == uid:
                    g.seats[s] = (uid, text)
                    changed_seat = s
                    break

        store.save()
        mode = CTRL if g.phase != "idle" else REG
        await publish_seating(ctx, chat_id, g, mode=mode)
 

        # Ÿæ€åÿßŸÖ ÿ™ÿ£€å€åÿØ
        if changed_seat:
            await ctx.bot.send_message(chat_id, f"‚úÖ ŸÜÿßŸÖ ÿµŸÜÿØŸÑ€å {changed_seat} ÿ®Ÿá ¬´{text}¬ª ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ.")
        else:
            await ctx.bot.send_message(chat_id, f"‚úÖ ŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®Ÿá ¬´{text}¬ª ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ.")

        # ŸÜŸàÿ¥ÿ™ŸÜ ÿ±Ÿà€å Gist ÿ®ÿπÿØ ÿßÿ≤ UI (ÿ®ÿ±ÿß€å ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ⁄©ŸÜÿØ€å)
        try:
            save_usernames_to_gist(g.user_names)
        except Exception:
            pass

        return

async def show_scenario_selection(ctx, chat_id: int, g: GameState):
    """ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ÿ≥ŸÜÿßÿ±€åŸàŸáÿß€å ŸÖŸàÿ¨ŸàÿØ ÿ®ÿ±ÿß€å ÿßŸÜÿ™ÿÆÿßÿ®"""
    valid_scenarios = [s for s in store.scenarios if sum(s.roles.values()) == g.max_seats]
    
    if not valid_scenarios:
        await ctx.bot.send_message(chat_id, "‚ùó ÿ≥ŸÜÿßÿ±€åŸà€å ŸÖŸÜÿßÿ≥ÿ® ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿ™ÿπÿØÿßÿØ ÿ®ÿßÿ≤€å⁄©ŸÜ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.")
        return
    
    # ÿß€åÿ¨ÿßÿØ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ≥ŸÜÿßÿ±€åŸà
    btns = [
        [InlineKeyboardButton(f"{s.name} ({sum(s.roles.values())} ŸÜŸÅÿ±)", callback_data=f"sc_{i}")]
        for i, s in enumerate(valid_scenarios)
    ]
    
    # ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿØ⁄©ŸÖŸá ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿß⁄Øÿ± ÿ®ÿßÿ≤€å ÿØÿ± ÿ≠ÿßŸÑ ÿßŸÜÿ¨ÿßŸÖ ÿßÿ≥ÿ™
    if g.phase != "idle":
        btns.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_game")])
    
    # ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà
    scenario_msg = await ctx.bot.send_message(
        chat_id,
        "üé≠ ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿ≥ŸÜÿßÿ±€åŸà ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
        reply_markup=InlineKeyboardMarkup(btns)
    )
    # ÿ∞ÿÆ€åÿ±Ÿá message_id ÿ®ÿ±ÿß€å ÿ≠ÿ∞ŸÅ ÿ®ÿπÿØ€å
    g.scenario_prompt_msg_id = scenario_msg.message_id
    g.awaiting_scenario = True
    store.save()


async def newgame(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat.id
    uid = update.effective_user.id

    # ŸÅŸÇÿ∑ ⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å ŸÅÿπÿßŸÑ
    if chat not in store.active_groups:
        await update.message.reply_text("‚õî ÿß€åŸÜ ⁄Øÿ±ŸàŸá ŸáŸÜŸàÿ≤ ŸÅÿπÿßŸÑ ŸÜÿ¥ÿØŸá. ÿßÿØŸÖ€åŸÜ ÿßÿµŸÑ€å ÿ®ÿß€åÿØ /active ÿ®ÿ≤ŸÜÿØ.")
        return

    # ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß
    if update.effective_chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ ⁄Øÿ±ŸàŸá
    member = await ctx.bot.get_chat_member(chat, uid)
    if member.status not in {"administrator", "creator"}:
        await update.message.reply_text("ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿ®ÿßÿ≤€å ÿ¨ÿØ€åÿØ ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜŸÜ.")
        return

    # ÿß⁄Øÿ± ÿ¢ÿ±⁄ØŸàŸÖÿßŸÜ ŸÜÿØÿßÿØ ‚Üí Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ €±€∞
    seats = 10
    if ctx.args and ctx.args[0].isdigit():
        seats = int(ctx.args[0])

    # ÿ≥ÿßÿÆÿ™ ⁄Ø€åŸÖ ÿ¨ÿØ€åÿØ
    store.games[chat] = GameState(max_seats=seats)
    g = gs(chat)

    # ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å/ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿßŸÖ‚ÄåŸáÿß ÿØÿ± Gist
    g.user_names = load_usernames_from_gist()
    save_usernames_to_gist(g.user_names)

    # ⁄ØÿßÿØ Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ = ÿßÿ¨ÿ±ÿß⁄©ŸÜŸÜÿØŸáŸî /newgame
    god_name = g.user_names.get(uid) or (update.effective_user.full_name or "‚Äî")
    g.god_id = uid
    g.god_name = god_name

    # ÿ≥ŸÜÿßÿ±€åŸà€å ÿ™ÿµÿßÿØŸÅ€å ÿ®ÿß ÿ∏ÿ±ŸÅ€åÿ™ seats
    candidates = [s for s in store.scenarios if sum(s.roles.values()) == seats]
    if candidates:
        import random
        g.scenario = random.choice(candidates)
        g.last_roles_scenario_name = None  # ÿ™ÿß ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿØŸàÿ®ÿßÿ±Ÿá ⁄ÜÿßŸæ ÿ¥ŸàÿØ
        g.awaiting_scenario = False
    else:
        g.scenario = None
        g.awaiting_scenario = True

    # ÿ¢ŸÖÿßÿ± ¬´waiting_list¬ª
    now = datetime.now(timezone.utc).timestamp()
    store.group_stats.setdefault(chat, {"waiting_list": [], "started": [], "ended": []})
    store.group_stats[chat]["waiting_list"].append(now)
    store.save()

    # ÿßŸÜÿ™ÿ¥ÿßÿ± ŸÑ€åÿ≥ÿ™ ÿßŸàŸÑ€åŸá
    await publish_seating(ctx, chat, g, mode=REG)
    # ÿß⁄Øÿ± ÿ≥ŸÜÿßÿ±€åŸà Ÿæ€åÿØÿß ŸÜÿ¥ÿØÿå ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà ÿ±ÿß ÿ®ÿßÿ≤ ⁄©ŸÜ
    if g.awaiting_scenario:
        g.from_startgame = True
        store.save()
        await show_scenario_selection(ctx, chat, g)



async def reset_game(ctx: ContextTypes.DEFAULT_TYPE = None, update: Update = None, chat_id: int = None):
    """ÿ±€åÿ≥ÿ™ ÿ®ÿßÿ≤€å ÿ®ÿß ÿ≠ŸÅÿ∏ ŸÜÿßŸÖ‚ÄåŸáÿß ‚Äì ŸáŸÖ ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ®ÿ±ÿß€å /resetgame Ÿà ŸáŸÖ ÿßÿ≤ ÿØÿßÿÆŸÑ ÿ®ÿßÿ™"""
    if update:
        chat_id = update.effective_chat.id
    elif not chat_id:
        raise ValueError("chat_id ÿ®ÿß€åÿØ ŸÖÿ¥ÿÆÿµ ÿ¥ŸàÿØ ÿß⁄Øÿ± update Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ")

    # üîÑ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ŸÜÿßŸÖ‚ÄåŸáÿß
    usernames = load_usernames_from_gist()

    store.games[chat_id] = GameState()
    g = store.games[chat_id]
    g.user_names = usernames
    save_usernames_to_gist(g.user_names)
    store.save()

    # ÿß⁄Øÿ± ÿßÿ≤ ÿ∑ÿ±€åŸÇ ÿØÿ≥ÿ™Ÿàÿ± ÿßŸàŸÖÿØŸáÿå Ÿæ€åÿßŸÖ ÿ®ŸÅÿ±ÿ≥ÿ™
    if update and update.message:
        await update.message.reply_text("üîÅ ÿ®ÿßÿ≤€å ÿ®ÿß ÿ≠ŸÅÿ∏ ŸÜÿßŸÖ‚ÄåŸáÿß ÿ±€åÿ≥ÿ™ ÿ¥ÿØ.")

async def resetgame_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    user = update.effective_user

    # ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ¨ÿ±ÿß ÿ®ÿßÿ¥Ÿá
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ⁄©ÿßÿ±ÿ®ÿ± ÿßÿØŸÖ€åŸÜ Ÿáÿ≥ÿ™ €åÿß ŸÜŸá
    try:
        admins = await ctx.bot.get_chat_administrators(chat.id)
        admin_ids = [admin.user.id for admin in admins]
        if user.id not in admin_ids:
            await update.message.reply_text("ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ÿ±Ÿà ÿßÿ¨ÿ±ÿß ⁄©ŸÜŸÜ.")
            return
    except:
        await update.message.reply_text("ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿ±ÿ±ÿ≥€å ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß.")
        return

    # ÿßÿ¨ÿ±ÿß€å ÿ±€åÿ≥ÿ™ ÿ®ÿßÿ≤€å
    await reset_game(ctx=ctx, update=update)



async def add_seat_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not ctx.args or not ctx.args[0].isdigit():
        await update.message.reply_text("Usage: /add <seat>")
        return

    seat = int(ctx.args[0])
    uid = update.effective_user.id
    chat = update.effective_chat.id
    g = gs(chat)

    if uid != g.god_id:
        return

    if seat in g.seats:
        await update.message.reply_text("‚ùå Seat already taken.")
        return

    if not update.message.reply_to_message:
        await update.message.reply_text("‚ùå Use this command by replying to a message from the user you want to add.")
        return

    target_uid = update.message.reply_to_message.from_user.id

    # üß† ÿ®ÿ±ÿ±ÿ≥€å ŸÜÿßŸÖ ÿ∞ÿÆ€åÿ±Ÿá‚Äåÿ¥ÿØŸá ÿØÿ± gist
    name = g.user_names.get(target_uid, "ŸÜÿßÿ¥ŸÜÿßÿ≥")
    g.seats[seat] = (target_uid, name)
    store.save()

    await update.message.reply_text(f"‚úÖ ÿµŸÜÿØŸÑ€å {seat} ÿ®ÿß ŸÜÿßŸÖ '{name}' ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.")

    # üñ• ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÑ€åÿ≥ÿ™ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß
    await publish_seating(ctx, chat, g)

async def addscenario(update: Update, ctx):
    """/addscenario <name> role1:n1 role2:n2 ..."""

    if update.effective_chat.id not in store.active_groups:
        return  # ⁄Øÿ±ŸàŸá ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤

    # ŸÅŸÇÿ∑ ÿ™Ÿà€å ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ÿ®ÿ±ÿ±ÿ≥€å ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    if update.message.chat.type in ["group", "supergroup"]:
        chat_id = update.effective_chat.id
        user_id = update.effective_user.id
        member = await ctx.bot.get_chat_member(chat_id, user_id)

        if member.status not in ["administrator", "creator"]:
            await update.message.reply_text("‚ö†Ô∏è ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿ≥ŸÜÿßÿ±€åŸà ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜŸÜ.")
            return

    if len(ctx.args) < 2:
        await update.message.reply_text("Usage: /addscenario <name> role1:n1 role2:n2 ...")
        return

    name = ctx.args[0]
    roles: dict[str, int] = {}
    for pair in ctx.args[1:]:
        if ":" in pair:
            r, n = pair.split(":")
            roles[r.strip()] = int(n)

    new_scenario = Scenario(name, roles)
    store.scenarios.append(new_scenario)
    store.save()
    save_scenarios_to_gist(store.scenarios)

    await update.message.reply_text(f"‚úÖ ÿ≥ŸÜÿßÿ±€åŸà '{name}' ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ ÿ®ÿß ŸÜŸÇÿ¥‚ÄåŸáÿß: {roles}")



async def list_scenarios(update: Update, ctx):
    store.scenarios = load_scenarios_from_gist()  # üëà ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿßÿ≤ Gist

    if not store.scenarios:
        await update.message.reply_text("‚ùå No scenarios found.")
        return

    lines = ["üìã ŸÑ€åÿ≥ÿ™ ÿ≥ŸÜÿßÿ±€åŸàŸáÿß:"]
    for i, s in enumerate(store.scenarios, 1):
        role_summary = ", ".join(f"{role}: {count}" for role, count in s.roles.items())
        lines.append(f"{i}. {s.name} ({role_summary})")

    await update.message.reply_text("\n".join(lines))


async def remove_scenario(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat = update.effective_chat

    if chat.id not in store.active_groups:
        return  # ⁄Øÿ±ŸàŸá ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤

    # üîê ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ÿßÿ¨ÿßÿ≤Ÿá ÿØÿßÿ±ŸÜÿØ ÿ≥ŸÜÿßÿ±€åŸà ÿ≠ÿ∞ŸÅ ⁄©ŸÜŸÜÿØ
    if chat.type != "private":
        member = await ctx.bot.get_chat_member(chat.id, user.id)
        if member.status not in ("administrator", "creator"):
            await update.message.reply_text("‚ö†Ô∏è ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿ≥ŸÜÿßÿ±€åŸà ÿ≠ÿ∞ŸÅ ⁄©ŸÜŸÜ.")
            return

    if not ctx.args:
        await update.message.reply_text("‚ùå ŸÜÿ≠ŸàŸá ÿßÿ≥ÿ™ŸÅÿßÿØŸá: /removescenario <ŸÜÿßŸÖ ÿ≥ŸÜÿßÿ±€åŸà>")
        return

    name = " ".join(ctx.args).strip()
    before = len(store.scenarios)
    store.scenarios = [s for s in store.scenarios if s.name != name]
    after = len(store.scenarios)

    if before == after:
        await update.message.reply_text(f"‚ö†Ô∏è ÿ≥ŸÜÿßÿ±€åŸà€å€å ÿ®ÿß ŸÜÿßŸÖ ¬´{name}¬ª Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.")
    else:
        store.save()
        save_scenarios_to_gist(store.scenarios)
        await update.message.reply_text(f"üóëÔ∏è ÿ≥ŸÜÿßÿ±€åŸà€å ¬´{name}¬ª ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.")

 
async def dynamic_timer(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat.id
    uid = update.effective_user.id
    g = gs(chat)

    # ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ÿßÿ¨ÿ±ÿß€å ÿ™ÿß€åŸÖÿ± ÿ±Ÿà€å Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ŸÇÿØ€åŸÖ€å
    if (datetime.now(timezone.utc) - update.message.date).total_seconds() > 10:
        return  

    if uid != g.god_id:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ⁄ØÿßÿØ ŸÖ€å‚Äåÿ™ŸàŸÜŸá ÿ™ÿß€åŸÖÿ± ÿ®ÿ≤ŸÜŸá.")
        return

    cmd = update.message.text.strip().lstrip("/")
    if not cmd.endswith("s") or not cmd[:-1].isdigit():
        await update.message.reply_text("‚ùó ÿØÿ≥ÿ™Ÿàÿ± ÿØÿ±ÿ≥ÿ™ ŸÜ€åÿ≥ÿ™. ŸÖÿ´ÿßŸÑ: /20s")
        return

    seconds = int(cmd[:-1])
    await update.message.reply_text(f"‚è≥ ÿ™ÿß€åŸÖÿ± {seconds} ÿ´ÿßŸÜ€åŸá‚Äåÿß€å ÿ¥ÿ±Ÿàÿπ ÿ¥ÿØ...")

    
    asyncio.create_task(run_timer(ctx, chat, seconds))


async def run_timer(ctx, chat: int, seconds: int):
    try:
        await asyncio.sleep(seconds)
        await ctx.bot.send_message(chat, "‚è∞ ÿ™ÿß€åŸÖ ÿ™ŸÖÿßŸÖ")
    except Exception as e:
        print("‚ö†Ô∏è run_timer error:", e)


async def transfer_god_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat.id

    # 1) ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å ŸÅÿπÿßŸÑ
    if chat not in store.active_groups:
        await update.message.reply_text("‚õî ÿß€åŸÜ ⁄Øÿ±ŸàŸá ŸáŸÜŸàÿ≤ ŸÅÿπÿßŸÑ ŸÜÿ¥ÿØŸá. ÿßŸàŸÑ /active ÿ±ÿß ÿ®ÿ≤ŸÜ.")
        return

    g = gs(chat)

    # 2) ŸÅŸÇÿ∑ ÿ®ÿπÿØ ÿßÿ≤ ÿ≥ÿßÿÆÿ™ ÿ®ÿßÿ≤€å
    if not g.max_seats or g.max_seats <= 0:
        await update.message.reply_text("‚ö†Ô∏è ÿßŸàŸÑ ÿ®ÿß /newgame <seats> ÿ®ÿßÿ≤€å ÿ®ÿ≥ÿßÿ≤ÿå ÿ®ÿπÿØ /god ÿ®ÿ≤ŸÜ.")
        return

    # ‚úÖ ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß €åÿß ⁄ØÿßÿØ ŸÅÿπŸÑ€å ÿßÿ¨ÿßÿ≤Ÿá ÿ™ÿ∫€å€åÿ± ⁄ØÿßÿØ ÿØÿßÿ±ŸÜÿØ
    admins = await ctx.bot.get_chat_administrators(chat)
    admin_ids = {admin.user.id for admin in admins}
    is_current_god = update.effective_user.id == g.god_id
    if update.effective_user.id not in admin_ids and not is_current_god:
        await update.message.reply_text("‚ùå ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá €åÿß ⁄ØÿßÿØ ŸÅÿπŸÑ€å ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ⁄ØÿßÿØ ÿ±Ÿà ÿπŸàÿ∂ ⁄©ŸÜŸÜ.")
        return

    if not update.message.reply_to_message:
        await update.message.reply_text("‚ùå ŸÑÿ∑ŸÅÿßŸã ÿ±Ÿà€å Ÿæ€åÿßŸÖ ⁄©ÿ≥€å ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ Ÿà ÿ®ÿπÿØ /god ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.")
        return

    target = update.message.reply_to_message.from_user
    if g.god_id == target.id:
        await update.message.reply_text("‚ÑπÔ∏è ŸáŸÖ€åŸÜ ÿ≠ÿßŸÑÿß ŸáŸÖ ⁄ØÿßÿØ Ÿáÿ≥ÿ™.")
        return
    # ŸÜÿßŸÖ ÿ™ÿ±ÿ¨€åÿ≠€å: ÿßÿ≤ gist ÿß⁄Øÿ± ŸÖŸàÿ¨ŸàÿØÿå Ÿà⁄Øÿ±ŸÜŸá ŸÜÿßŸÖ ÿ™ŸÑ⁄Øÿ±ÿßŸÖ
    new_name = g.user_names.get(target.id, target.full_name)

    g.god_id = target.id
    g.god_name = new_name
    store.save()

    await update.message.reply_text(f"‚úÖ ÿ≠ÿßŸÑÿß ⁄ØÿßÿØ ÿ¨ÿØ€åÿØ ÿ®ÿßÿ≤€åŸá {new_name}.")

    mode = CTRL if g.phase != "idle" else REG
    await publish_seating(ctx, chat, g, mode=mode)

    if g.phase != "idle":
        log = []
        for seat in sorted(g.assigned_roles):
            role = g.assigned_roles.get(seat, "‚Äî")
            name = g.seats[seat][1]
            log.append(f"{name} ‚á¶ {role}")
        try:
            await ctx.bot.send_message(
                target.id,
                "üëë ÿ¥ŸÖÿß ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ⁄ØÿßÿØ ÿ¨ÿØ€åÿØ ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØ€åÿØ.\n\nüßæ ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß:\n" + "\n".join(log)
            )
        except telegram.error.Forbidden:
            await update.message.reply_text("‚ö†Ô∏è ŸÜÿ™ŸàŸÜÿ≥ÿ™ŸÖ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ±Ÿà ÿ®Ÿá Ÿæ€åŸà€å ⁄ØÿßÿØ ÿ¨ÿØ€åÿØ ÿ®ŸÅÿ±ÿ≥ÿ™ŸÖ.")



async def handle_direct_name_input(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if not msg or not msg.text:
        return

    chat_id = msg.chat.id
    uid = msg.from_user.id
    g = gs(chat_id)
    text = msg.text.strip()

    if g.vote_type == "awaiting_time" and uid == g.god_id:
        g.event_time = text
        g.vote_type = None
        store.save()
        await publish_seating(ctx, chat_id, g)
        await ctx.bot.send_message(chat_id, f"‚úÖ ÿ≥ÿßÿπÿ™ ÿ±Ÿà€åÿØÿßÿØ ÿ±Ÿà€å {text} ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ.")
        return


    # ÿ´ÿ®ÿ™ ŸÜÿßŸÖ ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å
    if uid in g.awaiting_name_input:
        seat_no = g.awaiting_name_input.pop(uid)

        import re
        if not re.match(r'^[\u0600-\u06FF\s]+$', text):
            await ctx.bot.send_message(chat_id, "‚ùó ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿ±ÿß ŸÅŸÇÿ∑ ÿ®ÿß ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
            return

        g.seats[seat_no] = (uid, text)
        g.user_names[uid] = text
        save_usernames_to_gist(g.user_names)
        store.save()

        if uid in g.last_name_prompt_msg_id:
            try:
                await ctx.bot.delete_message(
                    chat_id=chat_id,
                    message_id=g.last_name_prompt_msg_id[uid]
                )
            except:
                pass
            del g.last_name_prompt_msg_id[uid]

        await publish_seating(ctx, chat_id, g)
        return

    if getattr(g, "vote_collecting", False) and g.current_vote_target:
        start, end, target = g.vote_window
        now = datetime.now().timestamp()
        voter_seat = next((s for s,(u,_) in g.seats.items() if u == uid), None)

        if voter_seat and voter_seat != target and start <= now <= end:
            # ÿ´ÿ®ÿ™ ÿ±ÿ£€å €å⁄©ÿ™ÿß
            g.votes_cast.setdefault(target, set())
            g.votes_cast[target].add(uid)

            # üïí ÿ∞ÿÆ€åÿ±Ÿá ŸÑÿß⁄Ø ÿ±ÿ£€å‚ÄåŸáÿß ÿ®ÿß ÿ≤ŸÖÿßŸÜ ŸÜÿ≥ÿ®€å
            if not hasattr(g, "vote_logs"):
                g.vote_logs = {}
            g.vote_logs.setdefault(target, [])
            rel_time = now - start  # ÿ≤ŸÖÿßŸÜ ÿßÿ≤ ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤Ÿá
            g.vote_logs[target].append((uid, rel_time))
            if not hasattr(g, "vote_cleanup_ids"):
                g.vote_cleanup_ids = []
            g.vote_cleanup_ids.append(msg.message_id)


    # -------------- defense seats by God ------------------
    if g.vote_type == "awaiting_defense" and uid == g.god_id:
        nums = [int(n) for n in text.split() if n.isdigit() and int(n) in g.seats]

        # ÿß⁄Øÿ± Ÿàÿ±ŸàÿØ€å ŸÖÿπÿ™ÿ®ÿ± ŸÜÿ®ŸàÿØÿå Ÿæ€åÿßŸÖ ÿÆÿ∑ÿß ÿ®ÿØŸá Ÿà ÿ®ÿ±⁄Øÿ±ÿØ
        if not nums:
            await ctx.bot.send_message(chat_id, "‚ùå ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å ŸÖÿπÿ™ÿ®ÿ± Ÿàÿßÿ±ÿØ ŸÜÿ¥ÿØ. ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ (ŸÖÿ´ÿßŸÑ: 1 3 5).")
            return

        g.defense_seats = nums
        g.vote_type = None  # ‚úÖ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿ≠ÿßŸÑÿ™ Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØŸÜ ÿµŸÜÿØŸÑ€å ÿØŸÅÿßÿπ

        # üßπ ÿ≠ÿ∞ŸÅ Ÿæ€åÿßŸÖ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ
        if g.defense_prompt_msg_id:
            try:
                await ctx.bot.delete_message(chat_id=chat_id, message_id=g.defense_prompt_msg_id)
            except:
                pass
            g.defense_prompt_msg_id = None

        store.save()
        await ctx.bot.send_message(chat_id, f"‚úÖ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ: {', '.join(map(str, nums))}")
        await start_vote(ctx, chat_id, g, "final")
        return

    if g.phase == "idle" and text.strip() == "⁄©ŸÜÿ≥ŸÑ":
        for seat, (player_uid, _) in list(g.seats.items()):
            if player_uid == uid:
                del g.seats[seat]
                store.save()
                await ctx.bot.send_message(chat_id, "‚ùé ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÑÿ∫Ÿà ÿ¥ÿØ.")
                await publish_seating(ctx, chat_id, g)
                break
        else:
            await ctx.bot.send_message(chat_id, "‚ùó ÿ¥ŸÖÿß ÿØÿ± ŸÑ€åÿ≥ÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.")
        return

    if hasattr(g, "adding_scenario_step") and g.adding_scenario_step:

        if uid != g.god_id:
            return


        if (datetime.now() - g.adding_scenario_last).total_seconds() > 300:
            g.adding_scenario_step = None
            g.adding_scenario_data = {}
            store.save()
            await ctx.bot.send_message(chat_id, "‚è± ÿ≤ŸÖÿßŸÜ ÿ¥ŸÖÿß ÿ™ŸÖÿßŸÖ ÿ¥ÿØ. ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿ≥ŸÜÿßÿ±€åŸà ŸÑÿ∫Ÿà ÿ¥ÿØ.")
            return

        text = msg.text.strip()

        # ŸÖÿ±ÿ≠ŸÑŸá €±: ŸÜÿßŸÖ ÿ≥ŸÜÿßÿ±€åŸà
        if g.adding_scenario_step == "name":
            g.adding_scenario_data["name"] = text
            g.adding_scenario_step = "mafia"
            g.adding_scenario_last = datetime.now()
            store.save()
            await ctx.bot.send_message(chat_id, " ‚ô†Ô∏è ÿ¢€åÿß ŸÜŸÇÿ¥ ŸÖÿßŸÅ€åÿß ÿØÿßÿ±ÿØÿü ÿß⁄Øÿ± ÿ®ŸÑŸáÿå ŸÑ€åÿ≥ÿ™ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ (ŸÜŸÇÿ¥ Ÿáÿß ÿ±ÿß ÿ®ÿß / ÿßÿ≤ ŸáŸÖ ÿ¨ÿØÿß ⁄©ŸÜ€åÿØ). ÿß⁄Øÿ± ŸÜŸáÿå ¬´ÿÆ€åÿ±¬ª.")
            return

        # ŸÖÿ±ÿ≠ŸÑŸá €≤: ŸÜŸÇÿ¥ ŸÖÿßŸÅ€åÿß
        if g.adding_scenario_step == "mafia":
            if text != "ÿÆ€åÿ±":
                g.adding_scenario_data["mafia"] = [r.strip() for r in text.split("/") if r.strip()]
            else:
                g.adding_scenario_data["mafia"] = []
            g.adding_scenario_step = "citizen"
            g.adding_scenario_last = datetime.now()
            store.save()
            await ctx.bot.send_message(chat_id, "‚ô•Ô∏è ÿ¢€åÿß ŸÜŸÇÿ¥ ÿ¥Ÿáÿ±ŸàŸÜÿØ ÿØÿßÿ±ÿØÿü ÿß⁄Øÿ± ÿ®ŸÑŸáÿå ŸÑ€åÿ≥ÿ™ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ (ŸÜŸÇÿ¥ Ÿáÿß ÿ±ÿß ÿ®ÿß / ÿßÿ≤ ŸáŸÖ ÿ¨ÿØÿß ⁄©ŸÜ€åÿØ). ÿß⁄Øÿ± ŸÜŸáÿå ¬´ÿÆ€åÿ±¬ª.")
            return

        # ŸÖÿ±ÿ≠ŸÑŸá €≥: ŸÜŸÇÿ¥ ÿ¥Ÿáÿ±ŸàŸÜÿØ
        if g.adding_scenario_step == "citizen":
            if text != "ÿÆ€åÿ±":
                g.adding_scenario_data["citizen"] = [r.strip() for r in text.split("/") if r.strip()]
            else:
                g.adding_scenario_data["citizen"] = []
            g.adding_scenario_step = "indep"
            g.adding_scenario_last = datetime.now()
            store.save()
            await ctx.bot.send_message(chat_id, "‚ô¶Ô∏è ÿ¢€åÿß ŸÜŸÇÿ¥ ŸÖÿ≥ÿ™ŸÇŸÑ ÿØÿßÿ±ÿØÿü ÿß⁄Øÿ± ÿ®ŸÑŸáÿå ŸÑ€åÿ≥ÿ™ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ. ÿß⁄Øÿ± ŸÜŸáÿå ¬´ÿÆ€åÿ±¬ª.")
            return

        # ŸÖÿ±ÿ≠ŸÑŸá €¥: ŸÜŸÇÿ¥ ŸÖÿ≥ÿ™ŸÇŸÑ
        if g.adding_scenario_step == "indep":
            if text != "ÿÆ€åÿ±":
                g.adding_scenario_data["indep"] = [r.strip() for r in text.split("/") if r.strip()]
            else:
                g.adding_scenario_data["indep"] = []
            g.adding_scenario_step = "cards"
            g.adding_scenario_last = datetime.now()
            store.save()
            await ctx.bot.send_message(chat_id, "‚ô•Ô∏è ÿ¢€åÿß ⁄©ÿßÿ±ÿ™ ÿØÿßÿ±ÿØÿü ÿß⁄Øÿ± ÿ®ŸÑŸáÿå ŸÑ€åÿ≥ÿ™ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ (ŸÜŸÇÿ¥ Ÿáÿß ÿ±ÿß ÿ®ÿß / ÿßÿ≤ ŸáŸÖ ÿ¨ÿØÿß ⁄©ŸÜ€åÿØ). ÿß⁄Øÿ± ŸÜŸáÿå ¬´ÿÆ€åÿ±¬ª.")
            return

        # ŸÖÿ±ÿ≠ŸÑŸá €µ: ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß
        if g.adding_scenario_step == "cards":
            if text != "ÿÆ€åÿ±":
                g.adding_scenario_data["cards"] = [r.strip() for r in text.split("/") if r.strip()]
            else:
                g.adding_scenario_data["cards"] = []

            # ‚úÖ ÿ∞ÿÆ€åÿ±Ÿá ÿØÿ± Gist
            name = g.adding_scenario_data["name"]
            mafia_roles   = g.adding_scenario_data["mafia"]
            citizen_roles = g.adding_scenario_data["citizen"]
            indep_roles   = g.adding_scenario_data["indep"]
            cards         = g.adding_scenario_data["cards"]

            # --- ŸÖÿßŸÅ€åÿß ---
            mafia_set = load_mafia_roles() or set()
            mafia_set |= set(mafia_roles)
            save_mafia_roles(mafia_set)

            # --- ŸÖÿ≥ÿ™ŸÇŸÑ ---
            indep_map = load_indep_roles() or {}
            cur_indep = set(indep_map.get(name, []))
            cur_indep |= set(indep_roles)
            if cur_indep:
                indep_map[name] = sorted(cur_indep)
            save_indep_roles(indep_map)

            # --- ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß ---
            cards_map = load_cards() or {}
            cur_cards = set(cards_map.get(name, []))
            cur_cards |= set(cards)
            if cur_cards:
                cards_map[name] = sorted(cur_cards)
            save_cards(cards_map)

            # --- ÿ≥ŸÜÿßÿ±€åŸà ---
            def list_to_counts(role_list):
                counts = {}
                for r in role_list:
                    counts[r] = counts.get(r, 0) + 1
                return counts

            mafia_counts   = list_to_counts(mafia_roles)
            citizen_counts = list_to_counts(citizen_roles)
            indep_counts   = list_to_counts(indep_roles)

            roles = {}
            roles.update(mafia_counts)
            roles.update(citizen_counts)
            roles.update(indep_counts)

            new_scenario = Scenario(name, roles)
            store.scenarios.append(new_scenario)
            store.save()
            save_scenarios_to_gist(store.scenarios)

            # Ÿæÿß⁄©ÿ≥ÿßÿ≤€å Ÿàÿ∂ÿπ€åÿ™
            g.adding_scenario_step = None
            g.adding_scenario_data = {}
            store.save()

            await ctx.bot.send_message(chat_id, f"‚úÖ ÿ≥ŸÜÿßÿ±€åŸà€å ¬´{name}¬ª ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ.")
            return





async def handle_stats_request(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    now = datetime.now(timezone.utc).timestamp()
    day_ago = now - 86400  # 24 ÿ≥ÿßÿπÿ™ ⁄Øÿ∞ÿ¥ÿ™Ÿá

    msg_lines = []
    running_groups = []
    recruiting_groups = []

    for gid, g in store.games.items():
        g: GameState
        stats = store.group_stats.get(gid, {})
        started = sum(1 for t in stats.get("started", []) if t > day_ago)
        ended = sum(1 for t in stats.get("ended", []) if t > day_ago)

        try:
            chat = await ctx.bot.get_chat(gid)
            if chat.username:
                name = f"<a href='https://t.me/{chat.username}'>{chat.title or chat.username}</a> (<code>{gid}</code>)"
                is_private = False
            else:
                name = f"{chat.title or '⁄Øÿ±ŸàŸá ÿÆÿµŸàÿµ€å'}  <code>{gid}</code>"
                is_private = True
        except:
            name = f"(⁄Øÿ±ŸàŸá ŸÜÿßÿ¥ŸÜÿßÿ≥) <code>{gid}</code>"
            is_private = True


        # Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπŸÑ€å
        if g.phase == "playing":
            running_groups.append(name)
        elif (
            g.scenario and
            g.god_id and
            len(g.seats) < g.max_seats and
            g.phase != "playing"
        ):
            recruiting_groups.append(name)

        msg_lines.append(f"üë• {name}:\n‚è∫ {started} ÿ¥ÿ±Ÿàÿπ\n‚èπ {ended} Ÿæÿß€åÿßŸÜ\n")

    final_msg = "\n".join(msg_lines)
    final_msg += "\n\nüéÆ <b>⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å€å ⁄©Ÿá ÿ®ÿßÿ≤€å ŸÅÿπÿßŸÑ ÿØÿßÿ±ŸÜ:</b>\n" + ", ".join(running_groups or ["‚Äî"])
    final_msg += "\n\nü™ë <b>⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å€å ⁄©Ÿá ÿØÿ± ÿ≠ÿßŸÑ ÿπÿ∂Ÿà⁄Ø€åÿ±€å Ÿáÿ≥ÿ™ŸÜ:</b>\n" + ", ".join(recruiting_groups or ["‚Äî"])

    await ctx.bot.send_message(
        update.effective_chat.id,
        final_msg,
        parse_mode="HTML",
        disable_web_page_preview=True
    )

async def leave_group(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != 99347107:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ŸÖÿØ€åÿ± ÿßÿµŸÑ€å ÿ®ÿßÿ™ ÿßÿ¨ÿßÿ≤Ÿá ÿØÿßÿ±ÿØ ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ÿ±ÿß ÿßÿ¨ÿ±ÿß ⁄©ŸÜÿØ.")
        return

    if not ctx.args:
        await update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã Chat ID ⁄Øÿ±ŸàŸá ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return

    try:
        chat_id = int(ctx.args[0])
        await ctx.bot.leave_chat(chat_id)
        await update.message.reply_text(f"‚úÖ ÿ®ÿßÿ™ ÿßÿ≤ ⁄Øÿ±ŸàŸá {chat_id} ÿÆÿßÿ±ÿ¨ ÿ¥ÿØ.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ⁄Øÿ±ŸàŸá: {e}")

OWNER_IDS = {99347107, 449916967, 7501892705,5904091398}


async def activate_group(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    user_id = update.effective_user.id
    if user_id not in OWNER_IDS:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ÿßÿµŸÑ€å ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ⁄Øÿ±ŸàŸá ÿ±Ÿà ŸÅÿπÿßŸÑ ⁄©ŸÜŸÜ.")
        return

    store.active_groups.add(chat.id)
    store.save()
    ok = save_active_groups(store.active_groups)
    if not ok:
        await update.message.reply_text("‚ö†Ô∏è ⁄Øÿ±ŸàŸá ŸÅÿπÿßŸÑ ÿ¥ÿØÿå ÿßŸÖÿß ÿ∞ÿÆ€åÿ±Ÿá ÿØÿ± Gist ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.")
        return

    await update.message.reply_text("‚úÖ ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÅÿπÿßŸÑ ÿ¥ÿØ.")


async def deactivate_group(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    user_id = update.effective_user.id
    if user_id not in OWNER_IDS:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ÿßÿµŸÑ€å ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ⁄Øÿ±ŸàŸá ÿ±Ÿà ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ŸÜŸÜ.")
        return

    if chat.id in store.active_groups:
        store.active_groups.remove(chat.id)
        store.save()
        ok = save_active_groups(store.active_groups)
        if not ok:
            await update.message.reply_text("‚ö†Ô∏è ⁄Øÿ±ŸàŸá ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ŸÖÿ≠ŸÑ€å ÿ≠ÿ∞ŸÅ ÿ¥ÿØÿå ŸàŸÑ€å ÿ∞ÿÆ€åÿ±Ÿá ÿØÿ± Gist ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.")
            return
        await update.message.reply_text("üõë ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿ¥ÿØ Ÿà ÿßÿ≤ Gist ŸáŸÖ Ÿæÿß⁄© ÿ¥ÿØ.")
    else:
        await update.message.reply_text("‚ÑπÔ∏è ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿßÿ≤ ŸÇÿ®ŸÑ ŸÅÿπÿßŸÑ ŸÜÿ®ŸàÿØ.")


async def set_event_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat_id_int = update.effective_chat.id
    chat_id = str(chat_id_int)
    g = gs(chat_id_int)

    if update.effective_user.id != g.god_id:
        await update.message.reply_text("‚ùå ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ¥ŸÖÿßÿ±Ÿá ÿß€åŸàŸÜÿ™ ÿ±ÿß ÿ™ÿ∫€å€åÿ± ÿØŸáÿØ.")
        return

    if not ctx.args or not ctx.args[0].isdigit():
        await update.message.reply_text("‚ö†Ô∏è ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿµÿ≠€åÿ≠: /setevent <ÿ¥ŸÖÿßÿ±Ÿá>")
        return

    num = int(ctx.args[0])

    # ‚úÖ ÿ®Ÿá ÿ¨ÿß€å load/save ÿÆÿßŸÖÿå ÿßÿ≤ ⁄©ÿ¥ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ Ÿà ŸáŸÖŸàŸÜ ÿ±Ÿà ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ⁄©ŸÜ
    nums = get_event_numbers()             # ‚Üê ÿßÿ≤ ⁄©ÿ¥ ŸÖ€å‚ÄåÿÆŸàÿßŸÜ€åŸÖ
    nums[chat_id] = num                    # ‚Üê ⁄©ÿ¥ ÿ±ÿß ÿ®ŸÑÿßŸÅÿßÿµŸÑŸá ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    save_event_numbers(nums)               # ‚Üê ÿ≥Ÿæÿ≥ €å⁄© PATCH ÿ®Ÿá Gist

    # ÿ≠ÿßŸÑÿß ŸÑ€åÿ≥ÿ™ ÿ±ÿß ÿßÿØ€åÿ™ ⁄©ŸÜÿõ ⁄ÜŸàŸÜ ⁄©ÿ¥ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ¥ÿØŸáÿå ŸÖÿ™ŸÜ ÿ¨ÿØ€åÿØ ŸÖ€å‚Äåÿ¥ŸàÿØ
    try:
        mode = CTRL if g.phase != "idle" else REG
        await publish_seating(ctx, chat_id_int, g, mode=mode)
    except Exception:
        pass

    await update.message.reply_text(f"‚úÖ ÿ¥ŸÖÿßÿ±Ÿá ÿß€åŸàŸÜÿ™ ÿ®ÿ±ÿß€å ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿ±Ÿà€å {num} ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ.")


MY_ID = 99347107 

async def add_sticker_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    # ŸÅŸÇÿ∑ ÿ¢€åÿØ€å ÿ™Ÿà
    if update.effective_user.id != MY_ID:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ ÿßÿµŸÑ€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿßÿ≥ÿ™€å⁄©ÿ± ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜÿØ.")
        return

    # ⁄Ü⁄© ⁄©ŸÜ ÿ±Ÿà€å ÿßÿ≥ÿ™€å⁄©ÿ± ÿ±€åŸæŸÑÿß€å ÿ¥ÿØŸá €åÿß ŸÜŸá
    if not update.message.reply_to_message or not update.message.reply_to_message.sticker:
        await update.message.reply_text("‚ö†Ô∏è ÿ®ÿß€åÿØ ÿ±Ÿà€å Ÿæ€åÿßŸÖ ÿßÿ≥ÿ™€å⁄©ÿ± ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ.")
        return

    if not ctx.args:
        await update.message.reply_text("‚ö†Ô∏è ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿµÿ≠€åÿ≠: /addsticker <ŸÜÿßŸÖ ŸÜŸÇÿ¥>")
        return

    role_name = " ".join(ctx.args).strip()
    file_id = update.message.reply_to_message.sticker.file_id

    stickers = load_stickers()
    stickers[role_name] = file_id
    save_stickers(stickers)

    await update.message.reply_text(f"‚úÖ ÿßÿ≥ÿ™€å⁄©ÿ± ÿ®ÿ±ÿß€å ŸÜŸÇÿ¥ ¬´{role_name}¬ª ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ.")

async def on_error(update: object, context: ContextTypes.DEFAULT_TYPE):
    err = context.error
    # BadRequest Ÿáÿß€å ÿ®€å‚ÄåÿßŸáŸÖ€åÿ™ ÿ±Ÿà ŸÜÿßÿØ€åÿØŸá ÿ®⁄Ø€åÿ±
    if isinstance(err, BadRequest) and ("Query is too old" in str(err) or "query id is invalid" in str(err)):
        return
    try:
        chat_id = update.effective_chat.id if update and hasattr(update, "effective_chat") else None
        print(f"[ERROR] chat={chat_id} err={err}")
    except Exception:
        pass

async def cmd_addmafia(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ⁄Ü⁄© ÿßÿØŸÖ€åŸÜ ÿ®ŸàÿØŸÜ
    try:
        member = await ctx.bot.get_chat_member(chat.id, update.effective_user.id)
        if member.status not in ("administrator", "creator"):
            await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÜÿØ ŸÜŸÇÿ¥ ŸÖÿßŸÅ€åÿß€å€å ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜŸÜÿØ.")
            return
    except Exception:
        await update.message.reply_text("‚õî ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿ±ÿ±ÿ≥€å ÿßÿØŸÖ€åŸÜ ÿ®ŸàÿØŸÜ.")
        return

    role = " ".join(ctx.args).strip() if ctx.args else ""
    if not role:
        await update.message.reply_text("ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™: /addmafia ŸÜÿßŸÖ_ŸÜŸÇÿ¥\nŸÖÿ´ÿßŸÑ: /addmafia ⁄ØÿßÿØŸÅÿßÿØÿ±")
        return

    roles = load_mafia_roles()
    if role in roles:
        await update.message.reply_text(f"‚ÑπÔ∏è ¬´{role}¬ª ÿßÿ≤ ŸÇÿ®ŸÑ ÿØÿ± ŸÑ€åÿ≥ÿ™ ŸÖÿßŸÅ€åÿß Ÿáÿ≥ÿ™.")
        return

    roles.add(role)
    ok = save_mafia_roles(roles)
    if ok:
        await update.message.reply_text(f"‚úÖ ŸÜŸÇÿ¥ ¬´{role}¬ª ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ŸÖÿßŸÅ€åÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.")
    else:
        await update.message.reply_text("‚ùå ÿ∞ÿÆ€åÿ±Ÿá‚Äåÿ≥ÿßÿ≤€å ÿØÿ± Gist ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.")


async def cmd_listmafia(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ÿß€åŸÜ €å⁄©€å ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿßÿØŸÖ€åŸÜ‚Äåÿ®ŸàÿØŸÜ ŸÜÿØÿßÿ±Ÿá ‚Üí ŸáŸÖŸá ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿ®ÿ®€åŸÜŸÜ
    roles = sorted(list(load_mafia_roles()))
    if not roles:
        await update.message.reply_text("ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß€å ŸÖÿßŸÅ€åÿß€å€å ÿÆÿßŸÑ€å ÿßÿ≥ÿ™.")
        return

    txt = "üï∂ ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß€å ŸÖÿßŸÅ€åÿß€å€å ÿ´ÿ®ÿ™‚Äåÿ¥ÿØŸá:\n" + "\n".join(f"‚Ä¢ {r}" for r in roles)
    await update.message.reply_text(txt)




async def add_card(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    user_id = update.effective_user.id

    # ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("‚õî ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß
    member = await ctx.bot.get_chat_member(chat.id, user_id)
    if member.status not in ("administrator", "creator"):
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÜÿØ ⁄©ÿßÿ±ÿ™ ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜŸÜÿØ.")
        return

    if len(ctx.args) < 2:
        await update.message.reply_text("‚ùó ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™: /addcard <ÿ≥ŸÜÿßÿ±€åŸà> <ŸÖÿ™ŸÜ ⁄©ÿßÿ±ÿ™>")
        return

    scn = ctx.args[0]
    card_text = " ".join(ctx.args[1:])

    cards = load_cards()
    cards.setdefault(scn, [])
    if card_text in cards[scn]:
        await update.message.reply_text("‚ö†Ô∏è ÿß€åŸÜ ⁄©ÿßÿ±ÿ™ ŸÇÿ®ŸÑÿßŸã ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™.")
        return

    cards[scn].append(card_text)
    save_cards(cards)
    await update.message.reply_text(f"‚úÖ ⁄©ÿßÿ±ÿ™ ¬´{card_text}¬ª ÿ®Ÿá ÿ≥ŸÜÿßÿ±€åŸà {scn} ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.")


async def list_cards(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    user_id = update.effective_user.id

    # ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("‚õî ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß
    member = await ctx.bot.get_chat_member(chat.id, user_id)
    if member.status not in ("administrator", "creator"):
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÜÿØ ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß ÿ±ÿß ÿ®ÿ®€åŸÜŸÜÿØ.")
        return

    if not ctx.args:
        await update.message.reply_text("‚ùó ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™: /listcards <ÿ≥ŸÜÿßÿ±€åŸà>")
        return

    scn = ctx.args[0]
    cards = load_cards().get(scn, [])

    if not cards:
        await update.message.reply_text(f"‚ùå ÿ®ÿ±ÿß€å ÿ≥ŸÜÿßÿ±€åŸà {scn} ⁄©ÿßÿ±ÿ™€å ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá.")
        return

    msg = f"üÉè ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß€å ÿ≥ŸÜÿßÿ±€åŸà {scn}:\n" + "\n".join([f"- {c}" for c in cards])
    await update.message.reply_text(msg)


async def add_indep_role(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    uid = update.effective_user.id

    # ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá
    if chat.type not in ("group", "supergroup"):
        await update.message.reply_text("‚ùó ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return
    member = await ctx.bot.get_chat_member(chat.id, uid)
    if member.status not in ("administrator", "creator"):
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÜÿØ ŸÜŸÇÿ¥ ŸÖÿ≥ÿ™ŸÇŸÑ ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜŸÜÿØ.")
        return

    if len(ctx.args) < 2:
        await update.message.reply_text("‚ùó ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™: /addindep <ÿ≥ŸÜÿßÿ±€åŸà> <ŸÜŸÇÿ¥>")
        return

    scn = ctx.args[0]
    role = " ".join(ctx.args[1:])

    indep = load_indep_roles()
    indep.setdefault(scn, [])
    if role in indep[scn]:
        await update.message.reply_text("‚ö†Ô∏è ÿß€åŸÜ ŸÜŸÇÿ¥ ŸÇÿ®ŸÑÿßŸã ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™.")
        return

    indep[scn].append(role)
    save_indep_roles(indep)
    await update.message.reply_text(f"‚úÖ ŸÜŸÇÿ¥ ŸÖÿ≥ÿ™ŸÇŸÑ ¬´{role}¬ª ÿ®Ÿá ÿ≥ŸÜÿßÿ±€åŸà {scn} ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.")


async def list_indep_roles(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not ctx.args:
        await update.message.reply_text("‚ùó ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™: /listindep <ÿ≥ŸÜÿßÿ±€åŸà>")
        return

    scn = ctx.args[0]
    roles = load_indep_roles().get(scn, [])

    if not roles:
        await update.message.reply_text(f"‚ùå ÿ®ÿ±ÿß€å ÿ≥ŸÜÿßÿ±€åŸà {scn} ŸÜŸÇÿ¥ ŸÖÿ≥ÿ™ŸÇŸÑ€å ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá.")
        return

    msg = f"‚ô¶Ô∏è ŸÜŸÇÿ¥‚ÄåŸáÿß€å ŸÖÿ≥ÿ™ŸÇŸÑ ÿ≥ŸÜÿßÿ±€åŸà {scn}:\n" + "\n".join([f"- {r}" for r in roles])
    await update.message.reply_text(msg)

async def sub_command(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    g = gs(chat_id)


    if update.effective_user.id != g.god_id:
        await update.message.reply_text("‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ¨ÿß€å⁄Øÿ≤€åŸÜ ⁄©ŸÜÿØ.")
        return


    if not update.message.reply_to_message or not update.message.reply_to_message.from_user:
        await update.message.reply_text("‚ö†Ô∏è ŸÑÿ∑ŸÅÿßŸã ÿ±Ÿà€å Ÿæ€åÿßŸÖ ÿ®ÿßÿ≤€å⁄©ŸÜ ÿ¨ÿØ€åÿØ ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ.")
        return

    new_uid = update.message.reply_to_message.from_user.id
    new_name = g.user_names.get(new_uid, "ŸÜÿßÿ¥ŸÜÿßÿ≥")


    parts = update.message.text.strip().split()
    if len(parts) < 2 or not parts[1].isdigit():
        await update.message.reply_text("‚ö†Ô∏è ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™: /sub <ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å>")
        return

    seat_no = int(parts[1])
    if seat_no not in g.seats:
        await update.message.reply_text(f"‚ö†Ô∏è ÿµŸÜÿØŸÑ€å {seat_no} Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        return


    role = g.assigned_roles.get(seat_no)

    g.seats[seat_no] = (new_uid, new_name)
    store.save()
    await publish_seating(ctx, chat_id, g, mode=CTRL)


    stickers = load_stickers()
    if role in stickers:
        try:
            await ctx.bot.send_sticker(new_uid, stickers[role])
        except:
            pass
    try:
        await ctx.bot.send_message(new_uid, f"üé≠ ŸÜŸÇÿ¥ ÿ¥ŸÖÿß: {role}")
    except telegram.error.Forbidden:
        await update.message.reply_text("‚ö†Ô∏è ŸÜÿ™ŸàŸÜÿ≥ÿ™ŸÖ ŸÜŸÇÿ¥ ÿ±Ÿà ÿ®Ÿá Ÿæ€åŸà€å ÿ®ŸÅÿ±ÿ≥ÿ™ŸÖ (Ÿæ€å‚ÄåŸà€å ÿ®ÿ≥ÿ™Ÿá ÿßÿ≥ÿ™).")


    if new_name == "ŸÜÿßÿ¥ŸÜÿßÿ≥":
        g.waiting_name[new_uid] = seat_no
        store.save()
        await ctx.bot.send_message(
            chat_id,
            f"‚úèÔ∏è ÿß€åŸÜ Ÿæ€åÿßŸÖ ÿ±ÿß ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ Ÿà ŸÜÿßŸÖ ÿ¨ÿØ€åÿØ ÿÆŸàÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å {seat_no} ÿ®Ÿá ŸÅÿßÿ±ÿ≥€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:"
        )

    await update.message.reply_text(f"‚úÖ ÿ®ÿßÿ≤€å⁄©ŸÜ ÿ¨ÿØ€åÿØ ÿ¨ÿß€å⁄Øÿ≤€åŸÜ ÿµŸÜÿØŸÑ€å {seat_no} ÿ¥ÿØ.")

async def cmd_lists(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    uid = update.effective_user.id
    g = gs(chat.id)

    # ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ÿßÿ¨ÿßÿ≤Ÿá ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ŸÜ
    try:
        member = await ctx.bot.get_chat_member(chat.id, uid)
        if member.status not in ("administrator", "creator"):
            await ctx.bot.send_message(chat.id, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÜÿØ ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ÿ±ÿß ÿ®ÿ≤ŸÜŸÜÿØ.")
            return
    except Exception:
        pass

    if not hasattr(g, "last_snapshot"):
        await ctx.bot.send_message(chat.id, "‚ùå ŸÑ€åÿ≥ÿ™ ŸÇÿ®ŸÑ€å ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™.")
        return

    try:
        kb = InlineKeyboardMarkup.de_json(g.last_snapshot["kb"], ctx.bot)
    except Exception:
        kb = None

    # üìú ÿßÿ±ÿ≥ÿßŸÑ ŸÑ€åÿ≥ÿ™ ÿ®ÿßÿ≤€åÿßÿ®€å‚Äåÿ¥ÿØŸá
    msg = await ctx.bot.send_message(
        chat.id,
        g.last_snapshot["text"],
        parse_mode="HTML",
        reply_markup=kb
    )

    # ‚úÖ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¢€åÿØ€å Ÿæ€åÿßŸÖ ŸÅÿπÿßŸÑ
    g.last_seating_msg_id = msg.message_id
    store.save()

    # üìå Ÿæ€åŸÜ ⁄©ÿ±ÿØŸÜ Ÿæ€åÿßŸÖ (ÿßÿÆÿ™€åÿßÿ±€å ŸàŸÑ€å Ÿæ€åÿ¥ŸÜŸáÿßÿØ ŸÖ€å‚Äåÿ¥ŸàÿØ)
    try:
        await ctx.bot.pin_chat_message(
            chat_id=chat.id,
            message_id=msg.message_id,
            disable_notification=True
        )
    except Exception as e:
        print(f"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± Ÿæ€åŸÜ ⁄©ÿ±ÿØŸÜ ŸÑ€åÿ≥ÿ™ ÿ®ÿßÿ≤€åÿßÿ®€å‚Äåÿ¥ÿØŸá: {e}")



async def main():
    app = ApplicationBuilder().token(TOKEN).build()
    app.add_error_handler(on_error)
    app.add_handler(CommandHandler("active", activate_group))
    app.add_handler(CommandHandler("deactivate", deactivate_group))
    # üëâ ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ŸáŸÜÿØŸÑÿ±Ÿáÿß
    app.add_handler(CommandHandler("newgame", newgame, filters=group_filter))
    app.add_handler(CommandHandler("leave", leave_group, filters=filters.ChatType.PRIVATE & filters.User(99347107)))

    # ü™ë ÿßŸÜÿ™ÿÆÿßÿ® ÿµŸÜÿØŸÑ€å ÿ®ÿß ÿØÿ≥ÿ™Ÿàÿ± ŸÖÿ´ŸÑ /3
    app.add_handler(
        MessageHandler(
            filters.Regex(r"^/\d+(@PouriaMafiaBot)?$") & filters.ChatType.GROUPS,
            handle_simple_seat_command
        )
    )
    app.add_handler(CommandHandler("resetgame", resetgame_cmd, filters=group_filter))
    app.add_handler(CommandHandler("addcdtmafia", cmd_listmafia, filters=group_filter))
    app.add_handler(CommandHandler("list", cmd_lists, filters=group_filter))
    app.add_handler(CommandHandler("addcard", add_card))
    app.add_handler(CommandHandler("listcard", list_cards))
    app.add_handler(CommandHandler("addindep", add_indep_role))
    app.add_handler(CommandHandler("listindep", list_indep_roles))
    app.add_handler(CommandHandler("add", add_seat_cmd, filters=group_filter))
    app.add_handler(CommandHandler("god", transfer_god_cmd, filters=group_filter))
    app.add_handler(CommandHandler("sub", sub_command, filters=group_filter))
    app.add_handler(CommandHandler("setevent", set_event_cmd, filters=group_filter))
    app.add_handler(CommandHandler("addsticker", add_sticker_cmd, filters=filters.ChatType.PRIVATE))
    # ‚è± ÿ™ÿß€åŸÖÿ± ŸæŸà€åÿß ŸÖÿ´ŸÑ /3s
    app.add_handler(
        MessageHandler(
            filters.COMMAND & filters.Regex(r"^/\d+s$"),
            dynamic_timer
        )
    )

    # üë• ŸáŸÜÿØŸÑÿ± ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß€å ŸÖÿ™ŸÜ€å (ÿßŸàŸÑ name_reply ÿ®ÿßÿ¥Ÿá)
    app.add_handler(
        MessageHandler(
            group_filter & filters.REPLY & filters.TEXT,
            name_reply
        )
    )

    # üßë‚Äçüíª ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß€å ŸÖÿ≥ÿ™ŸÇ€åŸÖ ÿ®ÿØŸàŸÜ ÿ±€åŸæŸÑÿß€å
    app.add_handler(
        MessageHandler(
            group_filter & filters.TEXT & ~filters.REPLY,
            handle_direct_name_input
        )
    )

    # üéÆ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß Ÿà ÿ±ÿß€å‚Äå⁄Ø€åÿ±€å
    app.add_handler(CallbackQueryHandler(callback_router))

    app.add_handler(
        MessageHandler(
            filters.ChatType.PRIVATE
            & filters.User(99347107)
            & filters.TEXT
            & filters.Regex(r"^/stats$"),
            handle_stats_request
        )
    )

      
    # ‚úÖ initialize application
    await app.initialize()

    # üåê ÿ≥ÿßÿÆÿ™ aiohttp ÿ®ÿ±ÿß€å Ÿàÿ®‚ÄåŸáŸà⁄©
    from aiohttp import web
    import os

    aio_app = web.Application()
    aio_app.router.add_get("/", lambda req: web.Response(text="OK"))

    async def webhook_handler(request):
        data = await request.json()
        update = Update.de_json(data, app.bot)
        await app.process_update(update)
        return web.Response()

    aio_app.router.add_post(f"/{TOKEN}", webhook_handler)

    # üì° ÿ™ŸÜÿ∏€åŸÖ ÿ¢ÿØÿ±ÿ≥ Ÿàÿ®‚ÄåŸáŸà⁄©
    webhook_url = f"https://mafia-bot-259u.onrender.com/{TOKEN}"
    await app.bot.set_webhook(webhook_url)

    # üü¢ ÿßÿ¨ÿ±ÿß€å ÿ≥ÿ±Ÿàÿ± aiohttp
    runner = web.AppRunner(aio_app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", int(os.environ.get("PORT", 8080)))
    await site.start()
    print("‚úÖ Webhook server is running...")

    # ‚ñ∂Ô∏è ÿßÿ¨ÿ±ÿß€å ÿßŸæŸÑ€å⁄©€åÿ¥ŸÜ
    await app.start()

    # ‚è≥ ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ÿÆÿßŸÖŸàÿ¥€å ÿ®ÿ±ŸÜÿßŸÖŸá
    await asyncio.Event().wait()


if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

