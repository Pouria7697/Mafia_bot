from __future__ import annotations
from dataclasses import dataclass
import pickle, os, random, asyncio
import telegram.error
import jdatetime
import requests
import json, httpx
import sys
import re
import asyncio
import regex
import subprocess
from html import escape
from telegram.ext import filters
from telegram.error import BadRequest
group_filter = filters.ChatType.GROUPS
from datetime import datetime, timezone, timedelta  
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ForceReply, Message
from telegram.ext import (
    ApplicationBuilder, CommandHandler, CallbackQueryHandler,
    MessageHandler, ContextTypes, filters
)
from collections import defaultdict
# --- CALLBACK DATA CONSTANTS ---
BTN_PLAYER  = "player_name"    
BTN_DELETE  = "delete_seat"      
BTN_START   = "start_game"      
BTN_CALL = "call_players"   
BTN_REROLL = "reroll_roles"  

GH_TOKEN = os.environ.get("GH_TOKEN")
GIST_ID = os.environ.get("GIST_ID")
GIST_FILENAME = "gistfile1.txt"
GIST_API_URL = f"https://api.github.com/gists/{GIST_ID}"


USERNAMES_FILENAME = "usernames.json" 
TOKEN = os.environ.get("TOKEN")
PERSIST_FILE = "mafia_data.pkl"
SEAT_EMOJI = "üë§"; LOCKED_EMOJI = "üîí"; GOD_EMOJI = "üë≥üèª‚Äç‚ôÇÔ∏è"; START_EMOJI = "üöÄ"

def load_active_groups() -> set[int]:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; load_active_groups -> empty set")
            return set()
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        r = requests.get(url, headers=headers, timeout=10)
        if r.status_code != 200:
            print("‚ùå load_active_groups failed:", r.status_code, r.text)
            return set()
        data = r.json()
        content = data["files"].get("active_groups.json", {}).get("content", "[]")
        arr = json.loads(content) if content else []
        return set(int(x) for x in arr)
    except Exception as e:
        print("‚ùå load_active_groups error:", e)
        return set()

def save_active_groups(active_groups: set[int]) -> bool:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; save_active_groups skipped")
            return False
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        payload = {
            "files": {
                "active_groups.json": {
                    "content": json.dumps(sorted(list(active_groups)), ensure_ascii=False, indent=2)
                }
            }
        }
        r = requests.patch(url, headers=headers, json=payload, timeout=10)
        if r.status_code not in (200, 201):
            print("‚ùå save_active_groups failed:", r.status_code, r.text)
            return False
        return True
    except Exception as e:
        print("‚ùå save_active_groups error:", e)
        return False

@dataclass
class Scenario:
    name: str
    roles: dict[str, int]

@dataclass
class GameState:
    god_id: int | None = None
    god_name: str | None = None
    seats: dict[int, tuple[int, str]] | None = None
    event_time: str | None = None
    max_seats: int = 0
    scenario: Scenario | None = None
    phase: str = "idle"

    waiting_name: dict[int, int] | None = None
    waiting_name_proxy: dict[int, int] | None = None
    waiting_god: set[int] | None = None
    awaiting_scenario: bool = False

    assigned_roles: dict[int, str] | None = None
    striked: set[int] | None = None
    voting: dict[int, list[int]] | None = None
    current_vote_target: int | None = None
    vote_type: str | None = None
    vote_candidates: list[int] | None = None
    defense_seats: list[int] | None = None
    last_seating_msg_id: int | None = None
    last_roles_msg_id: int | None = None
    last_roles_scenario_name: str | None = None
    winner_side: str | None = None
    awaiting_winner: bool = False
    last_vote_msg_id: int | None = None
    defense_prompt_msg_id: int | None = None
    strike_control_msg_id = None
    strike_list_msg_id = None
    awaiting_players: set[int] | None = None
    awaiting_name_input: dict[int, int] = None
    last_name_prompt_msg_id: dict[int, int] = None
    from_startgame: bool = False
    awaiting_shuffle_decision: bool = False
    shuffle_prompt_msg_id: int | None = None
    purchased_seat: int | None = None
    awaiting_purchase_number: bool = False
    pending_strikes: set[int] | None = None 
    status_counts: dict[str, int] = None
    status_mode: bool = False 
    ui_hint: str | None = None
    warnings: dict[int, int] | None = None
    warning_mode: bool = False
    pending_warnings: dict[int, int] | None = None


    def __post_init__(self):
        self.seats = self.seats or {}
        self.waiting_name = self.waiting_name or {}
        self.waiting_name_proxy = self.waiting_name_proxy or {}
        self.waiting_god = self.waiting_god or set()
        self.assigned_roles = self.assigned_roles or {}
        self.striked = self.striked or set()
        self.strike_backup_seats = {}
        self.strike_control_msg_id = None
        self.voting = self.voting or {}
        self.vote_candidates = self.vote_candidates or []
        self.defense_seats = self.defense_seats or []
        self.awaiting_players = self.awaiting_players or set()
        self.defense_prompt_msg_id = self.defense_prompt_msg_id or None
        self.awaiting_seat = {}
        self.pending_name_msgs = {}
        self.awaiting_name_input = self.awaiting_name_input or {}
        self.last_name_prompt_msg_id = self.last_name_prompt_msg_id or {}
        self.user_names = {}
        self.selected_defense = []
        self.vote_messages: list = []
        self.last_roles_msg_id = None
        self.awaiting_shuffle_decision = False
        self.shuffle_prompt_msg_id = None
        self.awaiting_purchase_number = False
        self.pending_strikes = self.pending_strikes or set()
        self.status_counts = self.status_counts or {"citizen": 0, "mafia": 0}
        self.status_mode = False
        self.preview_uid_to_role = getattr(self, "preview_uid_to_role", None)
        self.shuffle_repeats = getattr(self, "shuffle_repeats", None) 
        self.chaos_mode = False        
        self.chaos_selected = set()       
        self.purchased_seat = None    
        self.pending_delete = getattr(self, "pending_delete", None) or set()  
        self.warnings = self.warnings or {}
        self.pending_warnings = self.pending_warnings or {}
        self.warning_mode = getattr(self, "warning_mode", False)

class Store:
    def __init__(self, path=PERSIST_FILE):
        self.path = path
        self.scenarios: list[Scenario] = []
        self.games: dict[int, GameState] = {}
        self.group_stats: dict[int, dict] = {}
        self.active_groups: set[int] = set()
        self.load()

    def load(self):
        if os.path.exists(self.path):
            with open(self.path, "rb") as f:
                obj = pickle.load(f)
                self.scenarios = obj.get("scenarios", [])
                self.games = obj.get("games", {})
                self.group_stats = obj.get("group_stats", {})
                # ‚¨áÔ∏è ŸÖŸÜÿ®ÿπ ÿ≠ŸÇ€åŸÇÿ™: Gist
                ag = load_active_groups()
                self.active_groups = ag if ag else set(obj.get("active_groups", []))
                for g in self.games.values():
                    if isinstance(g, GameState):
                        g.__post_init__()
        else:
          
            self.scenarios = []
            self.games = {}
            self.group_stats = {}
            self.active_groups = load_active_groups()  
            self.save()  # ÿ®ÿπÿØÿßŸã ÿ±Ÿà€å ÿØ€åÿ≥⁄© ÿ∞ÿÆ€åÿ±Ÿá ⁄©ŸÜ

    def save(self):
        with open(self.path, "wb") as f:
            pickle.dump({
                "scenarios": self.scenarios,
                "games": self.games,
                "group_stats": self.group_stats,
                "active_groups": list(self.active_groups)
            }, f)


def save_scenarios_to_gist(scenarios):
    if not GH_TOKEN or not GIST_ID:
        return

    url = f"https://api.github.com/gists/{GIST_ID}"
    headers = {
        "Authorization": f"token {GH_TOKEN}",
        "Accept": "application/vnd.github+json",
    }
    data = {
        "files": {
            GIST_FILENAME: {
                "content": json.dumps({"scenarios": [s.__dict__ for s in scenarios]}, ensure_ascii=False, indent=2)
            }
        }
    }

    try:
        httpx.patch(url, headers=headers, json=data)
    except Exception as e:
        print("‚ùå save_scenarios error:", e)

def load_scenarios_from_gist():
    if not GH_TOKEN or not GIST_ID:
        return []

    url = f"https://api.github.com/gists/{GIST_ID}"
    headers = {
        "Authorization": f"token {GH_TOKEN}",
        "Accept": "application/vnd.github+json",
    }

    try:
        response = httpx.get(url, headers=headers)
        if response.status_code == 200:
            gist_data = response.json()
            content = gist_data["files"][GIST_FILENAME]["content"]
            data = json.loads(content)
            return [Scenario(name=s["name"], roles=s["roles"]) for s in data.get("scenarios", [])]
        else:
            print("‚ùå Gist fetch failed:", response.status_code)
            return []
    except Exception as e:
        print("‚ùå load_scenarios error:", e)
        return []
def load_usernames_from_gist():
    try:
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {
            "Authorization": f"token {GH_TOKEN}",
            "Accept": "application/vnd.github+json",
        }

        response = httpx.get(url, headers=headers)
        if response.status_code == 200:
            gist_data = response.json()
            content = gist_data["files"].get(USERNAMES_FILENAME, {}).get("content", "{}")
            data = json.loads(content) or {}
            return {int(k): v for k, v in data.items()}  # üëà ⁄©ŸÑ€åÿØŸáÿß ÿ±Ÿà ÿ™ÿ®ÿØ€åŸÑ ⁄©ŸÜ ÿ®Ÿá ÿπÿØÿØ
        else:
            print("‚ùå user_names gist fetch failed:", response.status_code)
            return {}
    except Exception as e:
        print("‚ùå load_usernames error:", e)
        return {}

def save_usernames_to_gist(usernames: dict[int, str]):
    try:
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {
            "Authorization": f"token {GH_TOKEN}",
            "Accept": "application/vnd.github+json",
        }
        data = {
            "files": {
                USERNAMES_FILENAME: {
                    "content": json.dumps(usernames, ensure_ascii=False, indent=2)
                }
            }
        }
        httpx.patch(url, headers=headers, json=data)
    except Exception as e:
        print("‚ùå save_usernames error:", e)


store = Store()
store.scenarios = load_scenarios_from_gist()

# ŸÑŸàÿØ ⁄©ÿ±ÿØŸÜ ŸÜÿßŸÖ‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿßÿ≤ Gist ÿ®ÿ±ÿß€å ÿ™ŸÖÿßŸÖ ⁄Ø€åŸÖ‚ÄåŸáÿß
usernames = load_usernames_from_gist()
for g in store.games.values():
    g.user_names = usernames



def gs(chat_id):
    g = store.games.setdefault(chat_id, GameState())
    if not g.user_names:
        g.user_names = load_usernames_from_gist()  # ‚Üê ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿßÿ≥ÿßŸÖ€å ÿßÿ≤ Gist
    return g

def load_event_numbers():
    url = f"https://api.github.com/gists/{GIST_ID}"
    res = requests.get(url, headers={"Authorization": f"token {GH_TOKEN}"})
    data = res.json()
    content = data["files"]["event_numbers.json"]["content"]
    try:
        return json.loads(content)
    except:
        return {}

def save_event_numbers(event_numbers: dict) -> bool:
    try:
        if not GH_TOKEN or not GIST_ID:
            print("‚ö†Ô∏è GH_TOKEN/GIST_ID not set; save_event_numbers skipped")
            return False
        url = f"https://api.github.com/gists/{GIST_ID}"
        headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
        payload = {
            "files": {
                "event_numbers.json": {
                    "content": json.dumps(event_numbers, ensure_ascii=False, indent=2)
                }
            }
        }
        res = requests.patch(url, headers=headers, json=payload, timeout=10)
        if res.status_code not in (200, 201):
            print("‚ùå save_event_numbers PATCH failed:", res.status_code, res.text)
            return False

        # ‚úÖ ⁄©ÿ¥ ÿ±ÿß ŸáŸÖÿ≤ŸÖÿßŸÜ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ⁄©ŸÜ
        global EVENT_NUMBERS_CACHE
        EVENT_NUMBERS_CACHE = event_numbers
        return True
    except Exception as e:
        print("‚ùå save_event_numbers error:", e)
        return False



def load_stickers():
    url = f"https://api.github.com/gists/{GIST_ID}"
    res = requests.get(url, headers={"Authorization": f"token {GH_TOKEN}"})
    data = res.json()
    content = data["files"]["stickers.json"]["content"]
    try:
        return json.loads(content)
    except:
        return {}

def save_stickers(stickers):
    url = f"https://api.github.com/gists/{GIST_ID}"
    files = {
        "stickers.json": {
            "content": json.dumps(stickers, ensure_ascii=False, indent=2)
        }
    }
    requests.patch(url, headers={"Authorization": f"token {GH_TOKEN}"}, json={"files": files})


def text_seating_keyboard(g: GameState) -> InlineKeyboardMarkup:
    rows = [
        [
            InlineKeyboardButton("‚è∞ ÿ™ÿ∫€å€åÿ± ÿ≥ÿßÿπÿ™", callback_data="change_time")
        ],
        [
            InlineKeyboardButton("‚ùå ÿ≠ÿ∞ŸÅ ÿ®ÿßÿ≤€å⁄©ŸÜ", callback_data=BTN_DELETE),
            InlineKeyboardButton("üßπ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ", callback_data="cleanup_below")
        ],
        [
            InlineKeyboardButton("‚Ü©Ô∏è ŸÑÿ∫Ÿà ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ", callback_data="cancel_self"),
            InlineKeyboardButton("‚úèÔ∏è ÿ™ÿ∫€å€åÿ± ŸÜÿßŸÖ", callback_data="change_name")
        ]
    ]

    if g.god_id:
        # ÿ±ÿØ€åŸÅ ÿßŸàŸÑ: ÿµÿØÿß ÿ≤ÿØŸÜ + ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà
        rows.append([
            InlineKeyboardButton("üîä ÿµÿØÿß ÿ≤ÿØŸÜ", callback_data=BTN_CALL),
            InlineKeyboardButton("ü™Ñ ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà", callback_data="change_scenario")
        ])

        # ÿ±ÿØ€åŸÅ ÿØŸàŸÖ: ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å + ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥ (ŸÅŸÇÿ∑ ŸàŸÇÿ™€å ŸáŸÖŸá ÿµŸÜÿØŸÑ€åÿß Ÿæÿ±Ÿá)
        if len(g.seats) == g.max_seats:
            rows.append([
                InlineKeyboardButton("‚ñ∂Ô∏è ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å", callback_data="startgame"),
                InlineKeyboardButton("üé≤ ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥", callback_data=BTN_REROLL)
            ])

    return InlineKeyboardMarkup(rows)



# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#  ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ⁄©ŸÜÿ™ÿ±ŸÑ ÿ±ÿßŸà€å ÿØÿ± ÿ≠€åŸÜ ÿ®ÿßÿ≤€å
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def control_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ö†Ô∏è ÿßÿÆÿ∑ÿßÿ±", callback_data="warn_mode")],
        [InlineKeyboardButton("‚úÇÔ∏è ÿÆÿ∑‚Äåÿ≤ÿØŸÜ", callback_data="strike_out")],
        [InlineKeyboardButton("üìä ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™", callback_data="status_query")],
        [InlineKeyboardButton("üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá", callback_data="init_vote")],
        [InlineKeyboardButton("üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å", callback_data="final_vote")],
        [InlineKeyboardButton("üèÅ ÿßÿ™ŸÖÿßŸÖ ÿ®ÿßÿ≤€å", callback_data="end_game")]
    ])

def warn_button_markup_plusminus(g: GameState) -> InlineKeyboardMarkup:
    # ÿßÿ≤ dict ÿ®ŸàÿØŸÜ ŸÖÿ∑ŸÖÿ¶ŸÜ ÿ¥Ÿà
    pw = g.pending_warnings if isinstance(g.pending_warnings, dict) else {}
    w  = g.warnings          if isinstance(g.warnings, dict)          else {}

    rows = []
    # ŸÅŸÇÿ∑ ÿ≤ŸÜÿØŸá‚ÄåŸáÿß
    alive = [s for s in sorted(g.seats) if s not in g.striked]
    for s in alive:
        base = pw.get(s, w.get(s, 0))
        try:
            n = int(base)
        except Exception:
            n = 0
       
        n = max(0, n)
        icons = "‚ùóÔ∏è" * n if n > 0 else "(0)"
        label = f"{s} {icons}"

        rows.append([
            InlineKeyboardButton("‚ûñ", callback_data=f"warn_dec_{s}"),
            InlineKeyboardButton(label, callback_data="noop"),
            InlineKeyboardButton("‚ûï", callback_data=f"warn_inc_{s}"),
        ])

    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="warn_confirm")])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="warn_back")])
    return InlineKeyboardMarkup(rows)




def kb_endgame_root() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üèô ÿ¥Ÿáÿ±", callback_data="winner_city")],
        [InlineKeyboardButton("üòà ŸÖÿßŸÅ€åÿß", callback_data="winner_mafia")],
        [InlineKeyboardButton("üèô ⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™ ÿ¥Ÿáÿ±", callback_data="clean_city")],
        [InlineKeyboardButton("üòà ⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™ ŸÖÿßŸÅ€åÿß", callback_data="clean_mafia")],
        [InlineKeyboardButton("üèô ÿ¥Ÿáÿ± (⁄©€å‚Äåÿ¢ÿ≥)", callback_data="winner_city_chaos")],
        [InlineKeyboardButton("üòà ŸÖÿßŸÅ€åÿß (⁄©€å‚Äåÿ¢ÿ≥)", callback_data="winner_mafia_chaos")],
        [InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_endgame")]
    ])



def kb_purchase_yesno() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ ÿ®ŸÑŸá", callback_data="purchased_yes")],
        [InlineKeyboardButton("‚ùå ÿÆ€åÿ±", callback_data="purchased_no")],
        [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")]
    ])


def kb_pick_single_seat(alive_seats: list[int], selected: int | None,
                        confirm_cb: str, back_cb: str, title: str = "ÿßŸÜÿ™ÿÆÿßÿ® ÿµŸÜÿØŸÑ€å") -> InlineKeyboardMarkup:
    rows = []
    for s in alive_seats:
        label = f"{s} ‚úÖ" if selected == s else f"{s}"
        rows.append([InlineKeyboardButton(label, callback_data=f"pick_single_{s}")])
    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data=confirm_cb)])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_cb)])
    return InlineKeyboardMarkup(rows)


def kb_pick_multi_seats(alive_seats: list[int], selected: set[int],
                        max_count: int, confirm_cb: str, back_cb: str) -> InlineKeyboardMarkup:
    rows = []
    for s in alive_seats:
        label = f"{s} ‚úÖ" if s in selected else f"{s}"
        rows.append([InlineKeyboardButton(label, callback_data=f"toggle_multi_{s}")])
    rows.append([InlineKeyboardButton(f"‚úÖ ÿ™ÿ£€å€åÿØ ({len(selected)}/{max_count})", callback_data=confirm_cb)])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_cb)])
    return InlineKeyboardMarkup(rows)

def delete_button_markup(g: GameState) -> InlineKeyboardMarkup:
    rows = []
    # ŸÅŸÇÿ∑ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å€å ⁄©Ÿá ÿ®ÿßÿ≤€å⁄©ŸÜ ÿØÿßÿ±ŸÜÿØ
    for seat in sorted(g.seats.keys()):
        label = f"{seat} ‚úÖ" if seat in g.pending_delete else f"{seat}"
        rows.append([InlineKeyboardButton(label, callback_data=f"delete_toggle_{seat}")])
    # ⁄©ŸÜÿ™ÿ±ŸÑ‚ÄåŸáÿß
    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ ÿ≠ÿ∞ŸÅ", callback_data="delete_confirm")])
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="delete_cancel")])
    return InlineKeyboardMarkup(rows)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÿ®ÿßŸÑÿß€å ŸÅÿß€åŸÑ (€åÿß ⁄©ŸÜÿßÿ± ÿ®ŸÇ€åŸáŸî ÿ´Ÿàÿßÿ®ÿ™) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
REG   = "register"   # ŸÜŸÖÿß€åÿ¥ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ€å
CTRL  = "controls"   # ŸÅŸÇÿ∑ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ⁄©ŸÜÿ™ÿ±ŸÑ€å

async def safe_q_answer(q, text=None, show_alert=False):
    try:
        await q.answer(text, show_alert=show_alert)
    except telegram.error.BadRequest:
        pass
    except Exception:
        pass
async def set_hint_and_kb(ctx, chat_id: int, g: GameState, hint: str | None, kb: InlineKeyboardMarkup, mode: str = CTRL):
    g.ui_hint = hint
    store.save()
    await publish_seating(ctx, chat_id, g, mode=mode, custom_kb=kb)

EVENT_NUMBERS_CACHE = None

def get_event_numbers():
    global EVENT_NUMBERS_CACHE
    if EVENT_NUMBERS_CACHE is None:
        EVENT_NUMBERS_CACHE = load_event_numbers() or {}
    return EVENT_NUMBERS_CACHE

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÿ™ÿßÿ®ÿπ ÿßÿµŸÑÿßÿ≠‚Äå ÿ¥ÿØŸá ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def publish_seating(
    ctx,
    chat_id: int,
    g: GameState,
    mode: str = REG,
    custom_kb: InlineKeyboardMarkup | None = None,
):
    # ÿß⁄Øÿ± ÿ®ÿßÿ≤€å ŸáŸÜŸàÿ≤ ÿ®ÿß /newgame ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ŸÜÿ¥ÿØŸá
    if not g.max_seats or g.max_seats <= 0:
        await ctx.bot.send_message(chat_id, "ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπÿå ÿßÿØŸÖ€åŸÜ ÿ®ÿß€åÿØ /newgame <seats> ÿ®ÿ≤ŸÜÿØ.")
        return

    today = jdatetime.date.today().strftime("%Y/%m/%d")
    emoji_numbers = [
        "‚ìø", "‚ûä", "‚ûã", "‚ûå", "‚ûç", "‚ûé", "‚ûè", "‚ûê", "‚ûë", "‚ûí",
        "‚ûì", "‚ì´", "‚ì¨", "‚ì≠", "‚ìÆ", "‚ìØ", "‚ì∞", "‚ì±", "‚ì≤", "‚ì≥", "‚ì¥"
    ]

    # ÿ¢€åÿØ€å/ŸÑ€åŸÜ⁄© ⁄Øÿ±ŸàŸá
    group_id_or_link = f"üÜî {chat_id}"
    if ctx.bot.username and chat_id < 0:
        try:
            chat_obj = await ctx.bot.get_chat(chat_id)
            if getattr(chat_obj, "username", None):
                group_id_or_link = f"üîó <a href='https://t.me/{chat_obj.username}'>{chat_obj.title}</a>"
            else:
                group_id_or_link = f"üîí {chat_obj.title}"
        except:
            pass

    # ÿ®ÿØŸÜŸá ŸÖÿ™ŸÜ
    lines = [
        f"{group_id_or_link}",
        "‚ôöüé≠ <b>ÿ±Ÿà€åÿØÿßÿØ ŸÖÿßŸÅ€åÿß</b>",
        f"‚ôöüìÜ <b>ÿ™ÿßÿ±€åÿÆ:</b> {today}",
        f"‚ôöüï∞ <b>ÿ≤ŸÖÿßŸÜ:</b> {g.event_time or '---'}",
        f"‚ôöüé© <b>ÿ±ÿßŸà€å:</b> <a href='tg://user?id={g.god_id}'>{g.god_name or '‚ùì'}</a>",
    ]

    # ÿ¥ŸÖÿßÿ±Ÿá ÿ±Ÿà€åÿØÿßÿØ (ŸáŸÖ€åÿ¥Ÿá ŸÖŸÇÿØÿßÿ± ŸÅÿπŸÑ€å ÿ±ÿß ÿßÿ≤ ⁄Ø€åÿ™ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ®ÿÆŸàÿßŸÜ)
    
    event_num = int(get_event_numbers().get(str(chat_id), 1))
    lines.insert(1, f"‚ôöüéØ <b>ÿ¥ŸÖÿßÿ±Ÿá ÿ±Ÿà€åÿØÿßÿØ:</b> {event_num}")

    # ÿ≥ŸÜÿßÿ±€åŸà
    if g.scenario:
        lines.append(f"‚ôöüìú <b>ÿ≥ŸÜÿßÿ±€åŸà:</b> {g.scenario.name} | üë• {sum(g.scenario.roles.values())} ŸÜŸÅÿ±")

    lines.append("\n\n‚ôöüìÇ <b>ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ:</b>\n")

    # ŸÑ€åÿ≥ÿ™ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß
    for i in range(1, g.max_seats + 1):
        emoji_num = emoji_numbers[i] if i < len(emoji_numbers) else str(i)

        if i in g.seats:
            uid, name = g.seats[i]
            safe_name = escape(name, quote=False)
            txt = f"<a href='tg://user?id={uid}'>{safe_name}</a>"

            
            wn = 0
            if isinstance(getattr(g, "warnings", None), dict):
                wn = g.warnings.get(i, 0)
            try:
                wn = int(wn)
            except Exception:
                wn = 0
            wn = max(0, wn)
            if wn > 0:
                txt += " " + ("‚ùóÔ∏è" * wn)

            # ‚ò†Ô∏è ÿÆÿ∑‚ÄåÿÆŸàÿ±ÿØŸá‚ÄåŸáÿß
            if i in g.striked:
                txt += " ‚ùå‚ò†Ô∏è"

            line = f"‚ôö{emoji_num}  {txt}"
        else:
            line = f"‚ôö{emoji_num} ‚¨ú /{i}"

        lines.append(line)




    # ⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©Ÿàÿ™ÿßŸá ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™ (ÿßÿÆÿ™€åÿßÿ±€å)
    if g.status_counts.get("citizen", 0) > 0 or g.status_counts.get("mafia", 0) > 0:
        c = g.status_counts.get("citizen", 0)
        m = g.status_counts.get("mafia", 0)
        lines.append(f"\nüßæ <i>ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™: {c} ÿ¥Ÿáÿ±ŸàŸÜÿØ Ÿà {m} ŸÖÿßŸÅ€åÿß</i>")

    # ÿ±ÿßŸáŸÜŸÖÿß€å ŸÖÿ±ÿ≠ŸÑŸá (ÿØÿ± ŸáŸÖÿßŸÜ Ÿæ€åÿßŸÖ)
    if getattr(g, "ui_hint", None):
        lines.append("")
        lines.append(f"‚ÑπÔ∏è <i>{g.ui_hint}</i>")

    text = "\n".join(lines)

    # ÿßŸÜÿ™ÿÆÿßÿ® ⁄©€åÿ®Ÿàÿ±ÿØ
    if custom_kb is not None:
        kb = custom_kb
    else:
        if mode == REG:
            kb = text_seating_keyboard(g)
        elif mode == "strike":
            kb = strike_button_markup(g)
        elif mode == "status":
            kb = status_button_markup(g)
        elif mode == "delete":
            kb = warn_button_markup_plusminus(g)
        elif mode == "warn":                         
            kb = warn_button_markup(g)
        else:
            kb = control_keyboard()

    # ÿßÿ±ÿ≥ÿßŸÑ/Ÿà€åÿ±ÿß€åÿ¥ Ÿæ€åÿßŸÖ ŸÑ€åÿ≥ÿ™
    from telegram.error import BadRequest

    try:
        if g.last_seating_msg_id:
            try:
                # ÿ™ŸÑÿßÿ¥ ÿ®ÿ±ÿß€å ÿßÿØ€åÿ™ ŸÖÿ™ŸÜ + ⁄©€åÿ®Ÿàÿ±ÿØ
                await ctx.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=g.last_seating_msg_id,
                    text=text,
                    parse_mode="HTML",
                    reply_markup=kb,
                )
            except BadRequest as e:
                s = str(e)
                if "message is not modified" in s:
                    # ŸÖÿ™ŸÜ ÿ™ÿ∫€å€åÿ±€å ŸÜ⁄©ÿ±ÿØŸáÿõ ÿ¥ÿß€åÿØ ŸÅŸÇÿ∑ ⁄©€åÿ®Ÿàÿ±ÿØ ÿ®ÿß€åÿØ ÿπŸàÿ∂ ÿ¥ŸàÿØ
                    try:
                        await ctx.bot.edit_message_reply_markup(
                            chat_id=chat_id,
                            message_id=g.last_seating_msg_id,
                            reply_markup=kb
                        )
                    except BadRequest as e2:
                        # ÿß⁄Øÿ± ÿß€åŸÜ ŸáŸÖ ÿ™ÿ∫€å€åÿ±€å ŸÜÿØÿßÿ¥ÿ™ÿå ⁄©ÿßÿ±€å ŸÑÿßÿ≤ŸÖ ŸÜ€åÿ≥ÿ™
                        if "message is not modified" in str(e2):
                            pass
                        else:
                            raise
                else:
                    # ÿÆÿ∑ÿß€å ÿØ€å⁄Øÿ±€å ÿ®ŸàÿØ ‚Üí ÿßÿ¨ÿßÿ≤Ÿá ÿ®ÿØŸá ÿ¥ÿßÿÆŸá‚Äå€å ÿ®€åÿ±ŸàŸÜ€å Ÿæ€åÿßŸÖ ÿ¨ÿØ€åÿØ ÿ®ÿ≥ÿßÿ≤ÿØ
                    raise
        else:
            # ŸáŸÜŸàÿ≤ Ÿæ€åÿßŸÖ€å ŸÜÿØÿßÿ±€åŸÖ ‚Üí ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ÿ¨ÿØ€åÿØ Ÿà Ÿæ€åŸÜ
            msg = await ctx.bot.send_message(chat_id, text, parse_mode="HTML", reply_markup=kb)
            g.last_seating_msg_id = msg.message_id
            if chat_id < 0:
                try:
                    await ctx.bot.pin_chat_message(chat_id, msg.message_id, disable_notification=True)
                except Exception:
                    pass
    except Exception:
        # ÿß⁄Øÿ± ÿßÿØ€åÿ™ ÿ®Ÿá Ÿáÿ± ÿØŸÑ€åŸÑ ŸÖŸÖ⁄©ŸÜ ŸÜÿ¥ÿØ ‚Üí Ÿæ€åÿßŸÖ ÿ¨ÿØ€åÿØ ÿ®ÿ≥ÿßÿ≤
        old_msg_id = g.last_seating_msg_id
        msg = await ctx.bot.send_message(chat_id, text, parse_mode="HTML", reply_markup=kb)
        g.last_seating_msg_id = msg.message_id

        # Ÿæ€åŸÜ Ÿæ€åÿßŸÖ ÿ¨ÿØ€åÿØ
        if chat_id < 0:
            try:
                await ctx.bot.pin_chat_message(chat_id, msg.message_id, disable_notification=True)
            except Exception:
                pass
        # (ÿßÿÆÿ™€åÿßÿ±€å) ÿ≠ÿ∞ŸÅ Ÿæ€åÿßŸÖ ŸÇÿØ€åŸÖ€å ÿ®ÿ±ÿß€å ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ÿØŸà ŸÑ€åÿ≥ÿ™
        # if old_msg_id:
        #     try:
        #         await ctx.bot.delete_message(chat_id, old_msg_id)
        #     except Exception:
        #         pass

    # ŸÜŸÖÿß€åÿ¥ €å⁄©‚Äåÿ®ÿßÿ±Ÿá ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß (ŸàŸÇÿ™€å ÿ≥ŸÜÿßÿ±€åŸà ÿπŸàÿ∂ ÿ¥ŸàÿØ)
    if g.scenario and mode == REG:
        if getattr(g, "last_roles_scenario_name", None) != g.scenario.name:
            role_lines = ["üìú <b>ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß€å ÿ≥ŸÜÿßÿ±€åŸà:</b>\n"]
            for role, count in g.scenario.roles.items():
                for _ in range(count):
                    role_lines.append(f"üî∏ {role}")
            role_text = "\n".join(role_lines)

            try:
                if getattr(g, "last_roles_msg_id", None):
                    try:
                        await ctx.bot.edit_message_text(
                            chat_id=chat_id,
                            message_id=g.last_roles_msg_id,
                            text=role_text,
                            parse_mode="HTML",
                        )
                    except BadRequest as e:
                        if "message is not modified" in str(e):
                            # ŸÜ€åÿßÿ≤€å ÿ®Ÿá Ÿæ€åÿßŸÖ ÿ¨ÿØ€åÿØ ŸÜ€åÿ≥ÿ™
                            pass
                        else:
                            raise
                else:
                    role_msg = await ctx.bot.send_message(chat_id, role_text, parse_mode="HTML")
                    g.last_roles_msg_id = role_msg.message_id
            except Exception:
                role_msg = await ctx.bot.send_message(chat_id, role_text, parse_mode="HTML")
                g.last_roles_msg_id = role_msg.message_id

            g.last_roles_scenario_name = g.scenario.name

    store.save()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#  ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å (ŸáŸÖÿßŸÜ ŸÜÿ≥ÿÆŸáŸî ŸÇÿ®ŸÑ€åÿõ ŸÅŸÇÿ∑ ÿØÿ≥ÿ™ ŸÜÿ≤ÿØ€åŸÖ)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def start_vote(ctx, chat_id: int, g: GameState, stage: str):
    g.vote_stage = stage
    g.tally = {}
    g.current_target = None
    g.collecting = False

    candidates = g.defense_seats if stage == "final" else list(g.seats.keys())

    if stage == "final":
        g.vote_candidates = [s for s in candidates if s not in g.striked]
    else:
        g.vote_candidates = sorted([s for s in candidates if s not in g.striked])
    btns = []
    for s in g.vote_candidates:
        name = g.seats[s][1]
        if hasattr(g, "voted_targets") and s in g.voted_targets:
            label = f"‚úÖ {s}. {name}"
        else:
            label = f"{s}. {name}"
        btns.append([InlineKeyboardButton(label, callback_data=f"vote_{s}")])

    btns.append([InlineKeyboardButton("‚úÖ Ÿæÿß€åÿßŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="vote_done")])

    back_code = "back_vote_init" if stage == "initial_vote" else "back_vote_final"
    btns.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_code)])

    title = "üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿßŸàŸÑ€åŸá ‚Äì ÿßŸÜÿ™ÿÆÿßÿ® ŸáÿØŸÅ:" \
            if stage == "initial_vote" else \
            "üó≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å ‚Äì ÿßŸÜÿ™ÿÆÿßÿ® ÿ≠ÿ∞ŸÅ:"

    msg = await ctx.bot.send_message(chat_id, title, reply_markup=InlineKeyboardMarkup(btns))
    g.last_vote_msg_id = msg.message_id  # üßπ ÿ∞ÿÆ€åÿ±Ÿá Ÿæ€åÿßŸÖ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å
    store.save()

async def update_vote_buttons(ctx, chat_id: int, g: GameState):
    btns = []
    for s in g.vote_candidates:
        name = g.seats[s][1]
        label = f"‚úÖ {s}. {name}" if hasattr(g, "voted_targets") and s in g.voted_targets else f"{s}. {name}"
        btns.append([InlineKeyboardButton(label, callback_data=f"vote_{s}")])

    btns.append([InlineKeyboardButton("‚úÖ Ÿæÿß€åÿßŸÜ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å", callback_data="vote_done")])
    btns.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_vote_init")])

    try:
        await ctx.bot.edit_message_reply_markup(
            chat_id=chat_id,
            message_id=g.last_vote_msg_id,
            reply_markup=InlineKeyboardMarkup(btns)
        )
    except:
        pass


async def handle_vote(ctx, chat_id: int, g: GameState, target_seat: int):
    g.current_vote_target = target_seat

    await ctx.bot.send_message(
        chat_id,
        f"‚è≥ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ®ÿ±ÿß€å <b>{target_seat}. {g.seats[target_seat][1]}</b>",
        parse_mode="HTML"
    )

    await asyncio.sleep(5)

    await ctx.bot.send_message(
        chat_id,
        f"üõë ÿ™ŸÖÿßŸÖ",
        parse_mode="HTML"
    )

    # ‚úÖ ÿπŸÑÿßŸÖÿ™‚Äå⁄Øÿ∞ÿßÿ±€å ÿß€åŸÜ⁄©Ÿá ÿß€åŸÜ ÿµŸÜÿØŸÑ€å ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ¥ÿØŸá
    if not hasattr(g, "voted_targets"):
        g.voted_targets = set()
    g.voted_targets.add(target_seat)

    # üîÅ ÿ¢ŸæÿØ€åÿ™ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß
    await update_vote_buttons(ctx, chat_id, g)

    store.save()

import jdatetime


async def announce_winner(ctx, update, g: GameState):
    chat = update.effective_chat
    group_title = chat.title or "‚Äî"
    date_str = jdatetime.date.today().strftime("%Y/%m/%d")
    scenario_name = getattr(g.scenario, "name", "‚Äî")

    # ‚Üê ŸÅŸÇÿ∑ ÿßÿ≤ ⁄©ÿ¥
    nums = get_event_numbers()
    key = str(chat.id)
    event_num = int(nums.get(key, 1))  # ŸÜŸÖÿß€åÿ¥ ÿπÿØÿØ ŸÅÿπŸÑ€å

    # ŸÑ€åŸÜ⁄©‚ÄåÿØÿßÿ± ⁄©ÿ±ÿØŸÜ ⁄Øÿ±ŸàŸá
    if chat.username:
        group_link = f"<a href='https://t.me/{chat.username}'>{group_title}</a>"
    else:
        group_link = group_title

    lines = [
        f"‚ñë‚öúÔ∏èüéÆ ⁄Øÿ±ŸàŸá: {group_link}",
        f"‚ñë‚öúÔ∏èüìÖ ÿ™ÿßÿ±€åÿÆ: {date_str}",
        f"‚ñë‚öúÔ∏èüéØ ÿ¥ŸÖÿßÿ±Ÿá ÿ±Ÿà€åÿØÿßÿØ:{event_num}",
        f"‚ñëüí°üî± ÿ±ÿßŸà€å: <a href='tg://user?id={g.god_id}'>{g.god_name or '‚ùì'}</a>",
        f"‚ñë‚öúÔ∏èüìÉ ÿ≥ŸÜÿßÿ±€åŸà: {scenario_name}",
        "",
        "‚ñë‚öúÔ∏èüí´ ŸÑ€åÿ≥ÿ™ ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ‚¨áÔ∏è",
        "",
    ]

    for seat in sorted(g.seats):
        uid, name = g.seats[seat]
        role = g.assigned_roles.get(seat, "‚Äî")
        role_display = f"{role} / ŸÖÿßŸÅ€åÿßÿ≥ÿßÿØŸá" if getattr(g, "purchased_seat", None) == seat else role
        chaos_mark = " üü¢" if getattr(g, "chaos_selected", set()) and seat in g.chaos_selected else ""
        lines.append(f"‚ñë‚öúÔ∏è‚ñ™Ô∏è{seat}- <a href='tg://user?id={uid}'>{name}</a> ‚á¶ {role_display}{chaos_mark}")

    lines.append("")
    result_line = f"üèÜ ŸÜÿ™€åÿ¨Ÿá ÿ®ÿßÿ≤€å: ÿ®ÿ±ÿØ {g.winner_side}"
    if getattr(g, "clean_win", False): result_line += " (⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™)"
    if getattr(g, "chaos_mode", False): result_line += " (⁄©€å‚Äåÿ¢ÿ≥)"
    lines.append(result_line)

    # ‚úÖ ÿßŸÅÿ≤ÿß€åÿ¥ ÿ¥ŸÖÿßÿ±Ÿá ÿß€åŸàŸÜÿ™ (⁄©ÿ¥ + Gist)
    nums[key] = event_num + 1
    ok = save_event_numbers(nums)
    if not ok:
        print(f"‚ö†Ô∏è save_event_numbers failed for chat {key}")

    g.phase = "ended"
    store.save()

    msg = await ctx.bot.send_message(chat.id, "\n".join(lines), parse_mode="HTML")
    try:
        await ctx.bot.pin_chat_message(chat_id=chat.id, message_id=msg.message_id)
    except Exception as e:
        print("‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± Ÿæ€åŸÜ ⁄©ÿ±ÿØŸÜ Ÿæ€åÿßŸÖ:", e)



def _apply_size_and_scenario(g: GameState, new_size: int, new_scenario: Scenario):
    # ÿß⁄Øÿ± ⁄©ŸÖ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ: ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿ®ÿßŸÑÿß€å ÿ∏ÿ±ŸÅ€åÿ™ ÿ¨ÿØ€åÿØ ÿ≠ÿ∞ŸÅ ÿ¥ŸàŸÜÿØ
    if new_size < g.max_seats:
        for seat in sorted(list(g.seats.keys())):
            if seat > new_size:
                g.seats.pop(seat, None)
        # ÿÆÿ∑‚ÄåÿÆŸàÿ±ÿØŸá‚ÄåŸáÿß Ÿà ÿØŸÅÿßÿπ Ÿà‚Ä¶ ŸáŸÖ ÿ™ŸÖ€åÿ≤ ÿ¥ŸàŸÜÿØ
        g.striked = {s for s in g.striked if s <= new_size}
        g.defense_seats = [s for s in g.defense_seats if s <= new_size]
    # ÿß⁄Øÿ± ÿ≤€åÿßÿØ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ: ŸÅŸÇÿ∑ ÿ∏ÿ±ŸÅ€åÿ™ ÿ®ÿßŸÑÿß ÿ®ÿ±ŸàÿØÿõ ŸÜŸÅÿ±ÿßÿ™ ŸÇÿ®ŸÑ€å ÿ≥ÿ± ÿ¨ÿß€åÿ¥ÿßŸÜ
    g.max_seats = new_size
    g.scenario = new_scenario
    g.last_roles_scenario_name = None  # ÿ™ÿß ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿØŸàÿ®ÿßÿ±Ÿá ⁄ÜÿßŸæ ÿ¥ŸàÿØ
    # Ÿáÿ±⁄Ü€åÿ≤€å ⁄©Ÿá ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ŸÜŸÇÿ¥‚ÄåŸáÿß€å ŸÇÿ®ŸÑ€å ÿ®ŸàÿØŸá Ÿæÿß⁄©ÿõ ⁄ÜŸàŸÜ ŸáŸÜŸàÿ≤ ÿ®ÿßÿ≤€å ÿ¥ÿ±Ÿàÿπ ŸÜÿ¥ÿØŸá
    g.assigned_roles = {}
    g.phase = "idle"
    g.awaiting_scenario = False
    # ŸÅŸÑ⁄Ø‚ÄåŸáÿß€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà
    g.awaiting_scenario_change = False
    g.pending_size = None

def _scenario_sizes_available() -> list[int]:
    sizes = sorted({sum(s.roles.values()) for s in store.scenarios})
    return sizes

def kb_choose_sizes() -> InlineKeyboardMarkup:
    sizes = _scenario_sizes_available()
    rows, row = [], []
    for i, n in enumerate(sizes, 1):
        row.append(InlineKeyboardButton(str(n), callback_data=f"scsize_{n}"))
        if i % 4 == 0:
            rows.append(row); row = []
    if row:
        rows.append(row)
    rows.append([InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="scchange_back")])
    return InlineKeyboardMarkup(rows)

def kb_choose_scenarios_for(size: int) -> InlineKeyboardMarkup:
    options = [s for s in store.scenarios if sum(s.roles.values()) == size]
    # Ÿáÿ± ÿ≥ŸÜÿßÿ±€åŸà €å⁄© ÿØ⁄©ŸÖŸá
    rows = [[InlineKeyboardButton(s.name, callback_data=f"scpick_{size}_{i}")]
            for i, s in enumerate(options)]
    rows.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÜÿ™ÿÆÿßÿ® ÿ∏ÿ±ŸÅ€åÿ™ ÿØ€å⁄Øÿ±", callback_data="scchange_again")])
    return InlineKeyboardMarkup(rows)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#  CALL-BACK ROUTER ‚Äì ŸÜÿ≥ÿÆŸáŸî ⁄©ÿßŸÖŸÑ ÿ®ÿß ŸÅÿßÿµŸÑŸá‚Äå⁄Øÿ∞ÿßÿ±€å ÿØÿ±ÿ≥ÿ™
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def callback_router(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.type == "private":
        return
    q = update.callback_query
    await safe_q_answer(q)
    data = q.data
    chat = q.message.chat.id
    uid = q.from_user.id
    g = gs(chat)


    # ‚îÄ‚îÄ‚îÄ ÿ≠ÿ∞ŸÅ ÿ®ÿßÿ≤€å⁄©ŸÜ ÿ™Ÿàÿ≥ÿ∑ ⁄ØÿßÿØ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == BTN_DELETE:
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ≠ÿ∞ŸÅ ⁄©ŸÜÿØ!")
            return
        g.pending_delete = set()
        store.save()
        await set_hint_and_kb(
            ctx, chat, g,
            "ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØÿßÿ±ÿß€å ÿ®ÿßÿ≤€å⁄©ŸÜ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿØÿ± Ÿæÿß€åÿßŸÜ ¬´ÿ™ÿ£€å€åÿØ ÿ≠ÿ∞ŸÅ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            delete_button_markup(g),
            mode="delete"
        )
        return
    if data.startswith("delete_toggle_") and uid == g.god_id:
        try:
            seat = int(data.split("_")[2])
        except:
            return
        # ŸÅŸÇÿ∑ ÿß⁄Øÿ± ÿµŸÜÿØŸÑ€å ŸæŸèÿ± ÿßÿ≥ÿ™ ÿßÿ¨ÿßÿ≤ŸáŸî ÿßŸÜÿ™ÿÆÿßÿ® ÿ®ÿØŸá
        if seat in g.seats:
            if seat in g.pending_delete:
                g.pending_delete.remove(seat)
            else:
                g.pending_delete.add(seat)
            store.save()
        await publish_seating(ctx, chat, g, mode="delete")
        return

    if data == "delete_confirm" and uid == g.god_id:
        # ÿ≠ÿ∞ŸÅ ŸáŸÖŸáŸî ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿßŸÜÿ™ÿÆÿßÿ®‚Äåÿ¥ÿØŸá
        for seat in sorted(list(g.pending_delete)):
            g.seats.pop(seat, None)
        g.pending_delete = set()
        g.ui_hint = None 
        store.save()
        await publish_seating(ctx, chat, g, mode=REG)
        return

    if data == "delete_cancel" and uid == g.god_id:
        g.pending_delete = set()
        store.save()
        await publish_seating(ctx, chat, g, mode=REG)
        return


    # ‚îÄ‚îÄ‚îÄ ŸÑÿ∫Ÿà ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ™Ÿàÿ≥ÿ∑ ÿÆŸàÿØŸê ÿ®ÿßÿ≤€å⁄©ŸÜ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "cancel_self":
        for seat, (player_uid, _) in g.seats.items():
            if player_uid == uid:
                del g.seats[seat]
                store.save()
                await ctx.bot.send_message(chat, "‚ùé ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÑÿ∫Ÿà ÿ¥ÿØ.")
                await publish_seating(ctx, chat, g)
                break
        else:
            await ctx.bot.send_message(chat,"‚ùó ÿ¥ŸÖÿß ÿØÿ± ŸÑ€åÿ≥ÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.")
        return

    if data == "change_name":
        if uid not in [u for u, _ in g.seats.values()]:
            await ctx.bot.send_message(chat, "‚ùó ÿ¥ŸÖÿß ŸáŸÜŸàÿ≤ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ŸÜ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.")
            return

        seat_no = [s for s in g.seats if g.seats[s][0] == uid][0]
        g.waiting_name[uid] = seat_no
        store.save()

        await ctx.bot.send_message(
            chat,
            f"‚úèÔ∏è ÿß€åŸÜ Ÿæ€åÿßŸÖ ÿ±ÿß ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ Ÿà ŸÜÿßŸÖ ÿ¨ÿØ€åÿØ ÿÆŸàÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å {seat_no} ÿ®Ÿá ŸÅÿßÿ±ÿ≥€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:"
        )
        return



    # ‚îÄ‚îÄ‚îÄ ÿµÿØÿß ÿ≤ÿØŸÜ ŸáŸÖŸá ŸÇÿ®ŸÑŸê ÿ¥ÿ±Ÿàÿπ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == BTN_CALL:
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿß€åŸÜ ÿØ⁄©ŸÖŸá ÿ±ÿß ÿ®ÿ≤ŸÜÿØ!")
            return

        mentions = [
            f"<a href='tg://user?id={u_id}'>{name}</a>"
            for _, (u_id, name) in sorted(g.seats.items())
        ]
        text = (
            "üéô ÿ≥ŸÑÿßÿ∑€åŸÜ ÿ™ÿ¥ÿ±€åŸÅ ÿ®€åÿßÿ±€åÿØÿå "
            "ÿ®ŸÇ€åŸá ÿ±Ÿà ÿπŸÑÿßŸÅ ŸÜ⁄©ŸÜ€åÿØ!\n" + " | ".join(mentions)
        )
        await ctx.bot.send_message(chat, text, parse_mode="HTML")
        return

    # ‚îÄ‚îÄ‚îÄ ÿ™ÿ∫€å€åÿ± ÿ≥ÿßÿπÿ™ ÿ¥ÿ±Ÿàÿπ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "change_time":
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ≤ŸÖÿßŸÜ ÿ±ÿß ÿπŸàÿ∂ ⁄©ŸÜÿØ!")
            return
        g.vote_type = "awaiting_time"
        store.save()
        await ctx.bot.send_message(
            chat,
            "üïí ÿ≥ÿßÿπÿ™ ÿ¥ÿ±Ÿàÿπ ÿ±ÿß ÿ®ŸÜŸà€åÿ≥ (ŸÖÿ´ÿßŸÑ: 22:30):",
            reply_markup=ForceReply(selective=True)
        )
        return

    # ‚îÄ‚îÄ‚îÄ ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å (ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "startgame":
        if g.god_id is None:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ÿ±ÿßŸà€å ÿ´ÿ®ÿ™ ŸÜÿßŸÖ ⁄©ŸÜÿØ!")
            return

        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ®ÿßÿ≤€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        if not getattr(g, "preview_uid_to_role", None):
            await ctx.bot.send_message(
                chat,
                "üé≤ ŸÇÿ®ŸÑ ÿßÿ≤ ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€åÿå ⁄ÜŸÜÿØ ÿ®ÿßÿ± ÿ±Ÿà€å ¬´ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥¬ª ÿ®ÿ≤ŸÜ€åÿØ ÿ™ÿß ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ¥ÿßŸÅŸÑ ÿ¥ŸàŸÜÿØ."
            )
            return

        if len(g.seats) != g.max_seats:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸáŸÜŸàÿ≤ ŸáŸÖŸáŸî ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ŸæŸèÿ± ŸÜÿ¥ÿØŸá!")
            return

     
        now = datetime.now(timezone.utc).timestamp()
        store.group_stats.setdefault(chat, {
            "waiting_list": [],
            "started": [],
            "ended": []
        })
        store.group_stats[chat]["started"].append(now)
        store.save()
        if g.scenario:
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("‚úÖ ÿ®ŸÑŸá", callback_data="shuffle_yes"),
                    InlineKeyboardButton("‚ùå ÿÆ€åÿ±", callback_data="shuffle_no"),
                ]
            ])
            msg = await ctx.bot.send_message(
                chat,
                "‚ùì ÿ¢€åÿß ŸÖÿß€åŸÑ Ÿáÿ≥ÿ™€åÿØ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿ±ŸÜÿØŸàŸÖ ÿ®ÿ¥ŸÜÿü",
                reply_markup=keyboard
            )
            g.shuffle_prompt_msg_id = msg.message_id
            g.awaiting_shuffle_decision = True
            store.save()
            return

 
        g.awaiting_scenario = True
        g.from_startgame = False
        store.save()
        await show_scenario_selection(ctx, chat, g)
        return

    if data == "shuffle_yes":
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ®ÿßÿ≤€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        if not g.awaiting_shuffle_decision:
            return

        g.awaiting_shuffle_decision = False
        g.from_startgame = False
        store.save()

        if hasattr(g, "shuffle_prompt_msg_id") and g.shuffle_prompt_msg_id:
            try:
                await ctx.bot.delete_message(chat, g.shuffle_prompt_msg_id)
            except:
                pass
            g.shuffle_prompt_msg_id = None

        repeats = getattr(g, "shuffle_repeats", None) or 1

        await shuffle_and_assign(
            ctx,
            chat,
            g,
            shuffle_seats=True,                         # ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿ¨ÿßÿ®ÿ¨ÿß ÿ®ÿ¥ŸÜ
            uid_to_role=g.preview_uid_to_role or None,  # ÿß⁄Øÿ± ÿ±€åÿ±ŸàŸÑ ÿ≤ÿØŸá ÿ®ŸàÿØÿå ŸáŸÖŸàŸÜ ŸÜŸÇÿ¥‚ÄåŸáÿß
            notify_players=True,                        # ÿß€åŸÜ ÿ®ÿßÿ± ÿ®ÿ±ÿß€å ŸæŸÑ€åÿ±Ÿáÿß ŸáŸÖ ÿ®ŸÅÿ±ÿ≥ÿ™
            preview_mode=False,
            role_shuffle_repeats=repeats,               # ‚ú® ÿ™ÿπÿØÿßÿØ ÿØŸÅÿπÿßÿ™ ÿ¥ÿßŸÅŸÑ ÿ≥€åÿ™ ŸÖÿ∑ÿßÿ®ŸÇ ÿ±€åÿ±ŸàŸÑ
        )

        g.preview_uid_to_role = None
        g.shuffle_repeats = None
        store.save()
        return


    
    if data == "shuffle_no":
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ®ÿßÿ≤€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        if not g.awaiting_shuffle_decision:
            return

        g.awaiting_shuffle_decision = False
        g.from_startgame = False
        store.save()

        if hasattr(g, "shuffle_prompt_msg_id") and g.shuffle_prompt_msg_id:
            try:
                await ctx.bot.delete_message(chat, g.shuffle_prompt_msg_id)
            except:
                pass
            g.shuffle_prompt_msg_id = None

        repeats = getattr(g, "shuffle_repeats", None) or 1

        await shuffle_and_assign(
            ctx,
            chat,
            g,
            shuffle_seats=False,                        # ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿ´ÿßÿ®ÿ™ ÿ®ŸÖÿßŸÜŸÜÿØ
            uid_to_role=g.preview_uid_to_role or None,  # ÿß⁄Øÿ± ÿ±€åÿ±ŸàŸÑ ÿ≤ÿØŸá ÿ®ŸàÿØÿå ŸáŸÖÿßŸÜ ŸÜŸÇÿ¥‚ÄåŸáÿß
            notify_players=True,                        # ÿß€åŸÜ ÿ®ÿßÿ± ÿ®ÿ±ÿß€å ŸæŸÑ€åÿ±Ÿáÿß ŸáŸÖ ÿ®ŸÅÿ±ÿ≥ÿ™
            preview_mode=False,
            role_shuffle_repeats=repeats,               # (ÿ®ÿ±ÿß€å ÿ≥ÿßÿ≤⁄Øÿßÿ±€å Ÿæÿßÿ≥ ŸÖ€å‚ÄåÿØŸá€åŸÖ)
        )

        g.preview_uid_to_role = None
        g.shuffle_repeats = None
        store.save()
        return

    # ÿßÿÆÿ∑ÿßÿ±

    # Ÿàÿ±ŸàÿØ ÿ®Ÿá ÿ≠ÿßŸÑÿ™ ÿßÿÆÿ∑ÿßÿ±
    if data == "warn_mode":
        if uid != g.god_id:
            await ctx.bot.send_message(chat, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿßÿÆÿ∑ÿßÿ± ÿ®ÿØŸáÿØ!")
            return
        if not isinstance(g.warnings, dict):
            g.warnings = {}
        g.warning_mode = True
        g.pending_warnings = dict(g.warnings)  # Ÿà€åÿ±ÿß€åÿ¥ ÿ±Ÿà€å ⁄©Ÿæ€å
        store.save()
        await publish_seating(ctx, chat, g, mode="warn")
        return

    # ÿßŸÅÿ≤ÿß€åÿ¥ ÿßÿÆÿ∑ÿßÿ±
    if data.startswith("warn_inc_") and g.warning_mode and uid == g.god_id:
        try:
            seat = int(data.split("_")[2])
        except Exception:
            return
        if seat in g.seats and seat not in g.striked:
            if not isinstance(g.pending_warnings, dict):
                g.pending_warnings = {}
            cur = g.pending_warnings.get(seat, g.warnings.get(seat, 0))
            try:
                cur = int(cur)
            except Exception:
                cur = 0
            
            nxt = cur + 1
            g.pending_warnings[seat] = nxt
            store.save()
            await publish_seating(ctx, chat, g, mode="warn")
        return

    # ⁄©ÿßŸáÿ¥ ÿßÿÆÿ∑ÿßÿ±
    if data.startswith("warn_dec_") and g.warning_mode and uid == g.god_id:
        try:
            seat = int(data.split("_")[2])
        except Exception:
            return
        if seat in g.seats and seat not in g.striked:
            if not isinstance(g.pending_warnings, dict):
                g.pending_warnings = {}
            cur = g.pending_warnings.get(seat, g.warnings.get(seat, 0))
            try:
                cur = int(cur)
            except Exception:
                cur = 0
            
            nxt = max(cur - 1, 0) 
            
            g.pending_warnings[seat] = nxt
            store.save()
            await publish_seating(ctx, chat, g, mode="warn")
        return

    # ÿ™ÿ£€å€åÿØ ÿßÿÆÿ∑ÿßÿ±Ÿáÿß
    if data == "warn_confirm" and g.warning_mode and uid == g.god_id:
        if not isinstance(g.pending_warnings, dict):
            g.pending_warnings = {}
        # ŸÅŸÇÿ∑ ŸÖŸÇÿßÿØ€åÿ± >0 ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ŸàŸÜÿØ
        g.warnings = {
            int(k): int(v)
            for k, v in g.pending_warnings.items()
            if isinstance(v, int) and v > 0
        }
        g.warning_mode = False
        g.pending_warnings = {}
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return

    # ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®ÿØŸàŸÜ ÿßÿπŸÖÿßŸÑ
    if data == "warn_back" and g.warning_mode and uid == g.god_id:
        g.warning_mode = False
        g.pending_warnings = {}
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return

    # ŸÜÿßÿØ€åÿØŸá ⁄Øÿ±ŸÅÿ™ŸÜ ÿ®ÿ±⁄Üÿ≥ÿ®
    if data == "noop":
        return

    # ÿ¥ÿ±Ÿàÿπ ¬´ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà/ÿ∏ÿ±ŸÅ€åÿ™¬ª
    if data == "change_scenario":
        if g.god_id is None or uid != g.god_id:
            await safe_q_answer(q, "‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ≥ŸÜÿßÿ±€åŸà ÿ±ÿß ÿ™ÿ∫€å€åÿ± ÿØŸáÿØ!", show_alert=True)
            return
        g.awaiting_scenario_change = True
        g.pending_size = None
        store.save()
        await set_hint_and_kb(ctx, chat, g, "ÿßÿ®ÿ™ÿØÿß ÿ∏ÿ±ŸÅ€åÿ™ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", kb_choose_sizes(), mode=REG if g.phase=="idle" else CTRL)
        return

    # ÿ®ÿ±⁄Øÿ¥ÿ™ ÿßÿ≤ ÿßŸÜÿ™ÿÆÿßÿ® ÿ∏ÿ±ŸÅ€åÿ™/ÿ≥ŸÜÿßÿ±€åŸà
    if data == "scchange_back":
        g.awaiting_scenario_change = False
        g.pending_size = None
        g.ui_hint = None
        store.save()
        await publish_seating(ctx, chat, g, mode=REG if g.phase=="idle" else CTRL)
        return

    # ÿ™ÿ∫€å€åÿ± ÿ∏ÿ±ŸÅ€åÿ™ ‚Üí ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ÿ≥ŸÜÿßÿ±€åŸàŸáÿß€å ŸáŸÖÿßŸÜ ÿ∏ÿ±ŸÅ€åÿ™
    if data.startswith("scsize_") and getattr(g, "awaiting_scenario_change", False):
        try:
            size = int(data.split("_")[1])
        except:
            return
        g.pending_size = size
        store.save()
        await set_hint_and_kb(ctx, chat, g,
                              f"ÿ≥ŸÜÿßÿ±€åŸà€å {size}ŸÜŸÅÿ±Ÿá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
                              kb_choose_scenarios_for(size),
                              mode=REG if g.phase=="idle" else CTRL)
        return

    # ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà ŸÜŸáÿß€å€å Ÿà ÿßÿπŸÖÿßŸÑ ÿ™ÿ∫€å€åÿ±
    if data.startswith("scpick_") and getattr(g, "awaiting_scenario_change", False):
        parts = data.split("_")
        if len(parts) != 3:
            return
        try:
            size = int(parts[1])
            idx = int(parts[2])
        except:
            return

        options = [s for s in store.scenarios if sum(s.roles.values()) == size]
        if not (0 <= idx < len(options)):
            await safe_q_answer(q, "ÿ≥ŸÜÿßÿ±€åŸà€å ŸÜÿßŸÖÿπÿ™ÿ®ÿ±.", show_alert=True)
            return

        chosen = options[idx]

        # ‚õî ÿß⁄Øÿ± ÿ™ÿ∫€å€åÿ±€å ŸÜ€åÿ≥ÿ™ÿå ⁄©ÿßÿ±€å ŸÜ⁄©ŸÜ
        if g.scenario and g.scenario.name == chosen.name and g.max_seats == size:
            await safe_q_answer(q, "ÿ≥ŸÜÿßÿ±€åŸà ÿ™ÿ∫€å€åÿ±€å ŸÜ⁄©ÿ±ÿØ.", show_alert=False)
            return

        _apply_size_and_scenario(g, size, chosen)
        # ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ŸÖŸàÿØ ÿ™ÿ∫€å€åÿ± ÿ≥ŸÜÿßÿ±€åŸà Ÿà Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ hint
        g.awaiting_scenario_change = False
        g.pending_size = None
        g.ui_hint = None
        store.save()

        # ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ÿ®ÿß ÿ∏ÿ±ŸÅ€åÿ™/ÿ≥ŸÜÿßÿ±€åŸà€å ÿ¨ÿØ€åÿØ
        await set_hint_and_kb(
            ctx, chat, g,
            None,
            text_seating_keyboard(g),
            mode=REG if g.phase == "idle" else CTRL
        )
        return

    # ÿß⁄Øÿ± Ÿàÿ≥ÿ∑ ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà ÿ®ŸàÿØ Ÿà ⁄ØŸÅÿ™ ¬´ÿ∏ÿ±ŸÅ€åÿ™ ÿØ€å⁄Øÿ±¬ª
    if data == "scchange_again" and getattr(g, "awaiting_scenario_change", False):
        g.pending_size = None
        store.save()
        await set_hint_and_kb(ctx, chat, g, "ÿ∏ÿ±ŸÅ€åÿ™ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", kb_choose_sizes(), mode=REG if g.phase=="idle" else CTRL)
        return

 

    # ‚îÄ‚îÄ‚îÄ Ÿæÿß€åÿßŸÜ ÿ®ÿßÿ≤€å Ÿà ÿßŸÜÿ™ÿÆÿßÿ® ÿ®ÿ±ŸÜÿØŸá ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "end_game" and uid == g.god_id:
        now = datetime.now(timezone.utc).timestamp()
        store.group_stats.setdefault(chat, {"waiting_list": [], "started": [], "ended": []})
        store.group_stats[chat]["ended"].append(now)

        g.phase = "awaiting_winner"
        g.awaiting_winner = True
        g.temp_winner = None
        g.chaos_mode = False
        g.chaos_selected = set()
        store.save()

        await set_hint_and_kb(ctx, chat, g, "ÿ®ÿ±ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.", kb_endgame_root())
        return


    if data == "back_endgame" and uid == g.god_id:
        g.awaiting_winner = False
        g.phase = "playing"
        g.temp_winner = None
        g.chaos_mode = False
        g.chaos_selected = set()
        g.ui_hint = None  # üëà ÿ®ÿ±ÿß€å ÿß€åŸÜ⁄©Ÿá ŸÖÿ™ŸÜ ÿ±ÿßŸáŸÜŸÖÿß ÿ±Ÿà€å ŸÑ€åÿ≥ÿ™ ÿßÿµŸÑ€å ÿ®ÿßŸÇ€å ŸÜŸÖŸàŸÜŸá
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return


    if data in {
        "winner_city", "winner_mafia", "clean_city", "clean_mafia",
        "winner_city_chaos", "winner_mafia_chaos"
    } and g.awaiting_winner:
        g.temp_winner = data
        g.chaos_mode = data.endswith("_chaos")
        store.save()

        # ⁄©ŸÑ€åŸÜ‚Äåÿ¥€åÿ™ ‚Üí ŸÖÿ≥ÿ™ŸÇ€åŸÖÿßŸã ÿ™ÿ£€å€åÿØ ŸÜŸáÿß€å€å
        if data in {"clean_city", "clean_mafia"}:
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
                [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
            ])
            await set_hint_and_kb(ctx, chat, g, "ŸÜÿ™€åÿ¨Ÿá ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ Ÿà ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.", kb)
            return

        # ÿ¥Ÿáÿ±/ŸÖÿßŸÅ€åÿß (ŸÖÿπŸÖŸàŸÑ€å €åÿß ⁄©€å‚Äåÿ¢ÿ≥) ‚Üí ÿßŸàŸÑ ÿ®Ÿæÿ±ÿ≥ ¬´ÿÆÿ±€åÿØÿßÿ±€åÿü¬ª
        await set_hint_and_kb(ctx, chat, g, "ÿ¢€åÿß ÿ®ÿßÿ≤€å⁄©ŸÜ€å ÿÆÿ±€åÿØÿßÿ±€å ÿ¥ÿØŸá ÿßÿ≥ÿ™ÿü", kb_purchase_yesno())
        return





    if data == "purchased_yes" and g.awaiting_winner:
        g.awaiting_purchase_number = True
        alive = [s for s in sorted(g.seats) if s not in g.striked]
        kb = kb_pick_single_seat(alive_seats=alive,
                                 selected=g.purchased_seat,
                                 confirm_cb="purchased_confirm",
                                 back_cb="back_to_winner_select")
        await set_hint_and_kb(ctx, chat, g,"ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å ÿ®ÿßÿ≤€å⁄©ŸÜŸê ÿÆÿ±€åÿØÿßÿ±€å‚Äåÿ¥ÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.", kb)
        return

    if data == "purchased_no" and g.awaiting_winner:
        g.purchased_seat = None
        store.save()

        if not g.chaos_mode:
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
                [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
            ])
            await set_hint_and_kb(
                ctx, chat, g,
                "üîí ÿ®ÿ±ŸÜÿØŸá ŸÖÿ¥ÿÆÿµ ÿ¥ÿØ. ÿß⁄Øÿ± ŸÖÿ∑ŸÖÿ¶ŸÜ Ÿáÿ≥ÿ™€åÿØ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
                kb
            )
            return

        # ⁄©€å‚Äåÿ¢ÿ≥ ‚Üí ÿßŸÜÿ™ÿÆÿßÿ® €≥ ŸÜŸÅÿ± ÿ≤ŸÜÿØŸá
        alive = [s for s in sorted(g.seats) if s not in g.striked]
        g.chaos_selected = set()
        kb = kb_pick_multi_seats(
            alive, g.chaos_selected, 3,
            confirm_cb="chaos_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            "üåÄ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥: €≥ ŸÜŸÅÿ± ÿßÿ≤ ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ÿ≤ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data.startswith("pick_single_") and g.awaiting_winner:
        try:
            s = int(data.split("_")[2])
        except:
            return

        if s in g.seats and s not in g.striked:
            g.purchased_seat = s
            store.save()

        alive = [x for x in sorted(g.seats) if x not in g.striked]
        kb = kb_pick_single_seat(
            alive, g.purchased_seat,
            confirm_cb="purchased_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            "üõí ÿµŸÜÿØŸÑ€å ÿÆÿ±€åÿØÿßÿ±€å‚Äåÿ¥ÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data == "purchased_confirm" and g.awaiting_winner:
        if not g.chaos_mode:
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
                [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
            ])
            await set_hint_and_kb(
                ctx, chat, g,
                "üîí ÿ®ÿ±ŸÜÿØŸá Ÿà ÿµŸÜÿØŸÑ€å ÿÆÿ±€åÿØÿßÿ±€å‚Äåÿ¥ÿØŸá ÿ´ÿ®ÿ™ ÿ¥ÿØ. ÿ®ÿ±ÿß€å ŸÜŸáÿß€å€å‚Äåÿ≥ÿßÿ≤€å ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
                kb
            )
            return

        # ⁄©€å‚Äåÿ¢ÿ≥ ÿ®ÿπÿØ ÿßÿ≤ ÿÆÿ±€åÿØÿßÿ±€å
        alive = [s for s in sorted(g.seats) if s not in g.striked]
        g.chaos_selected = set()
        kb = kb_pick_multi_seats(
            alive, g.chaos_selected, 3,
            confirm_cb="chaos_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            "üåÄ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥: €≥ ŸÜŸÅÿ± ÿßÿ≤ ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ÿ≤ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ Ÿà ÿ≥Ÿæÿ≥ ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data.startswith("toggle_multi_") and g.awaiting_winner and g.chaos_mode:
        try:
            s = int(data.split("_")[2])
        except:
            return

        alive = [x for x in sorted(g.seats) if x not in g.striked]
        if s in alive:
            if s in g.chaos_selected:
                g.chaos_selected.remove(s)
            else:
                if len(g.chaos_selected) >= 3:
                    await safe_q_answer(q, "ÿ≠ÿØÿß⁄©ÿ´ÿ± €≥ ŸÜŸÅÿ±!", show_alert=True)
                else:
                    g.chaos_selected.add(s)
            store.save()

        kb = kb_pick_multi_seats(
            alive, g.chaos_selected, 3,
            confirm_cb="chaos_confirm",
            back_cb="back_to_winner_select"
        )
        await set_hint_and_kb(
            ctx, chat, g,
            f"üåÄ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥: {len(g.chaos_selected)}/3 ŸÜŸÅÿ± ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØŸá‚ÄåÿßŸÜÿØ. ÿßÿØÿßŸÖŸá ÿØŸá€åÿØ Ÿà ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data == "chaos_confirm" and g.awaiting_winner and g.chaos_mode:
        if len(g.chaos_selected) != 3:
            await safe_q_answer(q, "ÿ®ÿß€åÿØ ÿØŸÇ€åŸÇÿßŸã €≥ ŸÜŸÅÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€å.", show_alert=True)
            return

        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_winner")],
            [InlineKeyboardButton("‚Ü©Ô∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_winner_select")],
        ])
        await set_hint_and_kb(
            ctx, chat, g,
            "üîí ÿßŸÜÿ™ÿÆÿßÿ®‚ÄåŸáÿß ÿ´ÿ®ÿ™ ÿ¥ÿØ. ÿ®ÿ±ÿß€å ŸÜŸáÿß€å€å‚Äåÿ≥ÿßÿ≤€å ŸÜÿ™€åÿ¨Ÿá ¬´ÿ™ÿ£€å€åÿØ¬ª ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.",
            kb
        )
        return


    if data == "back_to_winner_select" and uid == g.god_id and g.awaiting_winner:
        await set_hint_and_kb(
            ctx, chat, g,
            "ÿ®ÿ±ŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
            kb_endgame_root()
        )
        return


    if data == "confirm_winner" and uid == g.god_id and getattr(g, "temp_winner", None):
        g.awaiting_winner = False
        g.winner_side = "ÿ¥Ÿáÿ±" if "city" in g.temp_winner else "ŸÖÿßŸÅ€åÿß"
        g.clean_win = "clean" in g.temp_winner
        # ÿØÿ± ÿµŸàÿ±ÿ™ ÿ≠ÿßŸÑÿ™ ⁄©€å‚Äåÿ¢ÿ≥ÿå g.chaos_selected ŸÇÿ®ŸÑÿßŸã ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØŸá
        g.temp_winner = None
        store.save()

        await announce_winner(ctx, update, g)
        await reset_game(update=update)
        return



    # ‚îÄ‚îÄ‚îÄ ÿß⁄Øÿ± ÿ®ÿßÿ≤€å Ÿæÿß€åÿßŸÜ €åÿßŸÅÿ™Ÿáÿå ÿØ€å⁄Øÿ± ÿßÿØÿßŸÖŸá ŸÜÿØŸá ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if g.phase == "ended":
        return

    if data == "vote_done" and uid == g.god_id:
        # üßπ ÿ≠ÿ∞ŸÅ Ÿæ€åÿßŸÖ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å (ÿß⁄Øÿ± ŸáŸÜŸàÿ≤ Ÿáÿ≥ÿ™)
        if g.last_vote_msg_id:
            try:
                await ctx.bot.delete_message(chat_id=chat, message_id=g.last_vote_msg_id)
            except:
                pass
           # print("Trying to delete vote message:", g.last_vote_msg_id)  # ‚úÖ ÿß€åŸÜÿ¨ÿß ÿ®ÿ∞ÿßÿ±
            g.last_vote_msg_id = None

        await ctx.bot.send_message(chat, "‚úÖ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ™ŸÖÿßŸÖ ÿ¥ÿØ.")
        store.save()
        return


    if data == "cleanup_below":
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàŸÜŸá ÿß€åŸÜ ⁄©ÿßÿ± ÿ±Ÿà ÿßŸÜÿ¨ÿßŸÖ ÿ®ÿØŸá!")
            return

        try:
            deleted = 0
            # üîÑ Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å€å ⁄©Ÿá ÿ®ÿπÿØ ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØŸÜ ÿ±Ÿà ÿ≠ÿ∞ŸÅ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ (ÿ≠ÿØÿß⁄©ÿ´ÿ± 100 ÿπÿØÿØ)
            for msg_id in range(g.last_seating_msg_id + 1, g.last_seating_msg_id + 100):
                try:
                    await ctx.bot.delete_message(chat_id=chat, message_id=msg_id)
                    deleted += 1
                except:
                    pass

            #await ctx.bot.send_message(chat, f"‚úÖ {deleted} Ÿæ€åÿßŸÖ ÿ≤€åÿ± ŸÑ€åÿ≥ÿ™ Ÿæÿß⁄© ÿ¥ÿØ.")
        except Exception as e:
            await ctx.bot.send_message(chat, f"‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿæÿß⁄©ÿ≥ÿßÿ≤€å: {e}")
        return


    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    #  ÿ®ÿÆÿ¥‚ÄåŸáÿß€å ŸÇÿØ€åŸÖ€å (seat_ / cancel_ / strike_out / ‚Ä¶)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    if data == "strike_out" and uid == g.god_id:
        g.pending_strikes = set(g.striked)
        store.save()
        await publish_seating(ctx, chat, g, mode="strike")
        return

    if data == "strike_toggle_done" and uid == g.god_id:
        g.striked = set(g.pending_strikes)
        g.pending_strikes = set()
        store.save()
        await publish_seating(ctx, chat, g, mode=CTRL)
        return

    if data.startswith("strike_toggle_") and uid == g.god_id:
        seat = int(data.split("_")[2])
        if seat in g.pending_strikes:
            g.pending_strikes.remove(seat)
        else:
            g.pending_strikes.add(seat)
        store.save()
        await publish_seating(ctx, chat, g, mode="strike")
        return

    if data == BTN_REROLL:
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ±ÿß ÿ±ŸÜÿØŸàŸÖ ⁄©ŸÜÿØ!")
            return

        if not g.scenario or len(g.seats) != g.max_seats:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß ÿ≥ŸÜÿßÿ±€åŸà ÿßŸÜÿ™ÿÆÿßÿ® Ÿà ŸáŸÖŸá ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ŸæŸèÿ± ÿ¥ŸàŸÜÿØ.")
            return

        repeats = random.randint(1, 30)
        g.shuffle_repeats = repeats 

        try:
            await shuffle_and_assign(
                ctx,
                chat,
                g,
                shuffle_seats=False,
                uid_to_role=None,
                notify_players=False,
                preview_mode=True,
                role_shuffle_repeats=repeats,  
            )
            await ctx.bot.send_message(chat, f"üé≤ ŸÜŸÇÿ¥‚ÄåŸáÿß {repeats} ÿ®ÿßÿ± ÿ±ŸÜÿØŸàŸÖ ÿ¥ÿØ.")
           
        except Exception:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ÿ±ŸÜÿØŸàŸÖ ŸÜŸÇÿ¥.")

        store.save()
        return



    # ‚îÄ‚îÄ‚îÄ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å‚ÄåŸáÿß ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data == "init_vote":
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        g.voted_targets = set()  # üßπ ÿ±€åÿ≥ÿ™ ÿ™€å⁄©‚ÄåŸáÿß€å ŸÇÿ®ŸÑ€å ŸáŸÜ⁄ØÿßŸÖ ÿ¥ÿ±Ÿàÿπ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ¨ÿØ€åÿØ
        await start_vote(ctx, chat, g, "initial_vote")
        return


    if data == "back_vote_init" and uid == g.god_id:
        g.phase = "voting_selection"
        g.voted_targets = set()  # üßπ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ŸÇÿ®ŸÑÿßŸã ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å‚Äåÿ¥ÿØŸá
        store.save()
        await ctx.bot.send_message(chat, "‚Ü©Ô∏è ŸÖÿ¨ÿØÿØÿßŸã ⁄©ÿßŸÜÿØ€åÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.")
        await start_vote(ctx, chat, g, "initial_vote")
        return


    if data == "final_vote" and uid == g.god_id:
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚ö†Ô∏è ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å ÿ±ÿß ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜÿØ!")
            return

        g.vote_type = "awaiting_defense"
        g.voted_targets = set()  # üßπ Ÿæÿß⁄©‚Äåÿ≥ÿßÿ≤€å ŸÑ€åÿ≥ÿ™ ÿ™€å⁄©‚ÄåŸáÿß ÿ®ÿ±ÿß€å ÿ±ÿ£€å‚Äå⁄Ø€åÿ±€å ŸÜŸáÿß€å€å
        store.save()

        msg = await ctx.bot.send_message(
            chat,
            "üì¢ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (ŸÖÿ´ÿßŸÑ: 1 3 5):",
            reply_markup=ForceReply(selective=True)
        )
        g.defense_prompt_msg_id = msg.message_id
        store.save()
        return

    if data == "status_query" and uid == g.god_id:
        g.status_mode = True
        await publish_seating(ctx, chat, g, mode="status")
        return

    if g.status_mode:
        changed = False

        if data == "inc_citizen":
            g.status_counts["citizen"] += 1
            changed = True

        elif data == "dec_citizen":
            if g.status_counts["citizen"] == 0:
                
                await safe_q_answer(q, "ÿßÿ≤ ÿµŸÅÿ± ⁄©ŸÖÿ™ÿ± ŸÜŸÖ€åÿ¥Ÿá.", show_alert=True)
                warn = await ctx.bot.send_message(chat, "‚ö†Ô∏è  ⁄©ŸÖÿ™ÿ± ÿßÿ≤ ÿµŸÅÿ± ŸÜŸÖ€å‚Äåÿ¥ŸàÿØ.")
               
                async def _cleanup(msg_id: int):
                    await asyncio.sleep(2)
                    try:
                        await ctx.bot.delete_message(chat_id=chat, message_id=msg_id)
                    except Exception:
                        pass
                asyncio.create_task(_cleanup(warn.message_id))
                # UI ÿ±ÿß ŸáŸÖÿßŸÜ ÿ≠ÿßŸÑÿ™ status ŸÜ⁄ØŸá ÿØÿßÿ±
                await publish_seating(ctx, chat, g, mode="status")
                return
            g.status_counts["citizen"] -= 1
            changed = True

        elif data == "inc_mafia":
            g.status_counts["mafia"] += 1
            changed = True

        elif data == "dec_mafia":
            if g.status_counts["mafia"] == 0:
                await safe_q_answer(q, "ÿßÿ≤ ÿµŸÅÿ± ⁄©ŸÖÿ™ÿ± ŸÜŸÖ€åÿ¥Ÿá.", show_alert=True)
                warn = await ctx.bot.send_message(chat, "‚ö†Ô∏è  ⁄©ŸÖÿ™ÿ± ÿßÿ≤ ÿµŸÅÿ± ŸÜŸÖ€å‚Äåÿ¥ŸàÿØ.")
                async def _cleanup(msg_id: int):
                    await asyncio.sleep(2)
                    try:
                        await ctx.bot.delete_message(chat_id=chat, message_id=msg_id)
                    except Exception:
                        pass
                asyncio.create_task(_cleanup(warn.message_id))
                await publish_seating(ctx, chat, g, mode="status")
                return
            g.status_counts["mafia"] -= 1
            changed = True

        elif data == "confirm_status":
            g.status_mode = False
            store.save()

            c = g.status_counts.get("citizen", 0)
            m = g.status_counts.get("mafia", 0)

            await ctx.bot.send_message(
                chat,
                f"üì¢ ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ Ÿàÿ∂ÿπ€åÿ™ :\n {c} ÿ¥Ÿáÿ±ŸàŸÜÿØ\n {m} ŸÖÿßŸÅ€åÿß"
            )
            await publish_seating(ctx, chat, g, mode=CTRL)
            return

        if changed:
            store.save()
            await publish_seating(ctx, chat, g, mode="status")
        return



    if data == "back_vote_final" and uid == g.god_id:
        g.phase = "defense_selection"
        g.vote_type = "awaiting_defense"
        g.voted_targets = set()  # üßπ Ÿæÿß⁄©‚Äåÿ≥ÿßÿ≤€å ŸÑ€åÿ≥ÿ™ ÿ™€å⁄©‚ÄåŸáÿß ŸáŸÜ⁄ØÿßŸÖ ÿ®ÿ±⁄Øÿ¥ÿ™
        store.save()

        msg = await ctx.bot.send_message(
            chat,
            "‚Ü©Ô∏è ÿØŸàÿ®ÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=ForceReply(selective=True)
        )
        g.defense_prompt_msg_id = msg.message_id
        store.save()
        return

    if data.startswith("vote_"):
        if uid != g.god_id:
            await ctx.bot.send_message(chat,"‚õî ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ±ÿ£€å ÿ®ÿØŸáÿØ!")
            return
        seat_str = data.split("_")[1]
        if seat_str.isdigit():
            await handle_vote(ctx, chat, g, int(seat_str))
        return

def status_button_markup(g: GameState) -> InlineKeyboardMarkup:
    c = g.status_counts.get("citizen", 0)
    m = g.status_counts.get("mafia", 0)
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(f"‚ö™ {c}", callback_data="noop"),
            InlineKeyboardButton("‚¨ÜÔ∏è", callback_data="inc_citizen"),
            InlineKeyboardButton("‚¨áÔ∏è", callback_data="dec_citizen")
        ],
        [
            InlineKeyboardButton(f"‚ö´ {m}", callback_data="noop"),
            InlineKeyboardButton("‚¨ÜÔ∏è", callback_data="inc_mafia"),
            InlineKeyboardButton("‚¨áÔ∏è", callback_data="dec_mafia")
        ],
        [
            InlineKeyboardButton("‚úÖ ÿ™ÿ£€å€åÿØ", callback_data="confirm_status")
        ]
    ])

def strike_button_markup(g: GameState) -> InlineKeyboardMarkup:
    rows = []

    for i in range(1, g.max_seats + 1):
        if i in g.pending_strikes:
            label = f"{i} ‚ùå"
        else:
            label = f"{i} ‚úÖ"
        rows.append([InlineKeyboardButton(label, callback_data=f"strike_toggle_{i}")])

    # ÿØ⁄©ŸÖŸá ÿ™ÿß€å€åÿØ ŸÜŸáÿß€å€å
    rows.append([InlineKeyboardButton("‚úÖ ÿ™ÿß€å€åÿØ ÿÆÿ∑‚Äåÿ≤ÿØŸÜ", callback_data="strike_toggle_done")])

    return InlineKeyboardMarkup(rows)


async def shuffle_and_assign(
    ctx,
    chat_id: int,
    g: GameState,
    shuffle_seats: bool = True,
    uid_to_role: dict[int, str] | None = None,
    notify_players: bool = True,
    preview_mode: bool = False,
    role_shuffle_repeats: int = 1,
):

    # 1) ÿ®ÿßÿ≤€å⁄©ŸÜ‚ÄåŸáÿß ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ™ÿ±ÿ™€åÿ® ŸÅÿπŸÑ€å ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß
    players = [g.seats[i] for i in sorted(g.seats)]
    uids = [uid for uid, _ in players]

    # 2) ÿß⁄Øÿ± ŸÜ⁄Øÿßÿ¥ÿ™ ŸÜŸÇÿ¥‚Üíÿ®ÿßÿ≤€å⁄©ŸÜ ÿØÿßÿØŸá ŸÜÿ¥ÿØŸáÿå ÿß€åŸÜÿ¨ÿß ÿ®ÿ≥ÿßÿ≤ (ŸÖÿ≥ÿ™ŸÇŸÑ ÿßÿ≤ ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å)
    if uid_to_role is None:
        pool = [r for r, n in g.scenario.roles.items() for _ in range(n)]
        uids_for_roles = uids[:]
        reps = max(1, int(role_shuffle_repeats))
        for _ in range(reps):
            random.shuffle(pool)
            random.shuffle(uids_for_roles)
        uid_to_role = {uid_: pool[i] for i, uid_ in enumerate(uids_for_roles)}

    # 3) ÿ≠ÿßŸÑÿ™ Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥: ŸÅŸÇÿ∑ ŸÜ⁄Øÿßÿ¥ÿ™ ÿ±ÿß ÿ∞ÿÆ€åÿ±Ÿá ⁄©ŸÜ Ÿà ÿÆÿßÿ±ÿ¨ ÿ¥Ÿà (Ÿá€å⁄Ü Ÿæ€åÿßŸÖ/ÿ™ÿ∫€å€åÿ±€å ÿßÿπŸÖÿßŸÑ ŸÜ⁄©ŸÜ)
    if preview_mode:
        g.preview_uid_to_role = uid_to_role
        store.save()
        return uid_to_role

    # 4) ŸÜŸáÿß€å€å‚Äåÿ≥ÿßÿ≤€å: ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜ€åÿßÿ≤ÿå ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿ±ÿß ÿ®Ÿá ÿ™ÿπÿØÿßÿØ ŸÖÿ¥ÿÆÿµ ÿ¥ÿßŸÅŸÑ ⁄©ŸÜ
    if shuffle_seats:
        reps = max(1, int(role_shuffle_repeats))
        for _ in range(reps):
            random.shuffle(players)

    g.seats = {i + 1: (uid, name) for i, (uid, name) in enumerate(players)}

    # 5) ŸÜÿ≥ÿ®ÿ™‚ÄåÿØÿßÿØŸÜ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ®Ÿá ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß ÿßÿ≤ ÿ±Ÿà€å uid
    g.assigned_roles = {
        seat: uid_to_role[g.seats[seat][0]]
        for seat in g.seats
    }

    # 6) ÿßÿ±ÿ≥ÿßŸÑ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ®Ÿá ÿ®ÿßÿ≤€å⁄©ŸÜ‚ÄåŸáÿß (ÿßÿÆÿ™€åÿßÿ±€å) Ÿà ÿ≥ÿßÿÆÿ™ ŸÑÿß⁄Ø ÿ®ÿ±ÿß€å ⁄ØÿßÿØ
    log, unreachable = [], []
    stickers = load_stickers()
    if notify_players:
        for seat in sorted(g.seats):
            uid, name = g.seats[seat]
            role = g.assigned_roles[seat]
            if role in stickers:
                try:
                    await ctx.bot.send_sticker(uid, stickers[role])
                except:
                    pass
            try:
                await ctx.bot.send_message(uid, f"üé≠ ŸÜŸÇÿ¥ ÿ¥ŸÖÿß: {role}")
            except telegram.error.Forbidden:
                unreachable.append(name)

    for seat in sorted(g.seats):
        uid, name = g.seats[seat]
        role = g.assigned_roles[seat]
        log.append(f"{seat:>2}. {name} ‚Üí {role}")

    if g.god_id:
        text = "üëë ÿÆŸÑÿßÿµŸáŸî ŸÜŸÇÿ¥‚ÄåŸáÿß:\n" + "\n".join(log)
        if unreachable:
            text += "\n‚ö†Ô∏è ŸÜÿ¥ÿØ ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿßŸÅÿ±ÿßÿØ Ÿæ€åÿßŸÖ ÿ®ŸÅÿ±ÿ≥ÿ™ŸÖ: " + ", ".join(unreachable)
        try:
            await ctx.bot.send_message(g.god_id, text)
        except:
            pass

    # 7) ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÅÿßÿ≤ Ÿà UI
    g.phase = "playing"
    store.save()
    await publish_seating(ctx, chat_id, g, mode=CTRL)

    return uid_to_role





async def handle_simple_seat_command(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    chat_id = msg.chat.id
    uid = msg.from_user.id
    g = gs(chat_id)

    # ‚õî ŸÅŸÇÿ∑ ÿØÿ± ÿ≠ÿßŸÑÿ™ "idle" ÿßÿ¨ÿßÿ≤Ÿá ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ®ÿß /ÿπÿØÿØ Ÿáÿ≥ÿ™
    if g.phase != "idle":
        return

    if not hasattr(g, 'user_names') or g.user_names is None:
        g.user_names = load_usernames_from_gist()

    command_text = msg.text.split('@')[0]
    try:
        seat_no = int(command_text[1:])
    except:
        return

    if seat_no in g.seats:
        await ctx.bot.send_message(chat_id, f"‚ùó ÿµŸÜÿØŸÑ€å {seat_no} ŸÇÿ®ŸÑÿßŸã ŸæŸèÿ± ÿ¥ÿØŸá.")
        return

    if uid in [u for u, _ in g.seats.values()]:
        await ctx.bot.send_message(chat_id, "‚ùó ÿ¥ŸÖÿß ŸÇÿ®ŸÑÿßŸã ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.")
        return

    name = g.user_names.get(uid, "ŸÜÿßÿ¥ŸÜÿßÿ≥")
    g.seats[seat_no] = (uid, name)
    store.save()
    await publish_seating(ctx, chat_id, g)
    await ctx.bot.send_message(chat_id, f"‚úÖ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å {seat_no} ÿ®ÿß ŸÜÿßŸÖ ¬´{name}¬ª ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ.")


async def name_reply(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if not msg or not msg.text:
        return

    text = msg.text.strip()
    uid = msg.from_user.id
    chat_id = msg.chat.id
    g = gs(chat_id)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # 1) ÿ™ÿ∫€å€åÿ± ÿ≥ÿßÿπÿ™ ÿ¥ÿ±Ÿàÿπ (ŸÅŸÇÿ∑ ÿ™Ÿàÿ≥ÿ∑ ⁄ØÿßÿØ) ‚Äì ÿ®ÿß €åÿß ÿ®ÿØŸàŸÜ ÿ±€åŸæŸÑÿß€å
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if g.vote_type == "awaiting_time" and uid == g.god_id:

        g.event_time = text
        g.vote_type = None
        store.save()
        await publish_seating(ctx, chat_id, g)
        await ctx.bot.send_message(chat_id, f"‚úÖ ÿ≥ÿßÿπÿ™ ÿ±Ÿà€åÿØÿßÿØ ÿ±Ÿà€å {text} ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ.")
        return

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # 2) ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ/ÿ¨ÿßÿ®ÿ¨ÿß€å€å ÿ®ÿß ÿ±€åŸæŸÑÿß€å ÿ®Ÿá ŸÑ€åÿ≥ÿ™: ⁄©ÿßÿ±ÿ®ÿ± ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å ŸÖ€å‚ÄåŸÜŸà€åÿ≥ÿØ
    #    - ÿß⁄Øÿ± ŸÇÿ®ŸÑÿßŸã ŸÜÿ¥ÿ≥ÿ™Ÿá ÿ®ŸàÿØÿå ÿ¨ÿßÿ®Ÿá‚Äåÿ¨ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ
    #    - ÿß⁄Øÿ± ÿßÿ≥ŸÖ ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿ®ÿßÿ¥ÿØÿå ¬´ŸÜÿßÿ¥ŸÜÿßÿ≥¬ª
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (
        msg.reply_to_message
        and g.last_seating_msg_id
        and msg.reply_to_message.message_id == g.last_seating_msg_id
    ):
        if text.isdigit():
            seat_no = int(text)

            if not (1 <= seat_no <= g.max_seats):
                await ctx.bot.send_message(chat_id, "‚ùå ÿ¥ŸÖÿßÿ±ŸáŸî ÿµŸÜÿØŸÑ€å ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™.")
                return

            if seat_no in g.seats:
                await ctx.bot.send_message(chat_id, f"‚ùå ÿµŸÜÿØŸÑ€å {seat_no} ŸÇÿ®ŸÑÿßŸã ŸæŸèÿ± ÿ¥ÿØŸá.")
                return

            # ŸÜÿßŸÖ ÿ™ÿ±ÿ¨€åÿ≠€å
            preferred_name = g.user_names.get(uid, None)

            # ÿ¢€åÿß ⁄©ÿßÿ±ÿ®ÿ± ŸÇÿ®ŸÑÿßŸã ÿ±Ÿà€å ÿµŸÜÿØŸÑ€å‚Äåÿß€å ŸÜÿ¥ÿ≥ÿ™Ÿáÿü
            existing_seat = None
            existing_name = None
            for s, (u, n) in g.seats.items():
                if u == uid:
                    existing_seat = s
                    existing_name = n
                    break

            final_name = preferred_name or existing_name or "ŸÜÿßÿ¥ŸÜÿßÿ≥"

            if existing_seat is not None:
                # ÿ¨ÿßÿ®ÿ¨ÿß€å€å
                del g.seats[existing_seat]
                g.seats[seat_no] = (uid, final_name)
                store.save()
                await publish_seating(ctx, chat_id, g)
                await ctx.bot.send_message(
                    chat_id,
                    f"‚Ü™Ô∏è ¬´{final_name}¬ª ÿßÿ≤ ÿµŸÜÿØŸÑ€å {existing_seat} ÿ®Ÿá ÿµŸÜÿØŸÑ€å {seat_no} ŸÖŸÜÿ™ŸÇŸÑ ÿ¥ÿØ."
                )
                return

            # ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ¨ÿØ€åÿØ
            g.seats[seat_no] = (uid, final_name)
            store.save()
            await publish_seating(ctx, chat_id, g)
            await ctx.bot.send_message(
                chat_id,
                f"‚úÖ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å {seat_no} ÿ®ÿß ŸÜÿßŸÖ ¬´{final_name}¬ª ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ."
            )
            return

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # 3) ÿ™ÿ∫€å€åÿ± ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± (ŸÅŸÇÿ∑ ŸàŸÇÿ™€å ÿßÿ≤ ÿØ⁄©ŸÖŸá ¬´‚úèÔ∏è ÿ™ÿ∫€å€åÿ± ŸÜÿßŸÖ¬ª Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá)
    #    g.waiting_name[uid] = seat_no
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if uid in g.waiting_name:
        target_seat = g.waiting_name[uid]  # ŸÅŸÑ⁄Ø ÿ±ÿß ŸÅÿπŸÑÿßŸã Ÿæÿß⁄© ŸÜ⁄©ŸÜ€åŸÖ

        import re
        if not re.match(r'^[\u0600-\u06FF\s]+$', text):
            await ctx.bot.send_message(
                chat_id,
                "‚ùó ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿ±ÿß ŸÅŸÇÿ∑ ÿ®ÿß ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ. ÿØŸàÿ®ÿßÿ±Ÿá ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ€åÿØ:"
            )
            return

        # Ÿàÿ±ŸàÿØ€å ŸÖÿπÿ™ÿ®ÿ± ÿ¥ÿØ ‚Üí ŸÅŸÑ⁄Ø ÿ±ÿß Ÿæÿß⁄© ⁄©ŸÜ
        g.waiting_name.pop(uid, None)

        # ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿßŸÖ ÿ¨ÿØ€åÿØ ÿØÿ± ÿØŸÅÿ™ÿ±⁄ÜŸá
        g.user_names[uid] = text

        # ÿß⁄Øÿ± ŸáŸÜŸàÿ≤ ÿ±Ÿà€å ŸáŸÖÿßŸÜ ÿµŸÜÿØŸÑ€å ÿßÿ≥ÿ™ÿå ŸáŸÖÿßŸÜ ÿ±ÿß ÿ¢ŸæÿØ€åÿ™ ⁄©ŸÜ
        if target_seat in g.seats and g.seats[target_seat][0] == uid:
            g.seats[target_seat] = (uid, text)
            changed_seat = target_seat
        else:
            # ÿß⁄Øÿ± ÿ¨ÿß€å ÿØ€å⁄Øÿ±€å ŸÜÿ¥ÿ≥ÿ™Ÿáÿå ÿµŸÜÿØŸÑ€å ŸÅÿπŸÑ€å‚Äåÿßÿ¥ ÿ±ÿß Ÿæ€åÿØÿß Ÿà ÿ¢ŸæÿØ€åÿ™ ⁄©ŸÜ
            changed_seat = None
            for s, (u, n) in list(g.seats.items()):
                if u == uid:
                    g.seats[s] = (uid, text)
                    changed_seat = s
                    break

        store.save()
        await publish_seating(ctx, chat_id, g)

        # Ÿæ€åÿßŸÖ ÿ™ÿ£€å€åÿØ
        if changed_seat:
            await ctx.bot.send_message(chat_id, f"‚úÖ ŸÜÿßŸÖ ÿµŸÜÿØŸÑ€å {changed_seat} ÿ®Ÿá ¬´{text}¬ª ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ.")
        else:
            await ctx.bot.send_message(chat_id, f"‚úÖ ŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®Ÿá ¬´{text}¬ª ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ.")

        # ŸÜŸàÿ¥ÿ™ŸÜ ÿ±Ÿà€å Gist ÿ®ÿπÿØ ÿßÿ≤ UI (ÿ®ÿ±ÿß€å ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ⁄©ŸÜÿØ€å)
        try:
            save_usernames_to_gist(g.user_names)
        except Exception:
            pass

        return





async def show_scenario_selection(ctx, chat_id: int, g: GameState):
    """ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ÿ≥ŸÜÿßÿ±€åŸàŸáÿß€å ŸÖŸàÿ¨ŸàÿØ ÿ®ÿ±ÿß€å ÿßŸÜÿ™ÿÆÿßÿ®"""
    valid_scenarios = [s for s in store.scenarios if sum(s.roles.values()) == g.max_seats]
    
    if not valid_scenarios:
        await ctx.bot.send_message(chat_id, "‚ùó ÿ≥ŸÜÿßÿ±€åŸà€å ŸÖŸÜÿßÿ≥ÿ® ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿ™ÿπÿØÿßÿØ ÿ®ÿßÿ≤€å⁄©ŸÜ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.")
        return
    
    # ÿß€åÿ¨ÿßÿØ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ≥ŸÜÿßÿ±€åŸà
    btns = [
        [InlineKeyboardButton(f"{s.name} ({sum(s.roles.values())} ŸÜŸÅÿ±)", callback_data=f"sc_{i}")]
        for i, s in enumerate(valid_scenarios)
    ]
    
    # ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿØ⁄©ŸÖŸá ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿß⁄Øÿ± ÿ®ÿßÿ≤€å ÿØÿ± ÿ≠ÿßŸÑ ÿßŸÜÿ¨ÿßŸÖ ÿßÿ≥ÿ™
    if g.phase != "idle":
        btns.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_game")])
    
    # ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà
    scenario_msg = await ctx.bot.send_message(
        chat_id,
        "üé≠ ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿ≥ŸÜÿßÿ±€åŸà ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
        reply_markup=InlineKeyboardMarkup(btns)
    )
    # ÿ∞ÿÆ€åÿ±Ÿá message_id ÿ®ÿ±ÿß€å ÿ≠ÿ∞ŸÅ ÿ®ÿπÿØ€å
    g.scenario_prompt_msg_id = scenario_msg.message_id
    g.awaiting_scenario = True
    store.save()


async def newgame(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat.id
    uid = update.effective_user.id

    # ŸÅŸÇÿ∑ ⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å ŸÅÿπÿßŸÑ
    if chat not in store.active_groups:
        await update.message.reply_text("‚õî ÿß€åŸÜ ⁄Øÿ±ŸàŸá ŸáŸÜŸàÿ≤ ŸÅÿπÿßŸÑ ŸÜÿ¥ÿØŸá. ÿßÿØŸÖ€åŸÜ ÿßÿµŸÑ€å ÿ®ÿß€åÿØ /active ÿ®ÿ≤ŸÜÿØ.")
        return

    # ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß
    if update.effective_chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ ⁄Øÿ±ŸàŸá
    member = await ctx.bot.get_chat_member(chat, uid)
    if member.status not in {"administrator", "creator"}:
        await update.message.reply_text("ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿ®ÿßÿ≤€å ÿ¨ÿØ€åÿØ ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜŸÜ.")
        return

    # ÿß⁄Øÿ± ÿ¢ÿ±⁄ØŸàŸÖÿßŸÜ ŸÜÿØÿßÿØ ‚Üí Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ €±€∞
    seats = 10
    if ctx.args and ctx.args[0].isdigit():
        seats = int(ctx.args[0])

    # ÿ≥ÿßÿÆÿ™ ⁄Ø€åŸÖ ÿ¨ÿØ€åÿØ
    store.games[chat] = GameState(max_seats=seats)
    g = gs(chat)

    # ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å/ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿßŸÖ‚ÄåŸáÿß ÿØÿ± Gist
    g.user_names = load_usernames_from_gist()
    save_usernames_to_gist(g.user_names)

    # ⁄ØÿßÿØ Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ = ÿßÿ¨ÿ±ÿß⁄©ŸÜŸÜÿØŸáŸî /newgame
    god_name = g.user_names.get(uid) or (update.effective_user.full_name or "‚Äî")
    g.god_id = uid
    g.god_name = god_name

    # ÿ≥ŸÜÿßÿ±€åŸà€å ÿ™ÿµÿßÿØŸÅ€å ÿ®ÿß ÿ∏ÿ±ŸÅ€åÿ™ seats
    candidates = [s for s in store.scenarios if sum(s.roles.values()) == seats]
    if candidates:
        import random
        g.scenario = random.choice(candidates)
        g.last_roles_scenario_name = None  # ÿ™ÿß ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿØŸàÿ®ÿßÿ±Ÿá ⁄ÜÿßŸæ ÿ¥ŸàÿØ
        g.awaiting_scenario = False
    else:
        g.scenario = None
        g.awaiting_scenario = True

    # ÿ¢ŸÖÿßÿ± ¬´waiting_list¬ª
    now = datetime.now(timezone.utc).timestamp()
    store.group_stats.setdefault(chat, {"waiting_list": [], "started": [], "ended": []})
    store.group_stats[chat]["waiting_list"].append(now)
    store.save()

    # ÿßŸÜÿ™ÿ¥ÿßÿ± ŸÑ€åÿ≥ÿ™ ÿßŸàŸÑ€åŸá
    await publish_seating(ctx, chat, g, mode=REG)
    # ÿß⁄Øÿ± ÿ≥ŸÜÿßÿ±€åŸà Ÿæ€åÿØÿß ŸÜÿ¥ÿØÿå ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥ŸÜÿßÿ±€åŸà ÿ±ÿß ÿ®ÿßÿ≤ ⁄©ŸÜ
    if g.awaiting_scenario:
        g.from_startgame = True
        store.save()
        await show_scenario_selection(ctx, chat, g)



async def reset_game(ctx: ContextTypes.DEFAULT_TYPE = None, update: Update = None, chat_id: int = None):
    """ÿ±€åÿ≥ÿ™ ÿ®ÿßÿ≤€å ÿ®ÿß ÿ≠ŸÅÿ∏ ŸÜÿßŸÖ‚ÄåŸáÿß ‚Äì ŸáŸÖ ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ®ÿ±ÿß€å /resetgame Ÿà ŸáŸÖ ÿßÿ≤ ÿØÿßÿÆŸÑ ÿ®ÿßÿ™"""
    if update:
        chat_id = update.effective_chat.id
    elif not chat_id:
        raise ValueError("chat_id ÿ®ÿß€åÿØ ŸÖÿ¥ÿÆÿµ ÿ¥ŸàÿØ ÿß⁄Øÿ± update Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ")

    # üîÑ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ŸÜÿßŸÖ‚ÄåŸáÿß
    usernames = load_usernames_from_gist()

    store.games[chat_id] = GameState()
    g = store.games[chat_id]
    g.user_names = usernames
    save_usernames_to_gist(g.user_names)
    store.save()

    # ÿß⁄Øÿ± ÿßÿ≤ ÿ∑ÿ±€åŸÇ ÿØÿ≥ÿ™Ÿàÿ± ÿßŸàŸÖÿØŸáÿå Ÿæ€åÿßŸÖ ÿ®ŸÅÿ±ÿ≥ÿ™
    if update and update.message:
        await update.message.reply_text("üîÅ ÿ®ÿßÿ≤€å ÿ®ÿß ÿ≠ŸÅÿ∏ ŸÜÿßŸÖ‚ÄåŸáÿß ÿ±€åÿ≥ÿ™ ÿ¥ÿØ.")

async def resetgame_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    user = update.effective_user

    # ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ¨ÿ±ÿß ÿ®ÿßÿ¥Ÿá
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    # ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ⁄©ÿßÿ±ÿ®ÿ± ÿßÿØŸÖ€åŸÜ Ÿáÿ≥ÿ™ €åÿß ŸÜŸá
    try:
        admins = await ctx.bot.get_chat_administrators(chat.id)
        admin_ids = [admin.user.id for admin in admins]
        if user.id not in admin_ids:
            await update.message.reply_text("ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ÿ±Ÿà ÿßÿ¨ÿ±ÿß ⁄©ŸÜŸÜ.")
            return
    except:
        await update.message.reply_text("ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿ±ÿ±ÿ≥€å ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß.")
        return

    # ÿßÿ¨ÿ±ÿß€å ÿ±€åÿ≥ÿ™ ÿ®ÿßÿ≤€å
    await reset_game(ctx=ctx, update=update)



async def add_seat_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not ctx.args or not ctx.args[0].isdigit():
        await update.message.reply_text("Usage: /add <seat>")
        return

    seat = int(ctx.args[0])
    uid = update.effective_user.id
    chat = update.effective_chat.id
    g = gs(chat)

    if uid != g.god_id:
        return

    if seat in g.seats:
        await update.message.reply_text("‚ùå Seat already taken.")
        return

    if not update.message.reply_to_message:
        await update.message.reply_text("‚ùå Use this command by replying to a message from the user you want to add.")
        return

    target_uid = update.message.reply_to_message.from_user.id

    # üß† ÿ®ÿ±ÿ±ÿ≥€å ŸÜÿßŸÖ ÿ∞ÿÆ€åÿ±Ÿá‚Äåÿ¥ÿØŸá ÿØÿ± gist
    name = g.user_names.get(target_uid, "ŸÜÿßÿ¥ŸÜÿßÿ≥")
    g.seats[seat] = (target_uid, name)
    store.save()

    await update.message.reply_text(f"‚úÖ ÿµŸÜÿØŸÑ€å {seat} ÿ®ÿß ŸÜÿßŸÖ '{name}' ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.")

    # üñ• ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÑ€åÿ≥ÿ™ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß
    await publish_seating(ctx, chat, g)

async def addscenario(update: Update, ctx):
    """/addscenario <name> role1:n1 role2:n2 ..."""

    if update.effective_chat.id not in store.active_groups:
        return  # ⁄Øÿ±ŸàŸá ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤

    # ŸÅŸÇÿ∑ ÿ™Ÿà€å ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ÿ®ÿ±ÿ±ÿ≥€å ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    if update.message.chat.type in ["group", "supergroup"]:
        chat_id = update.effective_chat.id
        user_id = update.effective_user.id
        member = await ctx.bot.get_chat_member(chat_id, user_id)

        if member.status not in ["administrator", "creator"]:
            await update.message.reply_text("‚ö†Ô∏è ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿ≥ŸÜÿßÿ±€åŸà ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜŸÜ.")
            return

    if len(ctx.args) < 2:
        await update.message.reply_text("Usage: /addscenario <name> role1:n1 role2:n2 ...")
        return

    name = ctx.args[0]
    roles: dict[str, int] = {}
    for pair in ctx.args[1:]:
        if ":" in pair:
            r, n = pair.split(":")
            roles[r.strip()] = int(n)

    new_scenario = Scenario(name, roles)
    store.scenarios.append(new_scenario)
    store.save()
    save_scenarios_to_gist(store.scenarios)

    await update.message.reply_text(f"‚úÖ ÿ≥ŸÜÿßÿ±€åŸà '{name}' ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ ÿ®ÿß ŸÜŸÇÿ¥‚ÄåŸáÿß: {roles}")



async def list_scenarios(update: Update, ctx):
    store.scenarios = load_scenarios_from_gist()  # üëà ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿßÿ≤ Gist

    if not store.scenarios:
        await update.message.reply_text("‚ùå No scenarios found.")
        return

    lines = ["üìã ŸÑ€åÿ≥ÿ™ ÿ≥ŸÜÿßÿ±€åŸàŸáÿß:"]
    for i, s in enumerate(store.scenarios, 1):
        role_summary = ", ".join(f"{role}: {count}" for role, count in s.roles.items())
        lines.append(f"{i}. {s.name} ({role_summary})")

    await update.message.reply_text("\n".join(lines))


async def remove_scenario(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat = update.effective_chat

    if chat.id not in store.active_groups:
        return  # ⁄Øÿ±ŸàŸá ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤

    # üîê ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ÿßÿ¨ÿßÿ≤Ÿá ÿØÿßÿ±ŸÜÿØ ÿ≥ŸÜÿßÿ±€åŸà ÿ≠ÿ∞ŸÅ ⁄©ŸÜŸÜÿØ
    if chat.type != "private":
        member = await ctx.bot.get_chat_member(chat.id, user.id)
        if member.status not in ("administrator", "creator"):
            await update.message.reply_text("‚ö†Ô∏è ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ÿ≥ŸÜÿßÿ±€åŸà ÿ≠ÿ∞ŸÅ ⁄©ŸÜŸÜ.")
            return

    if not ctx.args:
        await update.message.reply_text("‚ùå ŸÜÿ≠ŸàŸá ÿßÿ≥ÿ™ŸÅÿßÿØŸá: /removescenario <ŸÜÿßŸÖ ÿ≥ŸÜÿßÿ±€åŸà>")
        return

    name = " ".join(ctx.args).strip()
    before = len(store.scenarios)
    store.scenarios = [s for s in store.scenarios if s.name != name]
    after = len(store.scenarios)

    if before == after:
        await update.message.reply_text(f"‚ö†Ô∏è ÿ≥ŸÜÿßÿ±€åŸà€å€å ÿ®ÿß ŸÜÿßŸÖ ¬´{name}¬ª Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.")
    else:
        store.save()
        save_scenarios_to_gist(store.scenarios)
        await update.message.reply_text(f"üóëÔ∏è ÿ≥ŸÜÿßÿ±€åŸà€å ¬´{name}¬ª ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.")

 
async def dynamic_timer(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat.id
    uid = update.effective_user.id
    g = gs(chat)

    # ‚ùó ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ÿßÿ¨ÿ±ÿß€å ÿ™ÿß€åŸÖÿ± ÿ±Ÿà€å Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ŸÇÿØ€åŸÖ€å (ŸÖÿ´ŸÑÿßŸã ÿØÿ± ŸÑÿ≠ÿ∏ŸáŸî ÿ±€å‚Äåÿßÿ≥ÿ™ÿßÿ±ÿ™ ÿ®ÿßÿ™)
    if (datetime.now(timezone.utc) - update.message.date).total_seconds() > 10:
        return  # ÿß⁄Øÿ± Ÿæ€åÿßŸÖ ÿÆ€åŸÑ€å ŸÇÿØ€åŸÖ€åŸáÿå Ÿá€å⁄Ü€å ŸÜ⁄©ŸÜ

    if uid != g.god_id:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ⁄ØÿßÿØ ŸÖ€å‚Äåÿ™ŸàŸÜŸá ÿ™ÿß€åŸÖÿ± ÿ®ÿ≤ŸÜŸá.")
        return

    cmd = update.message.text.strip().lstrip("/")
    if not cmd.endswith("s") or not cmd[:-1].isdigit():
        await update.message.reply_text("‚ùó ÿØÿ≥ÿ™Ÿàÿ± ÿØÿ±ÿ≥ÿ™ ŸÜ€åÿ≥ÿ™. ŸÖÿ´ÿßŸÑ: /20s")
        return

    seconds = int(cmd[:-1])
    await update.message.reply_text(f"‚è≥ ÿ™ÿß€åŸÖÿ± {seconds} ÿ´ÿßŸÜ€åŸá‚Äåÿß€å ÿ¥ÿ±Ÿàÿπ ÿ¥ÿØ...")
    await asyncio.sleep(seconds)
    await ctx.bot.send_message(chat, "‚è∞ ÿ™ÿß€åŸÖ ÿ™ŸÖÿßŸÖ")


async def transfer_god_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat.id

    # 1) ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å ŸÅÿπÿßŸÑ
    if chat not in store.active_groups:
        await update.message.reply_text("‚õî ÿß€åŸÜ ⁄Øÿ±ŸàŸá ŸáŸÜŸàÿ≤ ŸÅÿπÿßŸÑ ŸÜÿ¥ÿØŸá. ÿßŸàŸÑ /active ÿ±ÿß ÿ®ÿ≤ŸÜ.")
        return

    g = gs(chat)

    # 2) ŸÅŸÇÿ∑ ÿ®ÿπÿØ ÿßÿ≤ ÿ≥ÿßÿÆÿ™ ÿ®ÿßÿ≤€å
    if not g.max_seats or g.max_seats <= 0:
        await update.message.reply_text("‚ö†Ô∏è ÿßŸàŸÑ ÿ®ÿß /newgame <seats> ÿ®ÿßÿ≤€å ÿ®ÿ≥ÿßÿ≤ÿå ÿ®ÿπÿØ /god ÿ®ÿ≤ŸÜ.")
        return

    # ‚úÖ ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß €åÿß ⁄ØÿßÿØ ŸÅÿπŸÑ€å ÿßÿ¨ÿßÿ≤Ÿá ÿ™ÿ∫€å€åÿ± ⁄ØÿßÿØ ÿØÿßÿ±ŸÜÿØ
    admins = await ctx.bot.get_chat_administrators(chat)
    admin_ids = {admin.user.id for admin in admins}
    is_current_god = update.effective_user.id == g.god_id
    if update.effective_user.id not in admin_ids and not is_current_god:
        await update.message.reply_text("‚ùå ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿ±ŸàŸá €åÿß ⁄ØÿßÿØ ŸÅÿπŸÑ€å ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ⁄ØÿßÿØ ÿ±Ÿà ÿπŸàÿ∂ ⁄©ŸÜŸÜ.")
        return

    if not update.message.reply_to_message:
        await update.message.reply_text("‚ùå ŸÑÿ∑ŸÅÿßŸã ÿ±Ÿà€å Ÿæ€åÿßŸÖ ⁄©ÿ≥€å ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ Ÿà ÿ®ÿπÿØ /god ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.")
        return

    target = update.message.reply_to_message.from_user
    if g.god_id == target.id:
        await update.message.reply_text("‚ÑπÔ∏è ŸáŸÖ€åŸÜ ÿ≠ÿßŸÑÿß ŸáŸÖ ⁄ØÿßÿØ Ÿáÿ≥ÿ™.")
        return
    # ŸÜÿßŸÖ ÿ™ÿ±ÿ¨€åÿ≠€å: ÿßÿ≤ gist ÿß⁄Øÿ± ŸÖŸàÿ¨ŸàÿØÿå Ÿà⁄Øÿ±ŸÜŸá ŸÜÿßŸÖ ÿ™ŸÑ⁄Øÿ±ÿßŸÖ
    new_name = g.user_names.get(target.id, target.full_name)

    g.god_id = target.id
    g.god_name = new_name
    store.save()

    await update.message.reply_text(f"‚úÖ ÿ≠ÿßŸÑÿß ⁄ØÿßÿØ ÿ¨ÿØ€åÿØ ÿ®ÿßÿ≤€åŸá {new_name}.")

    mode = CTRL if g.phase != "idle" else REG
    await publish_seating(ctx, chat, g, mode=mode)

    if g.phase != "idle":
        log = []
        for seat in sorted(g.assigned_roles):
            role = g.assigned_roles.get(seat, "‚Äî")
            name = g.seats[seat][1]
            log.append(f"{name} ‚á¶ {role}")
        try:
            await ctx.bot.send_message(
                target.id,
                "üëë ÿ¥ŸÖÿß ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ⁄ØÿßÿØ ÿ¨ÿØ€åÿØ ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØ€åÿØ.\n\nüßæ ŸÑ€åÿ≥ÿ™ ŸÜŸÇÿ¥‚ÄåŸáÿß:\n" + "\n".join(log)
            )
        except telegram.error.Forbidden:
            await update.message.reply_text("‚ö†Ô∏è ŸÜÿ™ŸàŸÜÿ≥ÿ™ŸÖ ŸÜŸÇÿ¥‚ÄåŸáÿß ÿ±Ÿà ÿ®Ÿá Ÿæ€åŸà€å ⁄ØÿßÿØ ÿ¨ÿØ€åÿØ ÿ®ŸÅÿ±ÿ≥ÿ™ŸÖ.")



async def handle_direct_name_input(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if not msg or not msg.text:
        return

    chat_id = msg.chat.id
    uid = msg.from_user.id
    g = gs(chat_id)
    text = msg.text.strip()

    if g.vote_type == "awaiting_time" and uid == g.god_id:
        g.event_time = text
        g.vote_type = None
        store.save()
        await publish_seating(ctx, chat_id, g)
        await ctx.bot.send_message(chat_id, f"‚úÖ ÿ≥ÿßÿπÿ™ ÿ±Ÿà€åÿØÿßÿØ ÿ±Ÿà€å {text} ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ.")
        return


    # ÿ´ÿ®ÿ™ ŸÜÿßŸÖ ÿ®ÿ±ÿß€å ÿµŸÜÿØŸÑ€å
    if uid in g.awaiting_name_input:
        seat_no = g.awaiting_name_input.pop(uid)

        import re
        if not re.match(r'^[\u0600-\u06FF\s]+$', text):
            await ctx.bot.send_message(chat_id, "‚ùó ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿ±ÿß ŸÅŸÇÿ∑ ÿ®ÿß ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
            return

        g.seats[seat_no] = (uid, text)
        g.user_names[uid] = text
        save_usernames_to_gist(g.user_names)
        store.save()

        if uid in g.last_name_prompt_msg_id:
            try:
                await ctx.bot.delete_message(
                    chat_id=chat_id,
                    message_id=g.last_name_prompt_msg_id[uid]
                )
            except:
                pass
            del g.last_name_prompt_msg_id[uid]

        await publish_seating(ctx, chat_id, g)
        return  

    # -------------- defense seats by God ------------------
    if g.vote_type == "awaiting_defense" and uid == g.god_id:
        nums = [int(n) for n in text.split() if n.isdigit() and int(n) in g.seats]

        # ÿß⁄Øÿ± Ÿàÿ±ŸàÿØ€å ŸÖÿπÿ™ÿ®ÿ± ŸÜÿ®ŸàÿØÿå Ÿæ€åÿßŸÖ ÿÆÿ∑ÿß ÿ®ÿØŸá Ÿà ÿ®ÿ±⁄Øÿ±ÿØ
        if not nums:
            await ctx.bot.send_message(chat_id, "‚ùå ÿ¥ŸÖÿßÿ±Ÿá ÿµŸÜÿØŸÑ€å ŸÖÿπÿ™ÿ®ÿ± Ÿàÿßÿ±ÿØ ŸÜÿ¥ÿØ. ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ (ŸÖÿ´ÿßŸÑ: 1 3 5).")
            return

        g.defense_seats = nums
        g.vote_type = None  # ‚úÖ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿ≠ÿßŸÑÿ™ Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØŸÜ ÿµŸÜÿØŸÑ€å ÿØŸÅÿßÿπ

        # üßπ ÿ≠ÿ∞ŸÅ Ÿæ€åÿßŸÖ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ
        if g.defense_prompt_msg_id:
            try:
                await ctx.bot.delete_message(chat_id=chat_id, message_id=g.defense_prompt_msg_id)
            except:
                pass
            g.defense_prompt_msg_id = None

        store.save()
        await ctx.bot.send_message(chat_id, f"‚úÖ ÿµŸÜÿØŸÑ€å‚ÄåŸáÿß€å ÿØŸÅÿßÿπ: {', '.join(map(str, nums))}")
        await start_vote(ctx, chat_id, g, "final")
        return


async def handle_stats_request(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    now = datetime.now(timezone.utc).timestamp()
    day_ago = now - 86400  # 24 ÿ≥ÿßÿπÿ™ ⁄Øÿ∞ÿ¥ÿ™Ÿá

    msg_lines = []
    running_groups = []
    recruiting_groups = []

    for gid, g in store.games.items():
        g: GameState
        stats = store.group_stats.get(gid, {})
        started = sum(1 for t in stats.get("started", []) if t > day_ago)
        ended = sum(1 for t in stats.get("ended", []) if t > day_ago)

        try:
            chat = await ctx.bot.get_chat(gid)
            if chat.username:
                name = f"<a href='https://t.me/{chat.username}'>{chat.title or chat.username}</a> (<code>{gid}</code>)"
                is_private = False
            else:
                name = f"{chat.title or '⁄Øÿ±ŸàŸá ÿÆÿµŸàÿµ€å'}  <code>{gid}</code>"
                is_private = True
        except:
            name = f"(⁄Øÿ±ŸàŸá ŸÜÿßÿ¥ŸÜÿßÿ≥) <code>{gid}</code>"
            is_private = True


        # Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπŸÑ€å
        if g.phase == "playing":
            running_groups.append(name)
        elif (
            g.scenario and
            g.god_id and
            len(g.seats) < g.max_seats and
            g.phase != "playing"
        ):
            recruiting_groups.append(name)

        msg_lines.append(f"üë• {name}:\n‚è∫ {started} ÿ¥ÿ±Ÿàÿπ\n‚èπ {ended} Ÿæÿß€åÿßŸÜ\n")

    final_msg = "\n".join(msg_lines)
    final_msg += "\n\nüéÆ <b>⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å€å ⁄©Ÿá ÿ®ÿßÿ≤€å ŸÅÿπÿßŸÑ ÿØÿßÿ±ŸÜ:</b>\n" + ", ".join(running_groups or ["‚Äî"])
    final_msg += "\n\nü™ë <b>⁄Øÿ±ŸàŸá‚ÄåŸáÿß€å€å ⁄©Ÿá ÿØÿ± ÿ≠ÿßŸÑ ÿπÿ∂Ÿà⁄Ø€åÿ±€å Ÿáÿ≥ÿ™ŸÜ:</b>\n" + ", ".join(recruiting_groups or ["‚Äî"])

    await ctx.bot.send_message(
        update.effective_chat.id,
        final_msg,
        parse_mode="HTML",
        disable_web_page_preview=True
    )

async def leave_group(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != 99347107:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ŸÖÿØ€åÿ± ÿßÿµŸÑ€å ÿ®ÿßÿ™ ÿßÿ¨ÿßÿ≤Ÿá ÿØÿßÿ±ÿØ ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ÿ±ÿß ÿßÿ¨ÿ±ÿß ⁄©ŸÜÿØ.")
        return

    if not ctx.args:
        await update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã Chat ID ⁄Øÿ±ŸàŸá ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return

    try:
        chat_id = int(ctx.args[0])
        await ctx.bot.leave_chat(chat_id)
        await update.message.reply_text(f"‚úÖ ÿ®ÿßÿ™ ÿßÿ≤ ⁄Øÿ±ŸàŸá {chat_id} ÿÆÿßÿ±ÿ¨ ÿ¥ÿØ.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ⁄Øÿ±ŸàŸá: {e}")

OWNER_IDS = {99347107, 449916967, 7501892705,5904091398}


async def activate_group(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    user_id = update.effective_user.id
    if user_id not in OWNER_IDS:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ÿßÿµŸÑ€å ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ⁄Øÿ±ŸàŸá ÿ±Ÿà ŸÅÿπÿßŸÑ ⁄©ŸÜŸÜ.")
        return

    store.active_groups.add(chat.id)
    store.save()
    ok = save_active_groups(store.active_groups)
    if not ok:
        await update.message.reply_text("‚ö†Ô∏è ⁄Øÿ±ŸàŸá ŸÅÿπÿßŸÑ ÿ¥ÿØÿå ÿßŸÖÿß ÿ∞ÿÆ€åÿ±Ÿá ÿØÿ± Gist ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.")
        return

    await update.message.reply_text("‚úÖ ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÅÿπÿßŸÑ ÿ¥ÿØ.")


async def deactivate_group(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in {"group", "supergroup"}:
        await update.message.reply_text("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿØÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™.")
        return

    user_id = update.effective_user.id
    if user_id not in OWNER_IDS:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ÿßÿµŸÑ€å ŸÖ€å‚Äåÿ™ŸàŸÜŸÜ ⁄Øÿ±ŸàŸá ÿ±Ÿà ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ŸÜŸÜ.")
        return

    if chat.id in store.active_groups:
        store.active_groups.remove(chat.id)
        store.save()
        ok = save_active_groups(store.active_groups)
        if not ok:
            await update.message.reply_text("‚ö†Ô∏è ⁄Øÿ±ŸàŸá ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ŸÖÿ≠ŸÑ€å ÿ≠ÿ∞ŸÅ ÿ¥ÿØÿå ŸàŸÑ€å ÿ∞ÿÆ€åÿ±Ÿá ÿØÿ± Gist ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.")
            return
        await update.message.reply_text("üõë ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿ¥ÿØ Ÿà ÿßÿ≤ Gist ŸáŸÖ Ÿæÿß⁄© ÿ¥ÿØ.")
    else:
        await update.message.reply_text("‚ÑπÔ∏è ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿßÿ≤ ŸÇÿ®ŸÑ ŸÅÿπÿßŸÑ ŸÜÿ®ŸàÿØ.")


async def set_event_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat_id_int = update.effective_chat.id
    chat_id = str(chat_id_int)
    g = gs(chat_id_int)

    if update.effective_user.id != g.god_id:
        await update.message.reply_text("‚ùå ŸÅŸÇÿ∑ ÿ±ÿßŸà€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ¥ŸÖÿßÿ±Ÿá ÿß€åŸàŸÜÿ™ ÿ±ÿß ÿ™ÿ∫€å€åÿ± ÿØŸáÿØ.")
        return

    if not ctx.args or not ctx.args[0].isdigit():
        await update.message.reply_text("‚ö†Ô∏è ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿµÿ≠€åÿ≠: /setevent <ÿ¥ŸÖÿßÿ±Ÿá>")
        return

    num = int(ctx.args[0])

    # ‚úÖ ÿ®Ÿá ÿ¨ÿß€å load/save ÿÆÿßŸÖÿå ÿßÿ≤ ⁄©ÿ¥ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ Ÿà ŸáŸÖŸàŸÜ ÿ±Ÿà ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ⁄©ŸÜ
    nums = get_event_numbers()             # ‚Üê ÿßÿ≤ ⁄©ÿ¥ ŸÖ€å‚ÄåÿÆŸàÿßŸÜ€åŸÖ
    nums[chat_id] = num                    # ‚Üê ⁄©ÿ¥ ÿ±ÿß ÿ®ŸÑÿßŸÅÿßÿµŸÑŸá ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    save_event_numbers(nums)               # ‚Üê ÿ≥Ÿæÿ≥ €å⁄© PATCH ÿ®Ÿá Gist

    # ÿ≠ÿßŸÑÿß ŸÑ€åÿ≥ÿ™ ÿ±ÿß ÿßÿØ€åÿ™ ⁄©ŸÜÿõ ⁄ÜŸàŸÜ ⁄©ÿ¥ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ¥ÿØŸáÿå ŸÖÿ™ŸÜ ÿ¨ÿØ€åÿØ ŸÖ€å‚Äåÿ¥ŸàÿØ
    try:
        mode = CTRL if g.phase != "idle" else REG
        await publish_seating(ctx, chat_id_int, g, mode=mode)
    except Exception:
        pass

    await update.message.reply_text(f"‚úÖ ÿ¥ŸÖÿßÿ±Ÿá ÿß€åŸàŸÜÿ™ ÿ®ÿ±ÿß€å ÿß€åŸÜ ⁄Øÿ±ŸàŸá ÿ±Ÿà€å {num} ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ.")


MY_ID = 99347107 

async def add_sticker_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    # ŸÅŸÇÿ∑ ÿ¢€åÿØ€å ÿ™Ÿà
    if update.effective_user.id != MY_ID:
        await update.message.reply_text("‚õî ŸÅŸÇÿ∑ ÿßÿØŸÖ€åŸÜ ÿßÿµŸÑ€å ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿßÿ≥ÿ™€å⁄©ÿ± ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜÿØ.")
        return

    # ⁄Ü⁄© ⁄©ŸÜ ÿ±Ÿà€å ÿßÿ≥ÿ™€å⁄©ÿ± ÿ±€åŸæŸÑÿß€å ÿ¥ÿØŸá €åÿß ŸÜŸá
    if not update.message.reply_to_message or not update.message.reply_to_message.sticker:
        await update.message.reply_text("‚ö†Ô∏è ÿ®ÿß€åÿØ ÿ±Ÿà€å Ÿæ€åÿßŸÖ ÿßÿ≥ÿ™€å⁄©ÿ± ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ.")
        return

    if not ctx.args:
        await update.message.reply_text("‚ö†Ô∏è ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿµÿ≠€åÿ≠: /addsticker <ŸÜÿßŸÖ ŸÜŸÇÿ¥>")
        return

    role_name = " ".join(ctx.args).strip()
    file_id = update.message.reply_to_message.sticker.file_id

    stickers = load_stickers()
    stickers[role_name] = file_id
    save_stickers(stickers)

    await update.message.reply_text(f"‚úÖ ÿßÿ≥ÿ™€å⁄©ÿ± ÿ®ÿ±ÿß€å ŸÜŸÇÿ¥ ¬´{role_name}¬ª ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ.")

async def on_error(update: object, context: ContextTypes.DEFAULT_TYPE):
    err = context.error
    # BadRequest Ÿáÿß€å ÿ®€å‚ÄåÿßŸáŸÖ€åÿ™ ÿ±Ÿà ŸÜÿßÿØ€åÿØŸá ÿ®⁄Ø€åÿ±
    if isinstance(err, BadRequest) and ("Query is too old" in str(err) or "query id is invalid" in str(err)):
        return
    try:
        chat_id = update.effective_chat.id if update and hasattr(update, "effective_chat") else None
        print(f"[ERROR] chat={chat_id} err={err}")
    except Exception:
        pass
async def main():
    app = ApplicationBuilder().token(TOKEN).build()
    app.add_error_handler(on_error)
    app.add_handler(CommandHandler("active", activate_group))
    app.add_handler(CommandHandler("deactivate", deactivate_group))
    # üëâ ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ŸáŸÜÿØŸÑÿ±Ÿáÿß
    app.add_handler(CommandHandler("newgame", newgame, filters=group_filter))
    app.add_handler(CommandHandler("leave", leave_group, filters=filters.ChatType.PRIVATE & filters.User(99347107)))
    # ü™ë ÿßŸÜÿ™ÿÆÿßÿ® ÿµŸÜÿØŸÑ€å ÿ®ÿß ÿØÿ≥ÿ™Ÿàÿ± ŸÖÿ´ŸÑ /3
    app.add_handler(
        MessageHandler(
            filters.Regex(r"^/\d+(@PouriaMafiaBot)?$") & filters.ChatType.GROUPS,
            handle_simple_seat_command
        )
    )
    app.add_handler(CommandHandler("resetgame", resetgame_cmd, filters=group_filter))
    app.add_handler(CommandHandler("addscenario", addscenario, filters=group_filter))
    app.add_handler(CommandHandler("listscenarios", list_scenarios, filters=group_filter))
    app.add_handler(CommandHandler("removescenario", remove_scenario, filters=group_filter))
    app.add_handler(CommandHandler("add", add_seat_cmd, filters=group_filter))
    app.add_handler(CommandHandler("god", transfer_god_cmd, filters=group_filter))
    app.add_handler(CommandHandler("setevent", set_event_cmd, filters=group_filter))
    app.add_handler(CommandHandler("addsticker", add_sticker_cmd, filters=filters.ChatType.PRIVATE))
    # ‚è± ÿ™ÿß€åŸÖÿ± ŸæŸà€åÿß ŸÖÿ´ŸÑ /3s
    app.add_handler(
        MessageHandler(
            filters.COMMAND & filters.Regex(r"^/\d+s$"),
            dynamic_timer
        )
    )

    # üë• ŸáŸÜÿØŸÑÿ± ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß€å ŸÖÿ™ŸÜ€å (ÿßŸàŸÑ name_reply ÿ®ÿßÿ¥Ÿá)
    app.add_handler(
        MessageHandler(
            group_filter & filters.REPLY & filters.TEXT,
            name_reply
        )
    )

    # üßë‚Äçüíª ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß€å ŸÖÿ≥ÿ™ŸÇ€åŸÖ ÿ®ÿØŸàŸÜ ÿ±€åŸæŸÑÿß€å
    app.add_handler(
        MessageHandler(
            group_filter & filters.TEXT & ~filters.REPLY,
            handle_direct_name_input
        )
    )

    # üéÆ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß Ÿà ÿ±ÿß€å‚Äå⁄Ø€åÿ±€å
    app.add_handler(CallbackQueryHandler(callback_router))

    app.add_handler(
        MessageHandler(
            filters.ChatType.PRIVATE
            & filters.User(99347107)
            & filters.TEXT
            & filters.Regex(r"^/stats$"),
            handle_stats_request
        )
    )

      
    # ‚úÖ initialize application
    await app.initialize()

    # üåê ÿ≥ÿßÿÆÿ™ aiohttp ÿ®ÿ±ÿß€å Ÿàÿ®‚ÄåŸáŸà⁄©
    from aiohttp import web
    import os

    aio_app = web.Application()
    aio_app.router.add_get("/", lambda req: web.Response(text="OK"))

    async def webhook_handler(request):
        data = await request.json()
        update = Update.de_json(data, app.bot)
        await app.process_update(update)
        return web.Response()

    aio_app.router.add_post(f"/{TOKEN}", webhook_handler)

    # üì° ÿ™ŸÜÿ∏€åŸÖ ÿ¢ÿØÿ±ÿ≥ Ÿàÿ®‚ÄåŸáŸà⁄©
    webhook_url = f"https://mafia-bot-259u.onrender.com/{TOKEN}"
    await app.bot.set_webhook(webhook_url)

    # üü¢ ÿßÿ¨ÿ±ÿß€å ÿ≥ÿ±Ÿàÿ± aiohttp
    runner = web.AppRunner(aio_app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", int(os.environ.get("PORT", 8080)))
    await site.start()
    print("‚úÖ Webhook server is running...")

    # ‚ñ∂Ô∏è ÿßÿ¨ÿ±ÿß€å ÿßŸæŸÑ€å⁄©€åÿ¥ŸÜ
    await app.start()

    # ‚è≥ ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ÿÆÿßŸÖŸàÿ¥€å ÿ®ÿ±ŸÜÿßŸÖŸá
    await asyncio.Event().wait()


if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

